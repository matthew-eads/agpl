
==================== FINAL INTERFACE ====================
2015-11-17 20:06:01.619321 UTC

interface Agpl_ARbgTy7wgrRJtlloTDRArE:CodeGen 7102
  interface hash: ed75b00eb139038c06da68074e91faf8
  ABI hash: c27bcb26b36b0d02139c3b433e73d9dc
  export-list hash: 7d3f5fde464839d39ac589c638f92031
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b66090cf17f4cc751c68c8377d24c28f
  sig of: Nothing
  used TH splices: False
  where
exports:
  CodeGen.boardT
  CodeGen.customDataDec
  CodeGen.doNothing
  CodeGen.fromStringDec
  CodeGen.gamestateDec
  CodeGen.gsDec
  CodeGen.handT
  CodeGen.initStateDec
  CodeGen.isValidDec
  CodeGen.makeAGPLDecs
  CodeGen.moveDec
  CodeGen.nilD
  CodeGen.outcomeDec
  CodeGen.pieceT
  CodeGen.playerDec
  CodeGen.possmovesDec
  CodeGen.testD
  CodeGen.turnT
  CodeGen.turnTypeDec
module dependencies: Agpl_syntax Parser
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  Agpl_syntax 6e693080fd2e3401d0bcece3ff793395
  exports: f49372cede7d1194d9354766daf6df62
  CustomDataType 3743bbde6a898e90a69bee5f2b38fbc3
  CustomDataType 48613b915782e92460fb1c97264b302e
  FromString 378c95cc08760b802eb72095115961cf
  FromString 57ee07929aa274f142ce19a4748aadda
  Game 0f6bbc897134aa610d0a3a616b1a2fec
  Game 95b8bb5ee7bbeef176d2e105f7777225
  GameState 0aba4775ecc39540cc403fa4e88bc6f5
  InitState 06d8ecc1ef848c51fd936946843d25d7
  IsValidFun f390a8540908186abe27a0d08b334a26
  IsValidFun 248b4294aab3781c6e580a9aaa94cc78
  Move a57477c1bc7aa1d45ebba4549bfa03d3
  Move abe769eedacde8d3bd14bf466b22ce61
  OutcomeFun 902091b882d8a6348f65e483ae6ef26d
  OutcomeFun c7c2fd5b39fbd254818d1c82ac07efcc
  PMNil 1a37829b3fcd6f93677eee0d4384e847
  Player f474a07d17c519bf0b98dab6b0e3e49f
  Player dab944622ceeb2054e623fb47f792a2d
  PossMovesFun 115e478786bddc23b57efa7852844cac
  PossMovesFun b3de14f020e33040f67b90c477a9bd0d
  board 01f7699c0515e469b38172138e1b4737
  boardInit f39c03058bafd9c611c356f9e0e2fa3d
  hand 70c63974ab2e49a928754eb46dad7779
  piece 5b0dee862fc14997345cdae518a67669
  turn 22e60d5b05ffef14131c1c4b1c696766
  turnInit 46ab1d3dd2ad8d53dff0948216848293
import  -/  Parser 5a609fbcbe1b5af82946ffd8244ab002
  exports: 8b31c0fe1bdad23e29098a2775584be3
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH cce81ae8a1596a0252bdcb72179c2937
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Quote 7a74e3dce88866c160fffb1503661817
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax afcf64bad3773d231089a8ce432131ab
0c1e9c227082005d2e40691c8c1e3543
  boardT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.boardT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.boardT1)) -}
ff989193fd587336b329d5c531cbd2e6
  boardT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.boardT2) -}
01f7aebed2336b933c799989526db030
  boardT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
7da84beaedf1e2cb9a261a437808f09a
  boardT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Board"#) -}
332501acc1da3098e29ec7806f52a03d
  boardT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3d585b14b3a8a2a65810059a4602aba2
  boardT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board"#) -}
2b284fa3e44975e178e2bb884a9115e1
  customDataDec ::
    Agpl_syntax.CustomDataType
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.customDataDec1
                  `cast`
                (<Agpl_syntax.CustomDataType>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
25e40d69551efc4db5de158e564521ae
  customDataDec1 ::
    Agpl_syntax.CustomDataType
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.CustomDataType
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.CustomDataType d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
770edfde3d71b12e411684ad1cb8f0e3
  doNothing :: Language.Haskell.TH.Syntax.Q ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.doNothing1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0] <()>_N)) -}
07e038386fc5c4b724a100d53fecf684
  doNothing1 :: Language.Haskell.TH.Syntax.Quasi m => m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ ()
                   GHC.Tuple.()) -}
2cfbbc55f0819439072e7e3f68a87ea1
  fromStringDec ::
    Agpl_syntax.FromString
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.fromStringDec1
                  `cast`
                (<Agpl_syntax.FromString>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
37e1c1e5601093b43cc9a477af1f7d92
  fromStringDec1 ::
    Agpl_syntax.FromString
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.FromString
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.FromString e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.fromStringDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
749a0cd4c875dc73e3907ca50bffecba
  fromStringDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.fromStringDec3) -}
913c0af94449ad20e7bea95e2ed409e8
  fromStringDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.fromStringDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
81b8fb47ea5d638c18b88e803d807da5
  fromStringDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fromString"#) -}
b9d5e0fb4064a5e8f3045e1c2e5249c4
  gamestateDec ::
    Agpl_syntax.GameState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,1*U,A)>,
     Unfolding: (\ gs :: Agpl_syntax.GameState ->
                 let {
                   x :: [Language.Haskell.TH.Syntax.Dec]
                   = case gs of wild { Agpl_syntax.GameState ds1 ds2 ds3 ds4 ds5 ->
                     let {
                       acc :: [Language.Haskell.TH.Syntax.Dec]
                       = let {
                           acc1 :: [Language.Haskell.TH.Syntax.Dec]
                           = case Language.Haskell.TH.Syntax.$fEqDec_$c==
                                    ds2
                                    CodeGen.nilD of wild1 {
                               GHC.Types.False
                               -> GHC.Types.:
                                    @ Language.Haskell.TH.Syntax.Dec
                                    ds2
                                    (case Language.Haskell.TH.Syntax.$fEqDec_$c==
                                            ds1
                                            CodeGen.nilD of wild2 {
                                       GHC.Types.False
                                       -> GHC.Types.:
                                            @ Language.Haskell.TH.Syntax.Dec
                                            ds1
                                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                       GHC.Types.True
                                       -> GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec })
                               GHC.Types.True
                               -> case Language.Haskell.TH.Syntax.$fEqDec_$c==
                                         ds1
                                         CodeGen.nilD of wild2 {
                                    GHC.Types.False
                                    -> GHC.Types.:
                                         @ Language.Haskell.TH.Syntax.Dec
                                         ds1
                                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                    GHC.Types.True
                                    -> GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec } }
                         } in
                         case Language.Haskell.TH.Syntax.$fEqDec_$c==
                                ds3
                                CodeGen.nilD of wild1 {
                           GHC.Types.False
                           -> GHC.Types.: @ Language.Haskell.TH.Syntax.Dec ds3 acc1
                           GHC.Types.True -> acc1 }
                     } in
                     case Language.Haskell.TH.Syntax.$fEqDec_$c==
                            ds4
                            CodeGen.nilD of wild1 {
                       GHC.Types.False
                       -> GHC.Types.: @ Language.Haskell.TH.Syntax.Dec ds4 acc
                       GHC.Types.True -> acc } }
                 } in
                 (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                  GHC.Base.return
                    @ m
                    (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                    @ [Language.Haskell.TH.Syntax.Dec]
                    x)
                   `cast`
                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <[Language.Haskell.TH.Syntax.Dec]>_N))) -}
100def1bfc1a48ca96150837e12a0ad1
  gsDec ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.gsDec1
                  `cast`
                (<[Language.Haskell.TH.Syntax.VarStrictType]>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
535c56c820d94e1b6affaf048ea8aa15
  gsDec1 ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ types :: [Language.Haskell.TH.Syntax.VarStrictType]
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.DataD
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                         CodeGen.gsDec21
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                         (GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Con
                            (Language.Haskell.TH.Syntax.RecC CodeGen.gsDec21 types)
                            CodeGen.gsDec8)
                         CodeGen.gsDec2)
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))) -}
de144c357b4c05dad439a0dec7bed722
  gsDec10 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec11
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
05b6052055fbe58147d8ea54da6cd423
  gsDec11 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec12
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
0f8d1c9d74224fab3c2a970bcd4868ee
  gsDec12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
c51e75658eecb7570252c64ace915013
  gsDec13 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec19
                   CodeGen.gsDec14) -}
804a7d7661a637f0dcb7cdcfecb8bf3a
  gsDec14 :: [Language.Haskell.TH.Syntax.StrictType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.StrictType
                   CodeGen.gsDec15
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
57ece085d9f74e342bddb8f61c12b076
  gsDec15 ::
    (Language.Haskell.TH.Syntax.Strict,
     Language.Haskell.TH.Syntax.Type)
  {- Strictness: m,
     Unfolding: ((Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.gsDec16)) -}
262a6275dceb24bd3067bf810aa41157
  gsDec16 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.gsDec17) -}
295c7e3cab9f382d422bb46817e2206e
  gsDec17 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec18
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
7ce034b2611c82ae9d1222290d5619ac
  gsDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Player"#) -}
6b71f6bba8d0e4c63324d5b17d4e9c6b
  gsDec19 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec20
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
fbfe3879a2992fdb99b45df1e7a6611e
  gsDec2 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec6
                   CodeGen.gsDec3) -}
6fbef49b33f764fa91203ee690d1226f
  gsDec20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win"#) -}
5d98f946266205582da1110dbcc2f81d
  gsDec21 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec22
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
e378171f88925e20142d326771c6dea7
  gsDec22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState"#) -}
aa9e09d685b7dfc1598f604f8519ba82
  gsDec3 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec4
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
423f54f8991c58dd0c0f77ebd7976f2d
  gsDec4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
35fa1a52a299670f34c1b2cb5ff3f7de
  gsDec5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Eq"#) -}
d02ff8c641e3547a39fb332107e368b5
  gsDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
047b9593650f92ac28be8b75c85fae92
  gsDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Show"#) -}
a1d1cc2ab443fd0f647bf3a3a793fcf6
  gsDec8 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec13
                   CodeGen.gsDec9) -}
a855916d2c69a2687a602b9125907a65
  gsDec9 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec10
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
aea777fa1d22f300f0ea4c0ad3646053
  handT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.handT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.handT1)) -}
70c96c1bccdf2c397bcc7f6e65f423fc
  handT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.handT2) -}
1b700115145611f19d45cdfbf77aa9db
  handT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
d6b1f26f1502579185c0371ba6326c26
  handT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hand"#) -}
81afa77a5c72de2e8f16d92c8b89d63c
  handT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
65bfb6d7d2ab4e3be456e34ab2652ef1
  handT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hand"#) -}
aa9d665dd28e41238b59240fe37c1531
  initStateDec ::
    Agpl_syntax.InitState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.initStateDec1
                  `cast`
                (<Agpl_syntax.InitState>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
ab6c63a0a846f65ceb07ee283314c2eb
  initStateDec1 ::
    Agpl_syntax.InitState
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ is :: Agpl_syntax.InitState
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.initStateDec5
                         (Language.Haskell.TH.Syntax.NormalB
                            (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds1 }))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.:
                         @ Language.Haskell.TH.Syntax.Dec
                         (Language.Haskell.TH.Syntax.ValD
                            CodeGen.initStateDec2
                            (Language.Haskell.TH.Syntax.NormalB
                               (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds2 }))
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)))) -}
11aaaf6c53624ac0828a6d7ab1cda5f0
  initStateDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec3) -}
4e8bd9b60fca7b1a79c694036c9a147c
  initStateDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
0108c9b7bd21f43d382f1633c4b89836
  initStateDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turn"#) -}
9fba7a8c21239ccf8a29c26eebeaf193
  initStateDec5 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec6) -}
1fa9194befb4b0e3b325c5160552e2f9
  initStateDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
4e4953500389657bb29fd5a76f8aafa3
  initStateDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boardInitF"#) -}
c7456bc7ce365d7d0e360877d5640d3f
  isValidDec ::
    Agpl_syntax.IsValidFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.isValidDec1
                  `cast`
                (<Agpl_syntax.IsValidFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
a8c7c9a1f915da284e6d6d822f06d56c
  isValidDec1 ::
    Agpl_syntax.IsValidFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.IsValidFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.IsValidFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.isValidDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
ad03df3e1efaa8bf775e9e3b30e988c8
  isValidDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.isValidDec3) -}
76aadad7652c638b83a737e03c6cbbc0
  isValidDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.isValidDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
45238b375d2e5c015f5e6dee0e78fe59
  isValidDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "isValid"#) -}
bbe339902acf8217e92ee49fa5216b81
  makeAGPLDecs ::
    Agpl_syntax.Game
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U> -}
b8993ae657b95835a00d37b2edf587a8
  moveDec ::
    Agpl_syntax.Move
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.moveDec1
                  `cast`
                (<Agpl_syntax.Move>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
8de1caa7ceacbbdf013fa217ab95869e
  moveDec1 ::
    Agpl_syntax.Move
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Move
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Move d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
5170ac59c528cf91560616ec6545b6e9
  nilD :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m3,
     Unfolding: (Language.Haskell.TH.Syntax.DataD
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.nilD1
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
e7e624b0a29e882c9c718c2105e9a7a1
  nilD1 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.nilD2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
e6a14586bca45b4aa51011741594eb72
  nilD2 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
b758f98be46aa3c6bca56b763ef5c29d
  nilD3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.nilD4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
39804335bc6d5d7554679c05774a057b
  nilD4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NULL"#) -}
505c255ed0f5c9a16237b7cdc224958c
  outcomeDec ::
    Agpl_syntax.OutcomeFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.outcomeDec1
                  `cast`
                (<Agpl_syntax.OutcomeFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
45f7e29783491ebb9409ba5b5e56f084
  outcomeDec1 ::
    Agpl_syntax.OutcomeFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.OutcomeFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.OutcomeFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.outcomeDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
fdd9bef54c8f26ec2c68b76b00e93e6d
  outcomeDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.outcomeDec3) -}
2075f01a2e09dd0075fa355b8bab090e
  outcomeDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
7b9d283ad7c0e15f8a877791f67c8a2d
  outcomeDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "outcome"#) -}
fc861c4c01e1839c53b14c768d0ffeb7
  pieceT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.pieceT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.pieceT1)) -}
f6f1594193d19cbf6104bc29d2d77c3f
  pieceT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.pieceT2) -}
19b820e70f93a77ab8ee0a71fb969509
  pieceT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
97947b39f6881bb4b3c36615ad6ac29f
  pieceT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Piece"#) -}
3205aaf477aa2eccb6760a608575669f
  pieceT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3ca23b2e2bcaeeec51b50b255309c4eb
  pieceT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "piece"#) -}
3f13d9d34c3184bd59dc9c0b2095b67c
  playerDec ::
    Agpl_syntax.Player
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.playerDec1
                  `cast`
                (<Agpl_syntax.Player>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
6aac2993e69ca14e32a95e0ca25d7295
  playerDec1 ::
    Agpl_syntax.Player
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Player
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Player d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
4408f352a647837ae03541b48f84bc85
  possmovesDec ::
    Agpl_syntax.PossMovesFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.possmovesDec1
                  `cast`
                (<Agpl_syntax.PossMovesFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
4219300b672688eb9b49083889845301
  possmovesDec1 ::
    Agpl_syntax.PossMovesFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.PossMovesFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.PossMovesFun e
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.:
                           @ Language.Haskell.TH.Syntax.Dec
                           (Language.Haskell.TH.Syntax.ValD
                              CodeGen.possmovesDec2
                              (Language.Haskell.TH.Syntax.NormalB e)
                              (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                           (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                   Agpl_syntax.PMNil
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
6335961e2dba713e01127f28bee60616
  possmovesDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.possmovesDec3) -}
d8a54f627f5a073e08977fc8e28e1eb7
  possmovesDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.possmovesDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
fdfbd810aa7f6575d347c276f4835b7c
  possmovesDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "possMoves"#) -}
e88d1d30d56770b8c460b9afcb88ad66
  testD ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.testD1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
532fedfd21c2db8d1fa109b89e700d0b
  testD1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 let {
                   lvl11 :: GHC.Base.Monad m
                   = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                 } in
                 let {
                   lvl12 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD16
                 } in
                 let {
                   lvl13 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD15
                 } in
                 let {
                   lvl14 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD14
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl11
                   @ Language.Haskell.TH.Syntax.Name
                   @ [Language.Haskell.TH.Syntax.Dec]
                   lvl14
                   (\ x :: Language.Haskell.TH.Syntax.Name ->
                    GHC.Base.>>=
                      @ m
                      lvl11
                      @ Language.Haskell.TH.Syntax.Name
                      @ [Language.Haskell.TH.Syntax.Dec]
                      lvl14
                      (\ x1 :: Language.Haskell.TH.Syntax.Name ->
                       GHC.Base.>>=
                         @ m
                         lvl11
                         @ Language.Haskell.TH.Syntax.Name
                         @ [Language.Haskell.TH.Syntax.Dec]
                         lvl13
                         (\ x2 :: Language.Haskell.TH.Syntax.Name ->
                          let {
                            a2 :: forall (m1 :: * -> *).
                                  Language.Haskell.TH.Syntax.Quasi m1 =>
                                  m1 Language.Haskell.TH.Syntax.VarStrictType
                              {- Arity: 1 -}
                            = Language.Haskell.TH.Lib.varStrictType1
                                x2
                                CodeGen.testD10
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <Language.Haskell.TH.Syntax.StrictType>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            lvl11
                            @ Language.Haskell.TH.Syntax.Name
                            @ [Language.Haskell.TH.Syntax.Dec]
                            lvl12
                            (\ x3 :: Language.Haskell.TH.Syntax.Name ->
                             Language.Haskell.TH.Syntax.sequenceQ2
                               @ Language.Haskell.TH.Syntax.Dec
                               (GHC.Types.:
                                  @ Language.Haskell.TH.Lib.DecQ
                                  (Language.Haskell.TH.Lib.dataD1
                                     CodeGen.testD9
                                       `cast`
                                     (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                               <[Language.Haskell.TH.Syntax.Pred]>_N))
                                     x
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                                     (GHC.Types.:
                                        @ Language.Haskell.TH.Lib.ConQ
                                        (Language.Haskell.TH.Lib.recC1
                                           x1
                                           (GHC.Types.:
                                              @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                              a2
                                                `cast`
                                              (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                        <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                              (GHC.Types.:
                                                 @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                                 (Language.Haskell.TH.Lib.varStrictType1
                                                    x3
                                                    CodeGen.testD2
                                                      `cast`
                                                    (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                              <Language.Haskell.TH.Syntax.StrictType>_N)))
                                                   `cast`
                                                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                           <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                                 (GHC.Types.[]
                                                    @ Language.Haskell.TH.Lib.VarStrictTypeQ))))
                                          `cast`
                                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                  <Language.Haskell.TH.Syntax.Con>_N))
                                        (GHC.Types.[] @ Language.Haskell.TH.Lib.ConQ))
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name))
                                    `cast`
                                  (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                            <Language.Haskell.TH.Syntax.Dec>_N))
                                  (GHC.Types.[] @ Language.Haskell.TH.Lib.DecQ))
                               @ m
                               $dQuasi))))) -}
a1db841124b31e20e9ff3af595885262
  testD10 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD11
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
ed55460cb153c251796e8b9d63a5e9f5
  testD11 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD12)) -}
172f5ab4c76c84dc704ed4a99666cb1f
  testD12 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD13
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
5253adcfa106c669cb1155360f1a997c
  testD13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Int"#) -}
fe8e594899c7c1b874290f122d11fcf5
  testD14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A"#) -}
1103e4d81f8567af22aff6cbc038fcce
  testD15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "b"#) -}
9dab8ee66bab5945da6ea03905293230
  testD16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
d1b839bea6aa6a537bea6d5bd01636a0
  testD2 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD3
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
80072081294d84267953ba271bc739cd
  testD3 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD4)) -}
85daefcd7f1c46a7b15b00bdc6942b7c
  testD4 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD8
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
32df9d67d9175b8a78d7b076113b8b5c
  testD5 :: Language.Haskell.TH.Syntax.NameFlavour
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.NameG
                   Language.Haskell.TH.Syntax.TcClsName
                   CodeGen.testD7
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:PkgName[0]))
                   CodeGen.testD6
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:ModName[0]))) -}
71377ebbe6ad1048deb1beb4b7a07c69
  testD6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GHC.Types"#) -}
83fdd98140225f80330fb741465349af
  testD7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ghc-prim"#) -}
5d1e9b12ba5cbfa03d9e27240e2d8202
  testD8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Char"#) -}
56a972132f1836cfcc34b7c4f151dc6a
  testD9 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Pred]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLLLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta1 :: Language.Haskell.TH.Syntax.Quasi m ->
                 Language.Haskell.TH.Lib.cxt2
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)
                   @ m
                   eta1) -}
ab8fa3ea456262cacca2c0ec62d8af4e
  turnT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.turnT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.turnT1)) -}
cefd77ca3e11f76de57e04a9ce0b3b33
  turnT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.turnT2) -}
996f654ea201987c98f4bf64292b5fbc
  turnT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a416f8e4692755acc5b2f9a8ae7ba76a
  turnT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Turn"#) -}
af50f17a375b745f11d171de6a51e02f
  turnT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
d450482fa3c24dbd8908a342858e0218
  turnT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn"#) -}
0676774ddd111a93acb4767b9a12d261
  turnTypeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.turnTypeDec1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
ab69a836900960bf7044b845ca9b2e20
  turnTypeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   CodeGen.turnTypeDec2) -}
181ed54e3f0699eb55182ea7d0709198
  turnTypeDec2 :: [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Dec
                   CodeGen.turnTypeDec3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
ab567413a8de4c0fba643bfbb38b249e
  turnTypeDec3 :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.TySynD
                   CodeGen.turnT2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.gsDec16) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

