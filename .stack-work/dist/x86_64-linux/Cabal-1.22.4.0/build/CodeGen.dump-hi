
==================== FINAL INTERFACE ====================
2015-11-27 19:33:35.519414 UTC

interface Agpl_01dT6SXeKAJ0RDOHBmKHBU:CodeGen 7102
  interface hash: a2740cacac062b2d7183f9e5a0d49bba
  ABI hash: bf82513eb578bf4a414c693d29195034
  export-list hash: acce175c2f5df579122936ae82cdb5b1
  orphan hash: ab876434d53120bef7ce39f90b5e9748
  flag hash: b66090cf17f4cc751c68c8377d24c28f
  sig of: Nothing
  used TH splices: False
  where
exports:
  CodeGen.boardT
  CodeGen.conToName
  CodeGen.customDataDec
  CodeGen.doNothing
  CodeGen.emptyDec
  CodeGen.fromStringDec
  CodeGen.gamestateDec
  CodeGen.gsDec
  CodeGen.handT
  CodeGen.inBoundsDec
  CodeGen.initStateDec
  CodeGen.isValidDec
  CodeGen.makeAGPLDecs
  CodeGen.moveDec
  CodeGen.nilD
  CodeGen.otherPlayerClause
  CodeGen.otherPlayerDec
  CodeGen.outcomeDec
  CodeGen.pieceT
  CodeGen.placeDec
  CodeGen.playerDec
  CodeGen.possmovesDec
  CodeGen.sizeDec
  CodeGen.testD
  CodeGen.turnT
  CodeGen.turnTypeDec
module dependencies: Agpl_syntax Parser
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  Agpl_syntax 6e54cfe657c092e4f217d654caacdd85
  exports: f0ee46e9f2fb04531fa8549554a62c0b
  Array 755c1a9b08ac25640fcf1f6a7552154c
  Board 9a7b0b5c0ee45f2b049cba188c3f615b
  Board c75d27e513d9668ca9ff65ae62b51e2d
  CustOutcomeFun 99959f5bffdb68c5608fcfe143103f8c
  CustomDataType 829828159547d99b42af28143c2df8c0
  CustomDataType ce25e86f36dd09be7a3f1a633a33205a
  FromString 2a3f88d67ee744b08176cb938fdd089a
  FromString 9de1f1c5c56bc150313b6f981a05186a
  Game 5d53a97bc56a88658b8371ca663a25dd
  Game 156b1b525f2358ad7a2bbc4e9bf3f87a
  GameState 871c7054332f33d83571ccf90ab002f6
  InitState eb234e934f004d266de185b45dfeb6d3
  IsValidFun 40bf8545f7118b9bc9201e7f115278d6
  IsValidFun 6c84a7fea3c724bb4ea5a77b300f4d0d
  Matrix 378fef45079a34a1017de2ef99dd5e9c
  Move a2b8ccad36b388a3b276aead23e0a28e
  Move c027ec37f3d8d7b80ac83549849cdc3e
  OutcomeFun 0305492e3b70695edb64cf4eacecc879
  PMNil 3f3b6c9dd043015fa4949f98f6b2e5a1
  Player e95530792462ae33498205b11884e7fb
  Player 153b6c1fe30397fa22e3d9401e47e221
  PossMovesFun 6cb1f7bf10608d79bae7db86971e75e5
  PossMovesFun 5753c96b872cf107753d361a048f55b0
  board 2c316276ae18138e2c2a47e9c966e4f0
  boardInit a1599c207cb1a9360a3751511be41345
  elsecon 46e2bb0b288855d07122cc45ec9a4a38
  hand 445609a9a462f8ede27301f8c56c89aa
  piece 5cffbb5bcc8b2fd379d0d16984165ecf
  tiecon 44ebc67cc0e798682233058f3dc90479
  turn 3bf320bf15c8260db9c1a64ddc880aff
  turnInit 40f33898b60bb1d95ca0635a1258fdd7
  wincon 807686047d65c4f03f925e7bdf9b6ad4
import  -/  Parser 76cfebc0436cd69b024a066bb9e59159
  exports: 8c9a4297d157f81e9e9950d9fcfba6cf
import  -/  base-4.8.1.0:Data.Either bc9482e78cc431fce439b593377aa2e6
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8:Language.Haskell.Meta.Parse c926810653cf52d957a896d138bd5ba0
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH cce81ae8a1596a0252bdcb72179c2937
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Quote 7a74e3dce88866c160fffb1503661817
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax afcf64bad3773d231089a8ce432131ab
import  -/  vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector 1ab51bec0be594f8c3b5e22942541591
c138c3ad65d2b1bd56e763ca54a71934
  $wotherPlayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: Language.Haskell.TH.Syntax.Dec ->
                 case w of wild {
                   DEFAULT -> CodeGen.otherPlayerDec3
                   Language.Haskell.TH.Syntax.DataD ds ds1 ds2 players ds3
                   -> case ds of wild1 {
                        []
                        -> case ds2 of wild2 {
                             []
                             -> let {
                                  a9 :: [Language.Haskell.TH.Syntax.Clause]
                                  = let {
                                      playerNames :: [Language.Haskell.TH.Syntax.Name]
                                      = GHC.Base.map
                                          @ Language.Haskell.TH.Syntax.Con
                                          @ Language.Haskell.TH.Syntax.Name
                                          CodeGen.conToName
                                          players
                                    } in
                                    let {
                                      a10 :: Language.Haskell.TH.Syntax.Name
                                      = CodeGen.otherPlayerDec_go
                                          playerNames
                                          (GHC.List.lastError @ Language.Haskell.TH.Syntax.Name)
                                    } in
                                    let {
                                      a11 :: Language.Haskell.TH.Syntax.Pat
                                      = Language.Haskell.TH.Syntax.ConP
                                          a10
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)
                                    } in
                                    let {
                                      a12 :: [Language.Haskell.TH.Syntax.Pat]
                                      = GHC.Types.:
                                          @ Language.Haskell.TH.Syntax.Pat
                                          a11
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)
                                    } in
                                    let {
                                      a13 :: Language.Haskell.TH.Syntax.Name
                                      = case playerNames of wild3 {
                                          [] -> GHC.List.badHead @ Language.Haskell.TH.Syntax.Name
                                          : x ds4 -> x }
                                    } in
                                    let {
                                      a14 :: Language.Haskell.TH.Syntax.Exp
                                      = Language.Haskell.TH.Syntax.ConE a13
                                    } in
                                    let {
                                      a15 :: Language.Haskell.TH.Syntax.Body
                                      = Language.Haskell.TH.Syntax.NormalB a14
                                    } in
                                    let {
                                      a16 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                                      = Language.Haskell.TH.Syntax.Clause
                                          a12
                                          a15
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                    } in
                                    let {
                                      z :: [Language.Haskell.TH.Syntax.Clause]
                                      = GHC.Types.:
                                          @ Language.Haskell.TH.Syntax.Clause
                                          a16
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                                    } in
                                    letrec {
                                      go :: [Language.Haskell.TH.Syntax.Name]
                                            -> [Language.Haskell.TH.Syntax.Name]
                                            -> [Language.Haskell.TH.Syntax.Clause]
                                        {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                                      = \ ds4 :: [Language.Haskell.TH.Syntax.Name]
                                          _ys :: [Language.Haskell.TH.Syntax.Name] ->
                                        case ds4 of wild3 {
                                          [] -> z
                                          : ipv ipv1
                                          -> case _ys of wild4 {
                                               [] -> z
                                               : ipv2 ipv3
                                               -> GHC.Types.:
                                                    @ Language.Haskell.TH.Syntax.Clause
                                                    (CodeGen.otherPlayerClause ipv ipv2)
                                                    (go ipv1 ipv3) } }
                                    } in
                                    go
                                      playerNames
                                      (CodeGen.$wunsafeDrop
                                         @ Language.Haskell.TH.Syntax.Name
                                         1
                                         playerNames)
                                } in
                                let {
                                  a10 :: Language.Haskell.TH.Syntax.Dec
                                  = Language.Haskell.TH.Syntax.FunD CodeGen.otherPlayerDec1 a9
                                } in
                                let {
                                  x :: [Language.Haskell.TH.Syntax.Dec]
                                  = GHC.Types.:
                                      @ Language.Haskell.TH.Syntax.Dec
                                      a10
                                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                } in
                                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                                 GHC.Base.return
                                   @ m
                                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                                   @ [Language.Haskell.TH.Syntax.Dec]
                                   x)
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <[Language.Haskell.TH.Syntax.Dec]>_N))
                             : ipv ipv1 -> CodeGen.otherPlayerDec3 }
                        : ipv ipv1 -> CodeGen.otherPlayerDec3 } }) -}
f40c346919cc52a0b3eca5dba0146302
  $wplayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: Language.Haskell.TH.Syntax.Dec ->
                 let {
                   ds :: Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
                   = CodeGen.$wotherPlayerDec ww
                 } in
                 (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                  let {
                    lvl23 :: GHC.Base.Monad m
                    = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                  } in
                  GHC.Base.>>=
                    @ m
                    lvl23
                    @ [Language.Haskell.TH.Syntax.Dec]
                    @ [Language.Haskell.TH.Syntax.Dec]
                    (ds
                       `cast`
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)
                       @ m
                       $dQuasi)
                    (\ x :: [Language.Haskell.TH.Syntax.Dec] ->
                     GHC.Base.return
                       @ m
                       lvl23
                       @ [Language.Haskell.TH.Syntax.Dec]
                       (GHC.Types.: @ Language.Haskell.TH.Syntax.Dec ww x)))
                   `cast`
                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <[Language.Haskell.TH.Syntax.Dec]>_N))) -}
fbbb40e5e4ace2cee15c99c0ae4907e6
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
620d3d0d3d9e24cad054a0612ca29cf9
  boardT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.boardT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.boardT1)) -}
14bb05b656239354556066c5d2d89d03
  boardT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.boardT2) -}
94cf134dee59730e3b7367339593eb7c
  boardT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
50cf8cbb2d62b31d66992905f3ae149d
  boardT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Board"#) -}
4f722a78bf4b947cc8c24ef02af71e4b
  boardT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
e6855856492ea1b3a954ad6bdc498071
  boardT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board"#) -}
bba245dace178cd2f2c249d6c07ebe9d
  conToName ::
    Language.Haskell.TH.Syntax.Con -> Language.Haskell.TH.Syntax.Name
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Language.Haskell.TH.Syntax.Con ->
                 case ds of wild {
                   Language.Haskell.TH.Syntax.NormalC name ds1 -> name
                   Language.Haskell.TH.Syntax.RecC name ds1 -> name
                   Language.Haskell.TH.Syntax.InfixC ds1 name ds2 -> name
                   Language.Haskell.TH.Syntax.ForallC ipv ipv1 ipv2
                   -> GHC.Err.undefined @ Language.Haskell.TH.Syntax.Name }) -}
cdbbbb5cd91fcb13a75bae12e3003a68
  customDataDec ::
    Agpl_syntax.CustomDataType
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.customDataDec1
                  `cast`
                (<Agpl_syntax.CustomDataType>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
67974b93a0876a19b24d1863e646c00c
  customDataDec1 ::
    Agpl_syntax.CustomDataType
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.CustomDataType
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.CustomDataType d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
df22f86efd476b224681415b3bd91d01
  doNothing :: Language.Haskell.TH.Syntax.Q ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.doNothing1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0] <()>_N)) -}
bb3f280f3a340f745b043cf587ddceef
  doNothing1 :: Language.Haskell.TH.Syntax.Quasi m => m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ ()
                   GHC.Tuple.()) -}
f77ea70ab4719efdaa1a7f68735da6fb
  emptyDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.emptyDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
f6709614bf851b8f03a2b625a870e71f
  emptyDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.Board
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.Matrix ds1
                   -> case CodeGen.emptyDec5 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Array ds1
                   -> case CodeGen.emptyDec2 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Board ipv
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
095763842e8d8592f66f4e9bec205378
  emptyDec2 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec3 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
6aad8d84d31e5274f3c808b5d5398576
  emptyDec3 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec4) -}
e9233a32c71041d812e8820042f69304
  emptyDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty i game = (((board game) V.! i) == Nil)"#) -}
d15c0ad839b650473d5824acd245b133
  emptyDec5 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec6 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
20992fe714dbb12b6b2b3bb45e4ad3e1
  emptyDec6 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec7) -}
d382ce7503244cbfd397ed22aa4ae4e8
  emptyDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty (i, j) game = (((board game) M.! (i,j)) == Nil)"#) -}
dc73abab930b0acef0cf5ac830214368
  fromStringDec ::
    Agpl_syntax.FromString
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.fromStringDec1
                  `cast`
                (<Agpl_syntax.FromString>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
b00ff610bc3dc075702470f9a4f454cf
  fromStringDec1 ::
    Agpl_syntax.FromString
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.FromString
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.FromString e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.fromStringDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
72d004f9de43f50a30542d6851fd7286
  fromStringDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.fromStringDec3) -}
f6b0abde1851adbacf735f3274fb014f
  fromStringDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.fromStringDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
9f41dbc258b7f7c77c0eee382935651e
  fromStringDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fromString"#) -}
a09317c7ebb181b51ef107c6ee8ed76f
  gamestateDec ::
    Agpl_syntax.GameState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,1*U)> -}
865d1f2165788cf755aade8ce35fe69c
  gsDec ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.gsDec1
                  `cast`
                (<[Language.Haskell.TH.Syntax.VarStrictType]>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
41b50e47ebbae384a54c230af0cea491
  gsDec1 ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ types :: [Language.Haskell.TH.Syntax.VarStrictType]
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.DataD
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                         CodeGen.gsDec21
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                         (GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Con
                            (Language.Haskell.TH.Syntax.RecC CodeGen.gsDec21 types)
                            CodeGen.gsDec8)
                         CodeGen.gsDec2)
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))) -}
ab84cc414a69f4f94d03bb5609391d2d
  gsDec10 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec11
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
0d84c09d27e6eb8ba8d724c81d3fc7f7
  gsDec11 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec12
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
8b5185da1dd00b53b5864b6b7461b931
  gsDec12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
67e9582d328cfc277259c8f110cf6f6d
  gsDec13 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec19
                   CodeGen.gsDec14) -}
acd190338539adf106a4fb7db61c138c
  gsDec14 :: [Language.Haskell.TH.Syntax.StrictType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.StrictType
                   CodeGen.gsDec15
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
79ba72b312aeee3ca4531393cc97e4bb
  gsDec15 ::
    (Language.Haskell.TH.Syntax.Strict,
     Language.Haskell.TH.Syntax.Type)
  {- Strictness: m,
     Unfolding: ((Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.gsDec16)) -}
aca44e8f7411f8e2bbe2d7df4901b148
  gsDec16 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.gsDec17) -}
b6f07d3909e78afa7e28cbdf5a7658da
  gsDec17 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec18
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
eb757eb1be5c14cd633a9b4801af6c51
  gsDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Player"#) -}
48d745b36321275b4ad51c798edd0072
  gsDec19 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec20
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
c4d4ee6a4cf305a16f1866b436c6bb19
  gsDec2 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec6
                   CodeGen.gsDec3) -}
27b75b2106065fbcdbfd51fdc50e0135
  gsDec20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win"#) -}
773f359aefc2d1d569daf5ce0ce8a57f
  gsDec21 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec22
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3fa5b69edd46985d630555b901fd9765
  gsDec22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState"#) -}
405c716e87faf75e033314c8c591c7d3
  gsDec3 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec4
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
7d66c8400d9a0084d4b08e33c1dca319
  gsDec4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
fb1bd87838993ec0070b6841180ae97b
  gsDec5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Eq"#) -}
3adc682905aa46d40273bb68105c1fe4
  gsDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
44fb548c039cad2f39f4f20d21f576f6
  gsDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Show"#) -}
d597d6972919f4724366d8cfc4035888
  gsDec8 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec13
                   CodeGen.gsDec9) -}
fdeaf611b31771f932bfb2a99bca92f4
  gsDec9 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec10
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
b36243da07d9334bd259d0ff01e978ff
  handT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.handT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.handT1)) -}
25612ec03b800a0cb34c1ec5823ead23
  handT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.handT2) -}
cc03405070a17960ee8546db29471b8d
  handT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
2804ead2b925139f30c384c9b3304427
  handT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hand"#) -}
643995f8c62bb3b8c0c1bc458276f584
  handT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
1e53bb99553e3eb6b991eed36d2ff06d
  handT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hand"#) -}
3300d707a80d745643cbc4c5cfc32049
  inBoundsDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.inBoundsDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
5a0865453a56c79bb67c4cbe3811fd27
  inBoundsDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
bbb26980250855bceb449f4379f0aab9
  initStateDec ::
    Agpl_syntax.InitState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.initStateDec1
                  `cast`
                (<Agpl_syntax.InitState>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
2a37938cd69e86d3589ca845652f72cd
  initStateDec1 ::
    Agpl_syntax.InitState
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ is :: Agpl_syntax.InitState
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.initStateDec5
                         (Language.Haskell.TH.Syntax.NormalB
                            (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds1 }))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.:
                         @ Language.Haskell.TH.Syntax.Dec
                         (Language.Haskell.TH.Syntax.ValD
                            CodeGen.initStateDec2
                            (Language.Haskell.TH.Syntax.NormalB
                               (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds2 }))
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)))) -}
cd2cea40ec9e4ed11168313a8ddf8329
  initStateDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec3) -}
ff480df4ee258ae3e772c1fc12894e7c
  initStateDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
72262a1638ea22762aabdb5231f2c98c
  initStateDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turn"#) -}
8795b5316dc56be221e5a0188f431e63
  initStateDec5 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec6) -}
a1bcbbb03000d929f80c4fc5087118d3
  initStateDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
2015f67c2a75e7da10a7dfeea00f6dfc
  initStateDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boardInitF"#) -}
a19febc7cd630956d442f9ea8ec1653c
  isValidDec ::
    Agpl_syntax.IsValidFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.isValidDec1
                  `cast`
                (<Agpl_syntax.IsValidFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
8a90419efdea8c26d96a27a918a83233
  isValidDec1 ::
    Agpl_syntax.IsValidFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.IsValidFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.IsValidFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.isValidDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
f46e7c8b1866bc4f2ba89a2c518a7e82
  isValidDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.isValidDec3) -}
aab612688e53b8ea47b7276876df29ec
  isValidDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.isValidDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
8db33117b4795d43531f873275827164
  isValidDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "isValid"#) -}
5e22e72ac6d90fb56771b8dbaa776250
  makeAGPLDecs ::
    Agpl_syntax.Game
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U> -}
336a534d99944ea08e9448a075778bd8
  moveDec ::
    Agpl_syntax.Move
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.moveDec1
                  `cast`
                (<Agpl_syntax.Move>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
64adbddb9b254a81476ebadae0e99968
  moveDec1 ::
    Agpl_syntax.Move
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Move
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Move d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
c2b283357faeb1bea9c5eb5064288367
  nilD :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m3,
     Unfolding: (Language.Haskell.TH.Syntax.DataD
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.nilD1
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
fb29f151d4da70fb78c7745dab1bff93
  nilD1 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.nilD2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
ea0bab739a131422e7af93f8aa460a88
  nilD2 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
30c62a45050432eb85e6526687e59035
  nilD3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.nilD4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
6140ad4b7cd340140567a015f16f7c19
  nilD4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NULL"#) -}
22c332d557e5c64afd76898b85ebe5d0
  otherPlayerClause ::
    Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Clause
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ p1 :: Language.Haskell.TH.Syntax.Name
                   p2 :: Language.Haskell.TH.Syntax.Name ->
                 Language.Haskell.TH.Syntax.Clause
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Pat
                      (Language.Haskell.TH.Syntax.ConP
                         p1
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat))
                   (Language.Haskell.TH.Syntax.NormalB
                      (Language.Haskell.TH.Syntax.ConE p2))
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
8fd31aa5cc88ecfb76667682d3d0ecb5
  otherPlayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> GHC.Types.Int
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: Language.Haskell.TH.Syntax.Dec w1 :: GHC.Types.Int ->
                 CodeGen.$wotherPlayerDec w) -}
e67b7f70b71001165926c92ba8370a0a
  otherPlayerDec1 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.otherPlayerDec2
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
ac9d32226eba90b9fcec41016f097455
  otherPlayerDec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "otherPlayer"#) -}
aa6ce83030b9f2a10b691418a8275f0b
  otherPlayerDec3 ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: b -}
2d6449ae60b1c8b4a7cb58ec2acc5291
  otherPlayerDec_go ::
    [Language.Haskell.TH.Syntax.Name]
    -> Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Name
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
9a82cc6e914e86d818c61d32ea3de5b3
  outcomeDec ::
    Agpl_syntax.OutcomeFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Agpl_syntax.OutcomeFun ->
                 case ds of wild {
                   Agpl_syntax.CustOutcomeFun e
                   -> let {
                        a9 :: Language.Haskell.TH.Syntax.Body
                        = Language.Haskell.TH.Syntax.NormalB e
                      } in
                      let {
                        a10 :: Language.Haskell.TH.Syntax.Dec
                        = Language.Haskell.TH.Syntax.ValD
                            CodeGen.outcomeDec19
                            a9
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                      } in
                      let {
                        x :: [Language.Haskell.TH.Syntax.Dec]
                        = GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Dec
                            a10
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                      } in
                      (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                       GHC.Base.return
                         @ m
                         (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                         @ [Language.Haskell.TH.Syntax.Dec]
                         x)
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <[Language.Haskell.TH.Syntax.Dec]>_N))
                   Agpl_syntax.OutcomeFun ipv ipv1 ipv2
                   -> case CodeGen.outcomeDec16 of wild1 {
                        Data.Either.Left err
                        -> let {
                             x :: [Language.Haskell.TH.Syntax.Dec]
                             = Debug.Trace.trace
                                 @ [Language.Haskell.TH.Syntax.Dec]
                                 err
                                 (GHC.Err.undefined @ [Language.Haskell.TH.Syntax.Dec])
                           } in
                           (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                            GHC.Base.return
                              @ m
                              (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                              @ [Language.Haskell.TH.Syntax.Dec]
                              x)
                             `cast`
                           (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <[Language.Haskell.TH.Syntax.Dec]>_N))
                        Data.Either.Right ds1
                        -> let {
                             a9 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv2
                           } in
                           let {
                             a10 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec11
                                 a9
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a11 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a10
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a12 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec9 a11
                           } in
                           let {
                             a13 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv
                           } in
                           let {
                             a14 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec5
                                 a13
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a15 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a14
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a16 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec3 a15
                           } in
                           let {
                             a17 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv1
                           } in
                           let {
                             a18 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec5
                                 a17
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a19 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a18
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a20 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec1 a19
                           } in
                           let {
                             a21 :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a20 ds1
                           } in
                           let {
                             a22 :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a16 a21
                           } in
                           let {
                             x :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a12 a22
                           } in
                           (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                            GHC.Base.return
                              @ m
                              (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                              @ [Language.Haskell.TH.Syntax.Dec]
                              x)
                             `cast`
                           (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <[Language.Haskell.TH.Syntax.Dec]>_N)) } }) -}
e46ca7f72e376753d5063bfd36769a87
  outcomeDec1 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec2
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
d7fe6d2f586d7e295d8e04c5274deffe
  outcomeDec10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "elsec"#) -}
f436702da0f0970e9ad1ecb999f7404e
  outcomeDec11 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec6
                   CodeGen.outcomeDec12) -}
8fd9f47fb4cd7b551fae7a0065dc2db4
  outcomeDec12 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec13
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)) -}
ddda0be01ca7f6080b4ff744cf79b721
  outcomeDec13 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.outcomeDec14) -}
45cbbdd5b3927981d70baab0b514d0da
  outcomeDec14 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec15
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
4a87f9cb41873c0e7d3baf6730394704
  outcomeDec15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "move"#) -}
fa3ab55145eacaf0c06826649f82f84a
  outcomeDec16 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.outcomeDec17 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
320c6187a4502f66ca66ffca831b98a1
  outcomeDec17 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.outcomeDec18) -}
8244a35c0780107c0099c968069b71af
  outcomeDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "outcome game move = if (winc game) then (Win (currentTurn game), 1) else if (tiec game) then (Tie, 1) else let g = elsec game move in if (winc g) then (Win (currentTurn game), 1) else if (tiec g) then (Tie, 1) else (g, 1)"#) -}
66e79e42688318a0e1e894767c8fe9a8
  outcomeDec19 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.outcomeDec20) -}
1e207173020b1a37b600f6559f0d030d
  outcomeDec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tiec"#) -}
f49ae1a968b71d3c54b7fc4b59fcdfa1
  outcomeDec20 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec21
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3f4bdd0685ce1ea846e0b6db0c67d40f
  outcomeDec21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "outcome"#) -}
e09a9936bd4a8b74e000581d0ddac280
  outcomeDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
6cfd32580c3b8f29e50f2bd8c83eca49
  outcomeDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "winc"#) -}
0abefb4fe92f2bb727d55ea0a1edacca
  outcomeDec5 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec6
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)) -}
a325e6adea33de5a84772776db95290c
  outcomeDec6 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.outcomeDec7) -}
19f0bf0051e5e7a37e0ccb661ebeb070
  outcomeDec7 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec8
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
30456567ac9c27248503650ab2309956
  outcomeDec8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "game"#) -}
58c163c73b954c062247714a038891f1
  outcomeDec9 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec10
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
50262ba38f2713c61591db3dd99ffaa7
  pieceT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.pieceT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.pieceT1)) -}
8da27b40f2227f9561e74241145f4a6e
  pieceT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.pieceT2) -}
7d37f90aca980dfcba4299c40fa9214c
  pieceT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
86d4f16681a7ba11a39cf90a676bc461
  pieceT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Piece"#) -}
007c184b27a1049572699a48e5f5dd60
  pieceT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
fccbb9806dcdd0765fac21d79eef2d84
  pieceT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "piece"#) -}
8057d57ed4316a47073754317e06a8f0
  placeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.placeDec2 of wild {
                   Data.Either.Left x1
                   -> Debug.Trace.trace
                        @ (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec])
                        (GHC.CString.unpackAppendCString# "fuckup: "# x1)
                        CodeGen.placeDec1
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <[Language.Haskell.TH.Syntax.Dec]>_N))
                   Data.Either.Right y
                   -> let {
                        x :: [Language.Haskell.TH.Syntax.Dec]
                        = case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                          Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                            @ Language.Haskell.Exts.Syntax.Decl
                            Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                              `cast`
                            (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                      <Language.Haskell.Exts.Syntax.Decl>_N))
                            x1 }
                      } in
                      (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                       GHC.Base.return
                         @ m
                         (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                         @ [Language.Haskell.TH.Syntax.Dec]
                         x)
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <[Language.Haskell.TH.Syntax.Dec]>_N)) }) -}
fa66dd4ee51a3959258039ce10815b77
  placeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
aaec32bd88632911607f9d4f330199e6
  placeDec2 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.placeDec3) -}
129f499f40f0ebf3f64d907d8029a07a
  placeDec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "place game piece coord = let b = (trace (\"setting at: \" L.++ (show coord)) (setElem piece coord (board game)))\n\
                   \                             t = (trace (\"set the piece \") (otherPlayer (currentTurn game)))\n\
                   \                         in (GameState{board=b, currentTurn=t})"#) -}
9cdade8ca5bb3bcdde251408f6ce78b8
  playerDec ::
    Agpl_syntax.Player
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S(S),1*U(1*U(U,A))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Agpl_syntax.Player ->
                 case w of ww { Agpl_syntax.Player ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 -> CodeGen.$wplayerDec ww3 } }) -}
17352df8cf837141cb8a302aad736c16
  possmovesDec ::
    Agpl_syntax.PossMovesFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.possmovesDec1
                  `cast`
                (<Agpl_syntax.PossMovesFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
5054cce2917b5d146b42e68d474b7734
  possmovesDec1 ::
    Agpl_syntax.PossMovesFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.PossMovesFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.PossMovesFun e
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.:
                           @ Language.Haskell.TH.Syntax.Dec
                           (Language.Haskell.TH.Syntax.ValD
                              CodeGen.possmovesDec2
                              (Language.Haskell.TH.Syntax.NormalB e)
                              (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                           (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                   Agpl_syntax.PMNil
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
a33ab14be35cdab2c647ce3f56595e07
  possmovesDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.possmovesDec3) -}
43e5a9dbb754d5ca95ca48e29932cda7
  possmovesDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.possmovesDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
2f2d8c42a070da9ac2ec6b7118888956
  possmovesDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "possMoves"#) -}
063b947eeccc33b1d7c735c822352dcc
  sizeDec :: GHC.Base.String -> Language.Haskell.TH.Syntax.Dec
  {- Arity: 1, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Exp
                        (Language.Haskell.Meta.Parse.parseExp1 w) of wild {
                   Data.Either.Left x1
                   -> case GHC.Err.undefined
                      ret_ty Language.Haskell.TH.Syntax.Dec
                      of {}
                   Data.Either.Right y
                   -> Language.Haskell.TH.Syntax.ValD
                        CodeGen.sizeDec1
                        (Language.Haskell.TH.Syntax.NormalB
                           (Language.Haskell.Meta.Syntax.Translate.$ctoExp1 y))
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
0bc03921ebd80c6d5a51b54af9f025f3
  sizeDec1 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.sizeDec2) -}
618d5dd6c63861480d5006a26cc768de
  sizeDec2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.sizeDec3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
04e14fe38f3a1631b7290a0f371c3653
  sizeDec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "size"#) -}
65711f790a60e762802ea6ca980f963e
  testD ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.testD1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
1be8b597584349a2bb86b55d0c650646
  testD1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 let {
                   lvl23 :: GHC.Base.Monad m
                   = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                 } in
                 let {
                   lvl24 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD16
                 } in
                 let {
                   lvl25 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD15
                 } in
                 let {
                   lvl26 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD14
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl23
                   @ Language.Haskell.TH.Syntax.Name
                   @ [Language.Haskell.TH.Syntax.Dec]
                   lvl26
                   (\ x :: Language.Haskell.TH.Syntax.Name ->
                    GHC.Base.>>=
                      @ m
                      lvl23
                      @ Language.Haskell.TH.Syntax.Name
                      @ [Language.Haskell.TH.Syntax.Dec]
                      lvl26
                      (\ x1 :: Language.Haskell.TH.Syntax.Name ->
                       GHC.Base.>>=
                         @ m
                         lvl23
                         @ Language.Haskell.TH.Syntax.Name
                         @ [Language.Haskell.TH.Syntax.Dec]
                         lvl25
                         (\ x2 :: Language.Haskell.TH.Syntax.Name ->
                          let {
                            a9 :: forall (m1 :: * -> *).
                                  Language.Haskell.TH.Syntax.Quasi m1 =>
                                  m1 Language.Haskell.TH.Syntax.VarStrictType
                              {- Arity: 1 -}
                            = Language.Haskell.TH.Lib.varStrictType1
                                x2
                                CodeGen.testD10
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <Language.Haskell.TH.Syntax.StrictType>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            lvl23
                            @ Language.Haskell.TH.Syntax.Name
                            @ [Language.Haskell.TH.Syntax.Dec]
                            lvl24
                            (\ x3 :: Language.Haskell.TH.Syntax.Name ->
                             Language.Haskell.TH.Syntax.sequenceQ2
                               @ Language.Haskell.TH.Syntax.Dec
                               (GHC.Types.:
                                  @ Language.Haskell.TH.Lib.DecQ
                                  (Language.Haskell.TH.Lib.dataD1
                                     CodeGen.testD9
                                       `cast`
                                     (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                               <[Language.Haskell.TH.Syntax.Pred]>_N))
                                     x
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                                     (GHC.Types.:
                                        @ Language.Haskell.TH.Lib.ConQ
                                        (Language.Haskell.TH.Lib.recC1
                                           x1
                                           (GHC.Types.:
                                              @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                              a9
                                                `cast`
                                              (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                        <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                              (GHC.Types.:
                                                 @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                                 (Language.Haskell.TH.Lib.varStrictType1
                                                    x3
                                                    CodeGen.testD2
                                                      `cast`
                                                    (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                              <Language.Haskell.TH.Syntax.StrictType>_N)))
                                                   `cast`
                                                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                           <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                                 (GHC.Types.[]
                                                    @ Language.Haskell.TH.Lib.VarStrictTypeQ))))
                                          `cast`
                                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                  <Language.Haskell.TH.Syntax.Con>_N))
                                        (GHC.Types.[] @ Language.Haskell.TH.Lib.ConQ))
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name))
                                    `cast`
                                  (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                            <Language.Haskell.TH.Syntax.Dec>_N))
                                  (GHC.Types.[] @ Language.Haskell.TH.Lib.DecQ))
                               @ m
                               $dQuasi))))) -}
3a2ee1f6062670612e2ee0bae63d09be
  testD10 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD11
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
6e01a02c2e79c33d48000738f9ac81b1
  testD11 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD12)) -}
da4f02ddc150104da61d052e3ae261f6
  testD12 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD13
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
162efccf4e9babf36d0987cbdd023d8a
  testD13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Int"#) -}
b575e2bf7c3e19451390d4d52d693c69
  testD14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A"#) -}
d7e78d7eb67fe87af5c3d1fc887ab032
  testD15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "b"#) -}
2b25ee96a231005e66a04960c6d79db9
  testD16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
32bf4c5ce37fc2290e7947f5f285f893
  testD2 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD3
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
1fdaded8122ba617e2b91b1b86330a76
  testD3 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD4)) -}
21d9717be610a931577141fc371ece95
  testD4 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD8
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
97ba543a19fe6187ab9b8084346f0b29
  testD5 :: Language.Haskell.TH.Syntax.NameFlavour
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.NameG
                   Language.Haskell.TH.Syntax.TcClsName
                   CodeGen.testD7
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:PkgName[0]))
                   CodeGen.testD6
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:ModName[0]))) -}
33a1dea5c8027c870d9efca31e31d367
  testD6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GHC.Types"#) -}
39d8919ba664a41ceadec2bec08b2850
  testD7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ghc-prim"#) -}
38a80e439178b948cc39614d6ff8d3ea
  testD8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Char"#) -}
349edd3db6185f07992e8d585508e451
  testD9 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Pred]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLLLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta1 :: Language.Haskell.TH.Syntax.Quasi m ->
                 Language.Haskell.TH.Lib.cxt2
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)
                   @ m
                   eta1) -}
14040e89894cef0cb1b3bf57894dfd14
  turnT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.turnT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.turnT1)) -}
bd34fcefbbcad0d193e84d12acaa2339
  turnT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.turnT2) -}
39a2160357119ff36ba68d0e640b4d49
  turnT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a07756239568bc2718c804ac6e888fa6
  turnT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Turn"#) -}
fad00e98354dda456ac51a511d8f7e86
  turnT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
930c7ac99cd8f1f811a2af3ec867fcb3
  turnT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn"#) -}
2455c62dc7a761a6f44ef6eaed1cedb3
  turnTypeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.turnTypeDec1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
434466b18c72d9efc8dd2b484d1dd561
  turnTypeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   CodeGen.turnTypeDec2) -}
54a5242379d07ae7a18629df761f9087
  turnTypeDec2 :: [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Dec
                   CodeGen.turnTypeDec3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
5130cd59860840089b0dbca0ce8c330a
  turnTypeDec3 :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.TySynD
                   CodeGen.turnT2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.gsDec16) -}
"SPEC/CodeGen lift @ Integer" [ALWAYS] forall tpl :: Language.Haskell.TH.Syntax.Lift
                                                       GHC.Integer.Type.Integer
  Language.Haskell.TH.Syntax.lift @ GHC.Integer.Type.Integer tpl
  = Language.Haskell.TH.Syntax.$fLiftInteger_$clift
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

