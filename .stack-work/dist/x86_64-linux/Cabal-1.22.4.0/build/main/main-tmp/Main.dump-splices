Main.hs:1:1: Splicing declarations
    "ttt.agpl"
  ======>
    [xor :: Bool -> Bool -> Bool,
     xor True True = False
     xor False False = False
     xor _ _ = True,
     iToC :: Int -> Int -> Int -> (Int, Int),
     iToC rows cols i
       = let
           c = if (i `mod` cols) == 0 then cols else (i `mod` cols)
           r = ceiling ((realToFrac i) / (realToFrac rows))
         in (r, c),
     lfoldi ::
       forall a b.
       (Int -> (Int, Int))
       -> Int -> (((Int, Int), a, b) -> b) -> b -> [a] -> b,
     lfoldi toC i f b [] = b
     lfoldi toC i f b (x ghc-prim-0.4.0.0:GHC.Types.: xs)
       = f ((toC i), x, (lfoldi toC (i - 1) f b xs)),
     mfold ::
       forall a b. (((Int, Int), a, b) -> b) -> b -> Matrix a -> b,
     mfold f b m
       = let
           nr = (nrows m)
           nc = (ncols m)
           l = (toList m)
         in lfoldi (iToC nr nc) (length l) f b l,
     data Piece
       = X | O | Nil
       deriving (Eq, Show),
     type Board = Matrix Piece,
     boardInitF = matrix 3 3 (\ (i, j) -> Nil), turn = PX,
     type Turn = Player,
     data Move
       = Move (Int, Int)
       deriving (Eq, Show),
     data Player
       = PX | PO
       deriving (Eq, Show),
     isValid
       = (\ game
            -> (\ (Move (i, j))
                  -> ((i <= 3) && (j <= 3) && (i > 0) && (j > 0)
                      && ((board game) ! (i, j))
                      == Nil))) ::
           GameState -> Move -> Bool,
     data GameState
       = GameState {board :: Board, currentTurn :: Turn} |
         Win Player |
         Tie
       deriving (Show, Eq),
     outcome
       = (\ game
            -> \ (Move move)
                 -> let
                      t = otherPlayer (currentTurn game)
                      b = if isFull (board game) then
                              (board game)
                          else
                              setElem (playerToPiece (currentTurn game)) move (board game)
                      g = (GameState {board = b, currentTurn = t})
                    in
                      if ((b ! (1, 1)) == (b ! (1, 2)) && ((b ! (1, 2)) == (b ! (1, 3)))
                          && ((b ! (1, 1)) /= Nil)) then
                          (Win (pieceToPlayer (b ! (1, 1))), 1)
                      else
                          if ((b ! (2, 1)) == (b ! (2, 2)) && ((b ! (2, 2)) == (b ! (2, 3)))
                              && ((b ! (2, 1)) /= Nil)) then
                              (Win (pieceToPlayer (b ! (2, 1))), 1)
                          else
                              if ((b ! (3, 1)) == (b ! (3, 2)) && ((b ! (3, 2)) == (b ! (3, 3)))
                                  && ((b ! (3, 1)) /= Nil)) then
                                  (Win (pieceToPlayer (b ! (3, 1))), 1)
                              else
                                  if ((b ! (1, 1)) == (b ! (2, 1)) && ((b ! (2, 1)) == (b ! (3, 1)))
                                      && ((b ! (1, 1)) /= Nil)) then
                                      (Win (pieceToPlayer (b ! (1, 1))), 1)
                                  else
                                      if ((b ! (1, 2)) == (b ! (2, 2))
                                          && ((b ! (2, 2)) == (b ! (3, 2)))
                                          && ((b ! (1, 2)) /= Nil)) then
                                          (Win (pieceToPlayer (b ! (1, 1))), 1)
                                      else
                                          if ((b ! (1, 3)) == (b ! (2, 3))
                                              && ((b ! (2, 3)) == (b ! (3, 3)))
                                              && ((b ! (1, 3)) /= Nil)) then
                                              (Win (pieceToPlayer (b ! (1, 1))), 1)
                                          else
                                              if ((b ! (1, 1)) == (b ! (2, 2))
                                                  && ((b ! (2, 2)) == (b ! (3, 3)))
                                                  && ((b ! (1, 1)) /= Nil)) then
                                                  (Win (pieceToPlayer (b ! (1, 1))), 1)
                                              else
                                                  if ((b ! (1, 3)) == (b ! (2, 2))
                                                      && ((b ! (2, 2)) == (b ! (3, 1)))
                                                      && ((b ! (1, 3)) /= Nil)) then
                                                      (Win (pieceToPlayer (b ! (1, 1))), 1)
                                                  else
                                                      if isFull b then (Tie, 1) else (g, 1)) ::
           GameState -> Move -> (GameState, Int),
     possMoves
       = (\ game
            -> mfold
                 (\ ((i, j), piece, acc)
                    -> if piece == Nil then
                           ((Move (i, j)) ghc-prim-0.4.0.0:GHC.Types.: acc)
                       else
                           acc)
                 []
                 (board game)) ::
           GameState -> [Move],
     fromString
       = \ (s)
           -> let move = map read (splitOn "," s)
              in (Move ((head move), (head (tail move)))),
     isFull b
       = mfold
           (\ ((i, j), piece, acc)
              -> if piece == Nil then False else (True && acc))
           True
           b,
     ne (x, y) = (x + 1, y + 1), e (x, y) = (x + 1, y),
     se (x, y) = (x + 1, y - 1), s (x, y) = (x, y - 1),
     sw (x, y) = (x - 1, y - 1), w (x, y) = (x - 1, y),
     nw (x, y) = (x - 1, y + 1), n (x, y) = (x, y + 1),
     pieceToPlayer :: Piece -> Player,
     pieceToPlayer X = PX
     pieceToPlayer O = PO,
     playerToPiece :: Player -> Piece,
     playerToPiece PX = X
     playerToPiece PO = O,
     otherPlayer :: Player -> Player,
     otherPlayer PX = PO
     otherPlayer PO = PX]
