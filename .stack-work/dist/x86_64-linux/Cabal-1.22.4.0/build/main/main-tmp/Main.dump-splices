Main.hs:1:1: Splicing declarations
    "ttt.agpl"
  ======>
    [xor :: Bool -> Bool -> Bool,
     xor True True = False
     xor False False = False
     xor _ _ = True,
     iToC :: Int -> Int -> Int -> (Int, Int),
     iToC rows cols i
       = let
           c = if (i `mod` cols) == 0 then cols else (i `mod` cols)
           r = ceiling ((realToFrac i) / (realToFrac rows))
         in (r, c),
     lfoldi ::
       forall a b.
       (Int -> (Int, Int))
       -> Int -> (((Int, Int), a, b) -> b) -> b -> [a] -> b,
     lfoldi toC i f b [] = b
     lfoldi toC i f b (x ghc-prim-0.4.0.0:GHC.Types.: xs)
       = f ((toC i), x, (lfoldi toC (i - 1) f b xs)),
     mfold ::
       forall a b. (((Int, Int), a, b) -> b) -> b -> Matrix a -> b,
     mfold f b m
       = let
           nr = (nrows m)
           nc = (ncols m)
           l = (M.toList m)
         in lfoldi (iToC nr nc) (L.length l) f b l,
     inRow :: Int -> Player -> Board -> Bool,
     inRow n player board
       = let
           piece = playerToPiece player :: Piece
           rows = toLists board :: [[Piece]]
           frow
             = (\ c -> (\ x -> if x == piece then (c + 1) else 0)) ::
                 Int -> Piece -> Int
           frows
             = (\ acc -> (\ row -> (foldl frow 0 row) >= n || acc)) ::
                 Bool -> [Piece] -> Bool
         in foldl frows False rows,
     inCol :: Int -> Player -> Board -> Bool,
     inCol n player board
       = let
           piece = playerToPiece player :: Piece
           cols = toLists (M.transpose board) :: [[Piece]]
           fcol
             = (\ c -> (\ x -> if x == piece then (c + 1) else 0)) ::
                 Int -> Piece -> Int
           fcols
             = (\ acc -> (\ col -> (foldl fcol 0 col) >= n || acc)) ::
                 Bool -> [Piece] -> Bool
         in foldl fcols False cols,
     getDiags :: forall t. Matrix t -> [[t]],
     getDiags m
       = let
           k = (ncols m) + (nrows m)
           midi = (2 * k) - (ncols m) - 2
           diags = generate (2 * (k - 1)) (\ _ -> empty)
         in
           V.toList
             (V.map
                V.toList
                (mfold
                   (\ ((i, j), elem, diagv)
                      -> let
                           subv = snoc (diagv V.! (i + j - 2)) elem
                           subv2 = snoc (diagv V.! (i - j + midi)) elem
                         in diagv // [((i + j - 2), subv), ((i - j + midi), subv2)])
                   diags
                   m)),
     inDiag :: Int -> Player -> Board -> Bool,
     inDiag n player board
       = let
           piece = playerToPiece player :: Piece
           diags = getDiags board :: [[Piece]]
           fdiag
             = (\ c -> (\ x -> if x == piece then (c + 1) else 0)) ::
                 Int -> Piece -> Int
           fdiags
             = (\ acc -> (\ diag -> (foldl fdiag 0 diag) >= n || acc)) ::
                 Bool -> [Piece] -> Bool
         in foldl fdiags False diags,
     isFull b
       = mfold
           (\ ((i, j), piece, acc)
              -> if piece == Nil then False else (True && acc))
           True
           b,
     ne (x, y) = (x + 1, y + 1), e (x, y) = (x + 1, y),
     se (x, y) = (x + 1, y - 1), s (x, y) = (x, y - 1),
     sw (x, y) = (x - 1, y - 1), w (x, y) = (x - 1, y),
     nw (x, y) = (x - 1, y + 1), n (x, y) = (x, y + 1),
     data Piece
       = X | O | Nil
       deriving (Eq, Show),
     size = (3, 3), type Board = Matrix Piece,
     boardInitF
       = M.fromLists [[Nil, Nil, Nil], [Nil, Nil, Nil], [Nil, Nil, Nil]],
     turn = PX, type Turn = Player,
     data Move
       = Move (Int, Int)
       deriving (Eq, Show),
     data Player
       = PX | PO
       deriving (Eq, Show),
     isValid
       = (\ game
            -> (\ (Move (i, j))
                  -> ((inBounds (i, j)) && (isEmpty (i, j) game)))) ::
           GameState -> Move -> Bool,
     data GameState
       = GameState {board :: Board, currentTurn :: Turn} |
         Win Player |
         Tie
       deriving (Show, Eq),
     outcome
       = (\ game
            -> \ (Move move)
                 -> let
                      t = otherPlayer (currentTurn game)
                      b = if isFull (board game) then
                              (board game)
                          else
                              setElem (playerToPiece (currentTurn game)) move (board game)
                      g = (GameState {board = b, currentTurn = t})
                    in
                      if (inRow 3 (currentTurn game) b) || (inCol 3 (currentTurn game) b)
                         || (inDiag 3 (currentTurn game) b) then
                          (Win (currentTurn game), 1)
                      else
                          if isFull b then (Tie, 1) else (g, 1)) ::
           GameState -> Move -> (GameState, Int),
     possMoves
       = (\ game
            -> mfold
                 (\ ((i, j), piece, acc)
                    -> if piece == Nil then
                           ((Move (i, j)) ghc-prim-0.4.0.0:GHC.Types.: acc)
                       else
                           acc)
                 []
                 (board game)) ::
           GameState -> [Move],
     fromString
       = \ (s)
           -> let move = L.map read (splitOn "," s)
              in (Move ((L.head move), (L.head (L.tail move)))),
     pieceToPlayer :: Piece -> Player,
     pieceToPlayer X = PX
     pieceToPlayer O = PO,
     playerToPiece :: Player -> Piece,
     playerToPiece PX = X
     playerToPiece PO = O,
     otherPlayer :: Player -> Player,
     otherPlayer PX = PO
     otherPlayer PO = PX,
     inBounds_aRQk (x1_aRQl, y1_aRQm)
       = ((x1_aRQl <= 3)
          && ((x1_aRQl > 0) && ((y1_aRQm <= 3) && (y1_aRQm > 0)))),
     isEmpty (i, j) game = (((board game) M.! (i, j)) == Nil)]
