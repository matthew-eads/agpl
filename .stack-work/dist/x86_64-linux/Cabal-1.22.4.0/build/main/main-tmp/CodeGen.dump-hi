
==================== FINAL INTERFACE ====================
2015-11-20 03:06:18.162624 UTC

interface main@main:CodeGen 7102
  interface hash: c91a7b0fb92e5c337ac9234a4ed22b99
  ABI hash: 13b1fb3bc8e0d7bc161b305a747ebb1f
  export-list hash: fe4587af2ae0bf953c9bc749b661cc39
  orphan hash: ab876434d53120bef7ce39f90b5e9748
  flag hash: 1e433d0ebc6754f04665631962e57d78
  sig of: Nothing
  used TH splices: False
  where
exports:
  CodeGen.boardT
  CodeGen.customDataDec
  CodeGen.doNothing
  CodeGen.emptyDec
  CodeGen.fromStringDec
  CodeGen.gamestateDec
  CodeGen.gsDec
  CodeGen.handT
  CodeGen.inBoundsDec
  CodeGen.initStateDec
  CodeGen.isValidDec
  CodeGen.makeAGPLDecs
  CodeGen.moveDec
  CodeGen.nilD
  CodeGen.outcomeDec
  CodeGen.pieceT
  CodeGen.playerDec
  CodeGen.possmovesDec
  CodeGen.sizeDec
  CodeGen.testD
  CodeGen.turnT
  CodeGen.turnTypeDec
module dependencies: Agpl_syntax Parser
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  base-4.8.1.0:Data.Either bc9482e78cc431fce439b593377aa2e6
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8:Language.Haskell.Meta.Parse c926810653cf52d957a896d138bd5ba0
import  -/  Agpl_syntax 530416e562a45301176b3789d180fa9e
  exports: f7de5df4ff3847065957407f09eefadf
  Array e9b2f031c5146398177094ec3aecfd84
  Board 13da1373552f41f3c0f209a3ecac94ee
  Board 5a6575be8b22b0b0f59e88b700df439d
  CustomDataType ffb9365911492f05edc60da8eb7a0104
  CustomDataType 91192d1ac1cebe57c987b47b377cf6bc
  FromString 6135a123da0f66d7a10aadde97f1eaff
  FromString 46199bec460db4ebc556e57dcb2854df
  Game 08ffb9525e9bdcfe08c5c829af599c4f
  Game 964dc5e66f90c4b8daeaf55ed46c51ee
  GameState 16deb5f1426ec569bd3815464085d553
  InitState cabb4e294e2b8e5dc26f9253eb649cb2
  IsValidFun bd65e17278348d186c507c66bf484920
  IsValidFun 0a680fb879788e9038046ed45ae15c01
  Matrix 219cf5613dbd64af998dfc42ee587461
  Move 75bde73f3ed47fcd7281c6e64f7bb9a5
  Move 8b522c55ef1479ecee50454e18a45c6c
  OutcomeFun b55b24ef0c535809b4a4a62f51c63533
  OutcomeFun b72e2669b5cd9e2861e8c87fb0fa3d1c
  PMNil e8092ba103316e8754f683b43e462d2a
  Player 446f0e27e6607cf783e99a749f19f4c1
  Player 938a387b6123ae606231aa9293af71c2
  PossMovesFun 69a051a132d07df7fda637a89a47e01d
  PossMovesFun 50c820c9396d9c7dfcd245c39b536489
  board 9240c40287cbcd98ffb4cf595667777b
  boardInit d73f6bbedaa8a4f24243b4d11e763ff7
  hand eb19f0d1e86bff8e6fbbae71be517fdc
  piece f13a62b0bc85e116f4659bdc83150bab
  turn 44783e2441694d687ced07df48f6d04d
  turnInit 305c3c20e7f6f2377ef9d171e6d9ab4a
import  -/  Parser 4bd1f15e1240f74f857ef58af7595b55
  exports: 1f9ec8c56c5e3b4aa932d4bab54c92c1
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH cce81ae8a1596a0252bdcb72179c2937
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Quote 7a74e3dce88866c160fffb1503661817
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax afcf64bad3773d231089a8ce432131ab
import  -/  vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector 1ab51bec0be594f8c3b5e22942541591
83ba6af2c236c895b251fc4a097e9286
  boardT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.boardT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.boardT1)) -}
27d1662a40773b346f840320f3398a70
  boardT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.boardT2) -}
53b6f562cfad6df7a87e4eda283728ac
  boardT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
593cbcfd0566bba215a1bc362d89b524
  boardT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Board"#) -}
1871d42adab363632c30709171533812
  boardT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
f0e65ef3ce3a6df7cd16e4751f3c316e
  boardT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board"#) -}
e9a9a6dceb28c89c1392144712cd6fb5
  customDataDec ::
    Agpl_syntax.CustomDataType
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.customDataDec1
                  `cast`
                (<Agpl_syntax.CustomDataType>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
0f01efc15bcc2ae3f030c34b980a06e9
  customDataDec1 ::
    Agpl_syntax.CustomDataType
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.CustomDataType
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.CustomDataType d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
325c67093be23910b938ee023fee18db
  doNothing :: Language.Haskell.TH.Syntax.Q ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.doNothing1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0] <()>_N)) -}
bd1c3c2390e3f857db925369441f2cfb
  doNothing1 :: Language.Haskell.TH.Syntax.Quasi m => m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ ()
                   GHC.Tuple.()) -}
3e8f7b348be0cef361cd7fa340228198
  emptyDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.emptyDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
53f8df07dc81422627dc11dbed9690f4
  emptyDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.Board
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.Matrix ds1
                   -> case CodeGen.emptyDec5 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Array ds1
                   -> case CodeGen.emptyDec2 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Board ipv
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
1dba1f81aeb4df22ee874ae91a3e74c9
  emptyDec2 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec3 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
4e01fcf6519a88b08ccb7a8e3d2d36ed
  emptyDec3 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec4) -}
fcaee9ae8b71f10fad4abb15772988db
  emptyDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty i game = (((board game) V.! i) == Nil)"#) -}
d1dc2eeeb4275e11e436029d7dacd750
  emptyDec5 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec6 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
fca9de829bfcb9f14e3c45a68edfe7f6
  emptyDec6 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec7) -}
286ef5dccb9e2043ea987cfe23b5227a
  emptyDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty (i, j) game = (((board game) M.! (i,j)) == Nil)"#) -}
e8e771636e2705a2919e6884326ce8f4
  fromStringDec ::
    Agpl_syntax.FromString
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.fromStringDec1
                  `cast`
                (<Agpl_syntax.FromString>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
598395b990f27c57955ccd3ba8dbac8c
  fromStringDec1 ::
    Agpl_syntax.FromString
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.FromString
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.FromString e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.fromStringDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
af35867b94f5d456e04373cd2951b6b0
  fromStringDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.fromStringDec3) -}
6e7b301af8f80101093a9b04c0357244
  fromStringDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.fromStringDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
2b185670de0e7a32aa7e9903190da30c
  fromStringDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fromString"#) -}
417ef2a706258e9637c8b5a66512e673
  gamestateDec ::
    Agpl_syntax.GameState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,1*U)> -}
ca5db38e066190c4b1080b28d610b3c2
  gsDec ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.gsDec1
                  `cast`
                (<[Language.Haskell.TH.Syntax.VarStrictType]>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
947c439e89f372a78266b4c9e840c494
  gsDec1 ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ types :: [Language.Haskell.TH.Syntax.VarStrictType]
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.DataD
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                         CodeGen.gsDec21
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                         (GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Con
                            (Language.Haskell.TH.Syntax.RecC CodeGen.gsDec21 types)
                            CodeGen.gsDec8)
                         CodeGen.gsDec2)
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))) -}
9dd0e616a4f4ac3975f36f7ecd8fe459
  gsDec10 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec11
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
96ba61babeec3c1bb9d61b039e27e8c8
  gsDec11 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec12
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
814729f897df86b0b640768df712cd63
  gsDec12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
13f21344b2d2a07a974e0823db305c99
  gsDec13 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec19
                   CodeGen.gsDec14) -}
b768ce96cee56e936bb65efca6f74756
  gsDec14 :: [Language.Haskell.TH.Syntax.StrictType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.StrictType
                   CodeGen.gsDec15
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
03ea48f0fa1337d79efb18d4670da7ef
  gsDec15 ::
    (Language.Haskell.TH.Syntax.Strict,
     Language.Haskell.TH.Syntax.Type)
  {- Strictness: m,
     Unfolding: ((Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.gsDec16)) -}
bd87df691b8b42d1847ed3b4fe4ca8cb
  gsDec16 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.gsDec17) -}
1d6d9cebed47d2dc13f2926ff2dd98fd
  gsDec17 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec18
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
943f251289847a821f272d87a470e1d0
  gsDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Player"#) -}
75cb81cff19b4fc5e27cf80efe2b9fcd
  gsDec19 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec20
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
f4406ffa0cf9de5d4fa067bd415e5827
  gsDec2 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec6
                   CodeGen.gsDec3) -}
b884f1f179a3f3aa5d530c0af52853ed
  gsDec20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win"#) -}
179433c01f8740f5ab80bea4f4fe0ec9
  gsDec21 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec22
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
60519b8ded863a9c7e909e92fcc7f997
  gsDec22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState"#) -}
420af152e6c9b6fd1c2fe12736d1e961
  gsDec3 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec4
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
fb733efbe81ac3c4b61a71eb5abd2e42
  gsDec4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
727324f00840f4c82ebdc9cf2bc5c91b
  gsDec5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Eq"#) -}
9684003c09c32bc9943dea8d4b807e80
  gsDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
0e93c94bc6a96e4090a37bd987e02d73
  gsDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Show"#) -}
2108ccc8ca8aa4fe33a99bf371c0b72e
  gsDec8 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec13
                   CodeGen.gsDec9) -}
3928def8af92c9de7258c2a362dc0f4b
  gsDec9 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec10
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
3c73c02d51b17b4bb842c80155ec7857
  handT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.handT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.handT1)) -}
3d5181bfd78aefed0c790df1756083a2
  handT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.handT2) -}
decce5ffe1bde720355c0b1ce23af124
  handT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
63e47aaee9d208afd1c531c34f938fe0
  handT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hand"#) -}
c281486f1f606bcbf2a212b3c2e48508
  handT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a0035600f323685750fb2a44f1a77404
  handT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hand"#) -}
01dd4111df6c0fe8b9ccfc40eef6af61
  inBoundsDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.inBoundsDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
234704fd12b34761b89ff79b33459339
  inBoundsDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
1d45b0db8e7deda1c34034aefe25f501
  initStateDec ::
    Agpl_syntax.InitState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.initStateDec1
                  `cast`
                (<Agpl_syntax.InitState>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
c9f7e2b91f0cdb5d5008192e667f0fa6
  initStateDec1 ::
    Agpl_syntax.InitState
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ is :: Agpl_syntax.InitState
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.initStateDec5
                         (Language.Haskell.TH.Syntax.NormalB
                            (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds1 }))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.:
                         @ Language.Haskell.TH.Syntax.Dec
                         (Language.Haskell.TH.Syntax.ValD
                            CodeGen.initStateDec2
                            (Language.Haskell.TH.Syntax.NormalB
                               (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds2 }))
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)))) -}
7dd0c2cd9d0b360eb1b535cbdecf85a5
  initStateDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec3) -}
d102c1f9fc0f7a8c8d84ad1ffe296143
  initStateDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
4b6dc74fd1de97b8ea1474bc3e886e33
  initStateDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turn"#) -}
0e4bd54241f59df7663e311ec77fdf81
  initStateDec5 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec6) -}
c6a33542e65266345d26f93f17b103e9
  initStateDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
9e9df0b74075458652491f0af1eb3257
  initStateDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boardInitF"#) -}
ada1205c0a2b634559ead13340102115
  isValidDec ::
    Agpl_syntax.IsValidFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.isValidDec1
                  `cast`
                (<Agpl_syntax.IsValidFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
1f90827578a7946f19bf2ab4f82caac1
  isValidDec1 ::
    Agpl_syntax.IsValidFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.IsValidFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.IsValidFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.isValidDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
550970d637ccda258507eaddd8874420
  isValidDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.isValidDec3) -}
6f5b89c25a339b81c558b4ecab33faaf
  isValidDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.isValidDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a7220a2b78cb414d67e68c0b80a21cd0
  isValidDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "isValid"#) -}
0f62ada3ae8895fc881fc96cd366b2ca
  makeAGPLDecs ::
    Agpl_syntax.Game
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U> -}
62c69398a8fc62af8514f0eabc0b01f3
  moveDec ::
    Agpl_syntax.Move
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.moveDec1
                  `cast`
                (<Agpl_syntax.Move>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
7972df668ab8bee7fbd0aa9e54d8ede4
  moveDec1 ::
    Agpl_syntax.Move
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Move
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Move d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
4d8532f462938215b59de50183e7d7e4
  nilD :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m3,
     Unfolding: (Language.Haskell.TH.Syntax.DataD
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.nilD1
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
f22b2ac9d2b6da823776f21d0df988bf
  nilD1 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.nilD2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
9251d15cc8e069140aae706dac5db8aa
  nilD2 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
785a0663b1f54a9e18f60fa9a5809915
  nilD3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.nilD4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3cec6af6a99129f1cb30e10b88b648b0
  nilD4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NULL"#) -}
b73452fbeaf6011fde2dd9237195b536
  outcomeDec ::
    Agpl_syntax.OutcomeFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.outcomeDec1
                  `cast`
                (<Agpl_syntax.OutcomeFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
3b892a7819e09f1468d92d55586c78ee
  outcomeDec1 ::
    Agpl_syntax.OutcomeFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.OutcomeFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.OutcomeFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.outcomeDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
6a518b402d90d21a5c39136ac8df789f
  outcomeDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.outcomeDec3) -}
f4ebc983ef970456cea225f588a4006b
  outcomeDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3cc841462e1d74a0a985d813d9ed545a
  outcomeDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "outcome"#) -}
367eee6d7a3a72d9f4291577b3539ec1
  pieceT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.pieceT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.pieceT1)) -}
f6360ad45da01f8895364867940d6f29
  pieceT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.pieceT2) -}
f8da49daf9ff03910575136d624d7f39
  pieceT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
5e8b0ec403047552af1b6fe143edd6b8
  pieceT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Piece"#) -}
5c013f524421c95b272f79223520295d
  pieceT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
43dd10cfe794e1cb901b9071b9954f78
  pieceT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "piece"#) -}
72f89699d2a2ff6e1dc733176000cd4d
  playerDec ::
    Agpl_syntax.Player
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.playerDec1
                  `cast`
                (<Agpl_syntax.Player>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
bb8040f6a832ddfb3883c172f7d7d8c0
  playerDec1 ::
    Agpl_syntax.Player
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Player
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Player d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
778128bcdce32dbdc815b03114e651b0
  possmovesDec ::
    Agpl_syntax.PossMovesFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.possmovesDec1
                  `cast`
                (<Agpl_syntax.PossMovesFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
efc6e947f387883dc2093e2ef33bc871
  possmovesDec1 ::
    Agpl_syntax.PossMovesFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.PossMovesFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.PossMovesFun e
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.:
                           @ Language.Haskell.TH.Syntax.Dec
                           (Language.Haskell.TH.Syntax.ValD
                              CodeGen.possmovesDec2
                              (Language.Haskell.TH.Syntax.NormalB e)
                              (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                           (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                   Agpl_syntax.PMNil
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
2a458790289e52966a105b940d07363b
  possmovesDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.possmovesDec3) -}
f0cab2d76dc6e2d967a14422beee32e6
  possmovesDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.possmovesDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
31483cb8d8b5a1e7c0387c80b58e8372
  possmovesDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "possMoves"#) -}
8fa0790b60189ee80ed37b9074bc3018
  sizeDec :: GHC.Base.String -> Language.Haskell.TH.Syntax.Dec
  {- Arity: 1, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Exp
                        (Language.Haskell.Meta.Parse.parseExp1 w) of wild {
                   Data.Either.Left x1
                   -> case GHC.Err.undefined
                      ret_ty Language.Haskell.TH.Syntax.Dec
                      of {}
                   Data.Either.Right y
                   -> Language.Haskell.TH.Syntax.ValD
                        CodeGen.sizeDec1
                        (Language.Haskell.TH.Syntax.NormalB
                           (Language.Haskell.Meta.Syntax.Translate.$ctoExp1 y))
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
70d7011005a918439906e55225c573d6
  sizeDec1 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.sizeDec2) -}
f64ccbc7f1a2cdd81b0597e736cdb94a
  sizeDec2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.sizeDec3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
209644a08996511df01a9aed82dd5cb6
  sizeDec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "size"#) -}
d8d0cf775dd8603d8c977a75c3756211
  testD ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.testD1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
1d7f8bbf37636f0a905ba54c1133723f
  testD1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 let {
                   lvl25 :: GHC.Base.Monad m
                   = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                 } in
                 let {
                   lvl26 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD16
                 } in
                 let {
                   lvl27 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD15
                 } in
                 let {
                   lvl28 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD14
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl25
                   @ Language.Haskell.TH.Syntax.Name
                   @ [Language.Haskell.TH.Syntax.Dec]
                   lvl28
                   (\ x :: Language.Haskell.TH.Syntax.Name ->
                    GHC.Base.>>=
                      @ m
                      lvl25
                      @ Language.Haskell.TH.Syntax.Name
                      @ [Language.Haskell.TH.Syntax.Dec]
                      lvl28
                      (\ x1 :: Language.Haskell.TH.Syntax.Name ->
                       GHC.Base.>>=
                         @ m
                         lvl25
                         @ Language.Haskell.TH.Syntax.Name
                         @ [Language.Haskell.TH.Syntax.Dec]
                         lvl27
                         (\ x2 :: Language.Haskell.TH.Syntax.Name ->
                          let {
                            a9 :: forall (m1 :: * -> *).
                                  Language.Haskell.TH.Syntax.Quasi m1 =>
                                  m1 Language.Haskell.TH.Syntax.VarStrictType
                              {- Arity: 1 -}
                            = Language.Haskell.TH.Lib.varStrictType1
                                x2
                                CodeGen.testD10
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <Language.Haskell.TH.Syntax.StrictType>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            lvl25
                            @ Language.Haskell.TH.Syntax.Name
                            @ [Language.Haskell.TH.Syntax.Dec]
                            lvl26
                            (\ x3 :: Language.Haskell.TH.Syntax.Name ->
                             Language.Haskell.TH.Syntax.sequenceQ2
                               @ Language.Haskell.TH.Syntax.Dec
                               (GHC.Types.:
                                  @ Language.Haskell.TH.Lib.DecQ
                                  (Language.Haskell.TH.Lib.dataD1
                                     CodeGen.testD9
                                       `cast`
                                     (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                               <[Language.Haskell.TH.Syntax.Pred]>_N))
                                     x
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                                     (GHC.Types.:
                                        @ Language.Haskell.TH.Lib.ConQ
                                        (Language.Haskell.TH.Lib.recC1
                                           x1
                                           (GHC.Types.:
                                              @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                              a9
                                                `cast`
                                              (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                        <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                              (GHC.Types.:
                                                 @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                                 (Language.Haskell.TH.Lib.varStrictType1
                                                    x3
                                                    CodeGen.testD2
                                                      `cast`
                                                    (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                              <Language.Haskell.TH.Syntax.StrictType>_N)))
                                                   `cast`
                                                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                           <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                                 (GHC.Types.[]
                                                    @ Language.Haskell.TH.Lib.VarStrictTypeQ))))
                                          `cast`
                                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                  <Language.Haskell.TH.Syntax.Con>_N))
                                        (GHC.Types.[] @ Language.Haskell.TH.Lib.ConQ))
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name))
                                    `cast`
                                  (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                            <Language.Haskell.TH.Syntax.Dec>_N))
                                  (GHC.Types.[] @ Language.Haskell.TH.Lib.DecQ))
                               @ m
                               $dQuasi))))) -}
056b056269a07c88aa85dc0a02043d17
  testD10 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD11
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
5360e9d1e057931c4ecb1b02f3a14be9
  testD11 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD12)) -}
c783c50509f1e57cbe768008576f25f3
  testD12 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD13
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
e43653a50a87361499d16a91d3439deb
  testD13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Int"#) -}
059705d2264ec9edb5b6be990e97bc43
  testD14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A"#) -}
b5454a53737e82d71bb90cb7d1b6170f
  testD15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "b"#) -}
36c44a30854aec740a948c3146d76dd2
  testD16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
0eda257a902746deeb745f22a7463781
  testD2 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD3
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
b5d4bba45a03b9e1a7a2e878cb85b68d
  testD3 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD4)) -}
f16287182692ef678e1bf926f117ba24
  testD4 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD8
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
b06db7ce2fc426b5740758cf139c0ccc
  testD5 :: Language.Haskell.TH.Syntax.NameFlavour
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.NameG
                   Language.Haskell.TH.Syntax.TcClsName
                   CodeGen.testD7
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:PkgName[0]))
                   CodeGen.testD6
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:ModName[0]))) -}
4bd70aeaf499e3e21899e961529c6536
  testD6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GHC.Types"#) -}
accd8d248e66ca38bac5aa37e4b5ba99
  testD7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ghc-prim"#) -}
76216be83540500ca4c43b64f5258b0c
  testD8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Char"#) -}
f454aa6c4434f40b928acc2ef971c4ed
  testD9 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Pred]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLLLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta1 :: Language.Haskell.TH.Syntax.Quasi m ->
                 Language.Haskell.TH.Lib.cxt2
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)
                   @ m
                   eta1) -}
6c98f4ec3b78b69feb6b89a1398ad6be
  turnT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.turnT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.turnT1)) -}
9ec3705b82306ecafd826d1dd9e8dc23
  turnT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.turnT2) -}
77d65799037296a5d428ecaf48b2d983
  turnT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
b3e239a3ac7059513fd74b80a3052a9e
  turnT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Turn"#) -}
e83b5423f9c88e33c282250dceaf260f
  turnT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
b6326929bad2cae2311f2dd77399d256
  turnT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn"#) -}
49fb8351e5acbd48b9d5a089e2036791
  turnTypeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.turnTypeDec1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
01220742f124a4d897f2b274b08cbb63
  turnTypeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   CodeGen.turnTypeDec2) -}
7ee4e9f73be1ff7610a4e2e319e40b25
  turnTypeDec2 :: [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Dec
                   CodeGen.turnTypeDec3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
4368fd0a3517a8e3767170308f22abbc
  turnTypeDec3 :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.TySynD
                   CodeGen.turnT2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.gsDec16) -}
"SPEC/CodeGen lift @ Integer" [ALWAYS] forall tpl :: Language.Haskell.TH.Syntax.Lift
                                                       GHC.Integer.Type.Integer
  Language.Haskell.TH.Syntax.lift @ GHC.Integer.Type.Integer tpl
  = Language.Haskell.TH.Syntax.$fLiftInteger_$clift
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

