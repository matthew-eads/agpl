
==================== FINAL INTERFACE ====================
2015-11-30 16:47:23.814878 UTC

interface main@main:CodeGen 7102
  interface hash: 8b7e693a70fc6bb5a149bfa4c1935ee4
  ABI hash: 797558f8df9bc137ae713a6360e3e82c
  export-list hash: 05c7fd34c2f84b5b997dd6f1669f8235
  orphan hash: ab876434d53120bef7ce39f90b5e9748
  flag hash: 1e433d0ebc6754f04665631962e57d78
  sig of: Nothing
  used TH splices: False
  where
exports:
  CodeGen.boardT
  CodeGen.conToName
  CodeGen.customDataDec
  CodeGen.doNothing
  CodeGen.emptyDec
  CodeGen.fromStringDec
  CodeGen.gamestateDec
  CodeGen.gsDec
  CodeGen.handT
  CodeGen.inBoundsDec
  CodeGen.initStateDec
  CodeGen.isValidDec
  CodeGen.makeAGPLDecs
  CodeGen.moveDec
  CodeGen.nilD
  CodeGen.otherPlayerClause
  CodeGen.otherPlayerDec
  CodeGen.outcomeDec
  CodeGen.pieceT
  CodeGen.placeDec
  CodeGen.playerDec
  CodeGen.possmovesDec
  CodeGen.sizeDec
  CodeGen.testD
  CodeGen.turnT
  CodeGen.turnTypeDec
module dependencies: Agpl_syntax Parser
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0 text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  base-4.8.1.0:Data.Either bc9482e78cc431fce439b593377aa2e6
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8:Language.Haskell.Meta.Parse c926810653cf52d957a896d138bd5ba0
import  -/  Agpl_syntax d05bf7e6fa7fbb68e60c1d4d9bf005ed
  exports: 4205051c493e95e2869d33ce21432354
  Array e9b2f031c5146398177094ec3aecfd84
  Board 13da1373552f41f3c0f209a3ecac94ee
  Board 5a6575be8b22b0b0f59e88b700df439d
  CustOutcomeFun 13a225b70c0033dfe6404d02f8a6b18e
  CustomDataType ffb9365911492f05edc60da8eb7a0104
  CustomDataType 91192d1ac1cebe57c987b47b377cf6bc
  FromString 6135a123da0f66d7a10aadde97f1eaff
  FromString 46199bec460db4ebc556e57dcb2854df
  Game 8c70295046fb1010df2c49bc4fb4f32c
  Game 82923e9d91bd4448ce090c8aed9c5a6a
  GameState 16deb5f1426ec569bd3815464085d553
  InitState cabb4e294e2b8e5dc26f9253eb649cb2
  IsValidFun bd65e17278348d186c507c66bf484920
  IsValidFun 0a680fb879788e9038046ed45ae15c01
  Matrix 219cf5613dbd64af998dfc42ee587461
  Move 75bde73f3ed47fcd7281c6e64f7bb9a5
  Move 8b522c55ef1479ecee50454e18a45c6c
  OutcomeFun 70f074be50c0a288868c104210a20e93
  PMNil e8092ba103316e8754f683b43e462d2a
  Player 1ef82fd9ce86165572b45f15d1033738
  Player 85c3d8138db63776e4a143f6c7901685
  PossMovesFun 69a051a132d07df7fda637a89a47e01d
  PossMovesFun 50c820c9396d9c7dfcd245c39b536489
  board 9240c40287cbcd98ffb4cf595667777b
  boardInit d73f6bbedaa8a4f24243b4d11e763ff7
  elsecon e454c2e082ee75eece9bdc6d683beb9e
  hand eb19f0d1e86bff8e6fbbae71be517fdc
  piece f13a62b0bc85e116f4659bdc83150bab
  tiecon 22591ef32f27ed01423a77d9450c45a8
  turn 44783e2441694d687ced07df48f6d04d
  turnInit 305c3c20e7f6f2377ef9d171e6d9ab4a
  wincon b09fb148b335c3f24831da78114d198e
import  -/  Parser 1e0bd912f55c7fb8071934fb612b1507
  exports: 27a1bcc305332993e3a8d79c4b37cae6
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH cce81ae8a1596a0252bdcb72179c2937
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Quote 7a74e3dce88866c160fffb1503661817
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax afcf64bad3773d231089a8ce432131ab
import  -/  vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector 1ab51bec0be594f8c3b5e22942541591
22832ef9cb650523aed855bf08ec5860
  $wotherPlayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U>, Inline: [0],
     Unfolding: (\ w :: Language.Haskell.TH.Syntax.Dec ->
                 case w of wild {
                   DEFAULT -> CodeGen.otherPlayerDec3
                   Language.Haskell.TH.Syntax.DataD ds ds1 ds2 players ds3
                   -> case ds of wild1 {
                        []
                        -> case ds2 of wild2 {
                             []
                             -> let {
                                  a9 :: [Language.Haskell.TH.Syntax.Clause]
                                  = let {
                                      playerNames :: [Language.Haskell.TH.Syntax.Name]
                                      = GHC.Base.map
                                          @ Language.Haskell.TH.Syntax.Con
                                          @ Language.Haskell.TH.Syntax.Name
                                          CodeGen.conToName
                                          players
                                    } in
                                    let {
                                      a10 :: Language.Haskell.TH.Syntax.Name
                                      = CodeGen.otherPlayerDec_go
                                          playerNames
                                          (GHC.List.lastError @ Language.Haskell.TH.Syntax.Name)
                                    } in
                                    let {
                                      a11 :: Language.Haskell.TH.Syntax.Pat
                                      = Language.Haskell.TH.Syntax.ConP
                                          a10
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)
                                    } in
                                    let {
                                      a12 :: [Language.Haskell.TH.Syntax.Pat]
                                      = GHC.Types.:
                                          @ Language.Haskell.TH.Syntax.Pat
                                          a11
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)
                                    } in
                                    let {
                                      a13 :: Language.Haskell.TH.Syntax.Name
                                      = case playerNames of wild3 {
                                          [] -> GHC.List.badHead @ Language.Haskell.TH.Syntax.Name
                                          : x ds4 -> x }
                                    } in
                                    let {
                                      a14 :: Language.Haskell.TH.Syntax.Exp
                                      = Language.Haskell.TH.Syntax.ConE a13
                                    } in
                                    let {
                                      a15 :: Language.Haskell.TH.Syntax.Body
                                      = Language.Haskell.TH.Syntax.NormalB a14
                                    } in
                                    let {
                                      a16 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                                      = Language.Haskell.TH.Syntax.Clause
                                          a12
                                          a15
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                    } in
                                    let {
                                      z :: [Language.Haskell.TH.Syntax.Clause]
                                      = GHC.Types.:
                                          @ Language.Haskell.TH.Syntax.Clause
                                          a16
                                          (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                                    } in
                                    letrec {
                                      go :: [Language.Haskell.TH.Syntax.Name]
                                            -> [Language.Haskell.TH.Syntax.Name]
                                            -> [Language.Haskell.TH.Syntax.Clause]
                                        {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                                      = \ ds4 :: [Language.Haskell.TH.Syntax.Name]
                                          _ys :: [Language.Haskell.TH.Syntax.Name] ->
                                        case ds4 of wild3 {
                                          [] -> z
                                          : ipv ipv1
                                          -> case _ys of wild4 {
                                               [] -> z
                                               : ipv2 ipv3
                                               -> GHC.Types.:
                                                    @ Language.Haskell.TH.Syntax.Clause
                                                    (CodeGen.otherPlayerClause ipv ipv2)
                                                    (go ipv1 ipv3) } }
                                    } in
                                    go
                                      playerNames
                                      (CodeGen.$wunsafeDrop
                                         @ Language.Haskell.TH.Syntax.Name
                                         1
                                         playerNames)
                                } in
                                let {
                                  a10 :: Language.Haskell.TH.Syntax.Dec
                                  = Language.Haskell.TH.Syntax.FunD CodeGen.otherPlayerDec1 a9
                                } in
                                let {
                                  x :: [Language.Haskell.TH.Syntax.Dec]
                                  = GHC.Types.:
                                      @ Language.Haskell.TH.Syntax.Dec
                                      a10
                                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                                } in
                                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                                 GHC.Base.return
                                   @ m
                                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                                   @ [Language.Haskell.TH.Syntax.Dec]
                                   x)
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <[Language.Haskell.TH.Syntax.Dec]>_N))
                             : ipv ipv1 -> CodeGen.otherPlayerDec3 }
                        : ipv ipv1 -> CodeGen.otherPlayerDec3 } }) -}
dd3152fc5c50b488bbfc35b048b05dd9
  $wplayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ ww :: Language.Haskell.TH.Syntax.Dec ->
                 let {
                   ds :: Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
                   = CodeGen.$wotherPlayerDec ww
                 } in
                 (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                  let {
                    lvl23 :: GHC.Base.Monad m
                    = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                  } in
                  GHC.Base.>>=
                    @ m
                    lvl23
                    @ [Language.Haskell.TH.Syntax.Dec]
                    @ [Language.Haskell.TH.Syntax.Dec]
                    (ds
                       `cast`
                     (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)
                       @ m
                       $dQuasi)
                    (\ x :: [Language.Haskell.TH.Syntax.Dec] ->
                     GHC.Base.return
                       @ m
                       lvl23
                       @ [Language.Haskell.TH.Syntax.Dec]
                       (GHC.Types.: @ Language.Haskell.TH.Syntax.Dec ww x)))
                   `cast`
                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                           <[Language.Haskell.TH.Syntax.Dec]>_N))) -}
5eb7e38badecbba5513aed292169feae
  $wunsafeDrop :: GHC.Prim.Int# -> [a1] -> [a1]
  {- Arity: 2, HasNoCafRefs, Strictness: <L,1*U><S,1*U>,
     Inline: [0] -}
83ba6af2c236c895b251fc4a097e9286
  boardT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.boardT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.boardT1)) -}
27d1662a40773b346f840320f3398a70
  boardT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.boardT2) -}
53b6f562cfad6df7a87e4eda283728ac
  boardT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
593cbcfd0566bba215a1bc362d89b524
  boardT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Board"#) -}
1871d42adab363632c30709171533812
  boardT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.boardT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
f0e65ef3ce3a6df7cd16e4751f3c316e
  boardT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board"#) -}
31c836fa04fb693a223ab35d590d044d
  conToName ::
    Language.Haskell.TH.Syntax.Con -> Language.Haskell.TH.Syntax.Name
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Language.Haskell.TH.Syntax.Con ->
                 case ds of wild {
                   Language.Haskell.TH.Syntax.NormalC name ds1 -> name
                   Language.Haskell.TH.Syntax.RecC name ds1 -> name
                   Language.Haskell.TH.Syntax.InfixC ds1 name ds2 -> name
                   Language.Haskell.TH.Syntax.ForallC ipv ipv1 ipv2
                   -> GHC.Err.undefined @ Language.Haskell.TH.Syntax.Name }) -}
e9a9a6dceb28c89c1392144712cd6fb5
  customDataDec ::
    Agpl_syntax.CustomDataType
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.customDataDec1
                  `cast`
                (<Agpl_syntax.CustomDataType>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
0f01efc15bcc2ae3f030c34b980a06e9
  customDataDec1 ::
    Agpl_syntax.CustomDataType
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.CustomDataType
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.CustomDataType d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
325c67093be23910b938ee023fee18db
  doNothing :: Language.Haskell.TH.Syntax.Q ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.doNothing1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0] <()>_N)) -}
bd1c3c2390e3f857db925369441f2cfb
  doNothing1 :: Language.Haskell.TH.Syntax.Quasi m => m ()
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ ()
                   GHC.Tuple.()) -}
3e8f7b348be0cef361cd7fa340228198
  emptyDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.emptyDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
53f8df07dc81422627dc11dbed9690f4
  emptyDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.Board
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.Matrix ds1
                   -> case CodeGen.emptyDec5 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Array ds1
                   -> case CodeGen.emptyDec2 of wild1 {
                        Data.Either.Left err
                        -> GHC.Base.return
                             @ m
                             (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                             @ [Language.Haskell.TH.Syntax.Dec]
                             (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                        Data.Either.Right ds2
                        -> Language.Haskell.TH.Syntax.$creturn1
                             @ [Language.Haskell.TH.Syntax.Dec]
                             ds2
                             @ m
                             eta }
                   Agpl_syntax.Board ipv
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
1dba1f81aeb4df22ee874ae91a3e74c9
  emptyDec2 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec3 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
4e01fcf6519a88b08ccb7a8e3d2d36ed
  emptyDec3 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec4) -}
fcaee9ae8b71f10fad4abb15772988db
  emptyDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty i game = (((board game) V.! i) == Nil)"#) -}
d1dc2eeeb4275e11e436029d7dacd750
  emptyDec5 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.emptyDec6 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
fca9de829bfcb9f14e3c45a68edfe7f6
  emptyDec6 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.emptyDec7) -}
286ef5dccb9e2043ea987cfe23b5227a
  emptyDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "isEmpty (i, j) game = (((board game) M.! (i,j)) == Nil)"#) -}
e8e771636e2705a2919e6884326ce8f4
  fromStringDec ::
    Agpl_syntax.FromString
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.fromStringDec1
                  `cast`
                (<Agpl_syntax.FromString>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
598395b990f27c57955ccd3ba8dbac8c
  fromStringDec1 ::
    Agpl_syntax.FromString
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.FromString
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.FromString e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.fromStringDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
af35867b94f5d456e04373cd2951b6b0
  fromStringDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.fromStringDec3) -}
6e7b301af8f80101093a9b04c0357244
  fromStringDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.fromStringDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
2b185670de0e7a32aa7e9903190da30c
  fromStringDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "fromString"#) -}
417ef2a706258e9637c8b5a66512e673
  gamestateDec ::
    Agpl_syntax.GameState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <L,U(1*U,1*U,1*U,1*U)> -}
ca5db38e066190c4b1080b28d610b3c2
  gsDec ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.gsDec1
                  `cast`
                (<[Language.Haskell.TH.Syntax.VarStrictType]>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
947c439e89f372a78266b4c9e840c494
  gsDec1 ::
    [Language.Haskell.TH.Syntax.VarStrictType]
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ types :: [Language.Haskell.TH.Syntax.VarStrictType]
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.DataD
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                         CodeGen.gsDec21
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                         (GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Con
                            (Language.Haskell.TH.Syntax.RecC CodeGen.gsDec21 types)
                            CodeGen.gsDec8)
                         CodeGen.gsDec2)
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))) -}
9dd0e616a4f4ac3975f36f7ecd8fe459
  gsDec10 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec11
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
96ba61babeec3c1bb9d61b039e27e8c8
  gsDec11 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec12
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
814729f897df86b0b640768df712cd63
  gsDec12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
13f21344b2d2a07a974e0823db305c99
  gsDec13 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.gsDec19
                   CodeGen.gsDec14) -}
b768ce96cee56e936bb65efca6f74756
  gsDec14 :: [Language.Haskell.TH.Syntax.StrictType]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.StrictType
                   CodeGen.gsDec15
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
03ea48f0fa1337d79efb18d4670da7ef
  gsDec15 ::
    (Language.Haskell.TH.Syntax.Strict,
     Language.Haskell.TH.Syntax.Type)
  {- Strictness: m,
     Unfolding: ((Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.gsDec16)) -}
bd87df691b8b42d1847ed3b4fe4ca8cb
  gsDec16 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.gsDec17) -}
1d6d9cebed47d2dc13f2926ff2dd98fd
  gsDec17 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec18
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
943f251289847a821f272d87a470e1d0
  gsDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Player"#) -}
75cb81cff19b4fc5e27cf80efe2b9fcd
  gsDec19 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec20
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
f4406ffa0cf9de5d4fa067bd415e5827
  gsDec2 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec6
                   CodeGen.gsDec3) -}
b884f1f179a3f3aa5d530c0af52853ed
  gsDec20 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win"#) -}
179433c01f8740f5ab80bea4f4fe0ec9
  gsDec21 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec22
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
60519b8ded863a9c7e909e92fcc7f997
  gsDec22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState"#) -}
420af152e6c9b6fd1c2fe12736d1e961
  gsDec3 :: [Language.Haskell.TH.Syntax.Name]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Name
                   CodeGen.gsDec4
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
fb733efbe81ac3c4b61a71eb5abd2e42
  gsDec4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
727324f00840f4c82ebdc9cf2bc5c91b
  gsDec5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Eq"#) -}
9684003c09c32bc9943dea8d4b807e80
  gsDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.gsDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
0e93c94bc6a96e4090a37bd987e02d73
  gsDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Show"#) -}
2108ccc8ca8aa4fe33a99bf371c0b72e
  gsDec8 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec13
                   CodeGen.gsDec9) -}
3928def8af92c9de7258c2a362dc0f4b
  gsDec9 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.gsDec10
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
3c73c02d51b17b4bb842c80155ec7857
  handT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.handT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.handT1)) -}
3d5181bfd78aefed0c790df1756083a2
  handT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.handT2) -}
decce5ffe1bde720355c0b1ce23af124
  handT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
63e47aaee9d208afd1c531c34f938fe0
  handT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hand"#) -}
c281486f1f606bcbf2a212b3c2e48508
  handT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.handT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a0035600f323685750fb2a44f1a77404
  handT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hand"#) -}
01dd4111df6c0fe8b9ccfc40eef6af61
  inBoundsDec ::
    Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.inBoundsDec1
                  `cast`
                (<Agpl_syntax.Board>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
234704fd12b34761b89ff79b33459339
  inBoundsDec1 ::
    Agpl_syntax.Board
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(SLLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)> -}
1d45b0db8e7deda1c34034aefe25f501
  initStateDec ::
    Agpl_syntax.InitState
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.initStateDec1
                  `cast`
                (<Agpl_syntax.InitState>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
c9f7e2b91f0cdb5d5008192e667f0fa6
  initStateDec1 ::
    Agpl_syntax.InitState
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <L,U(1*U,1*U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ is :: Agpl_syntax.InitState
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.initStateDec5
                         (Language.Haskell.TH.Syntax.NormalB
                            (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds1 }))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.:
                         @ Language.Haskell.TH.Syntax.Dec
                         (Language.Haskell.TH.Syntax.ValD
                            CodeGen.initStateDec2
                            (Language.Haskell.TH.Syntax.NormalB
                               (case is of wild { Agpl_syntax.InitState ds1 ds2 -> ds2 }))
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)))) -}
7dd0c2cd9d0b360eb1b535cbdecf85a5
  initStateDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec3) -}
d102c1f9fc0f7a8c8d84ad1ffe296143
  initStateDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
4b6dc74fd1de97b8ea1474bc3e886e33
  initStateDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turn"#) -}
0e4bd54241f59df7663e311ec77fdf81
  initStateDec5 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.initStateDec6) -}
c6a33542e65266345d26f93f17b103e9
  initStateDec6 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.initStateDec7
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
9e9df0b74075458652491f0af1eb3257
  initStateDec7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boardInitF"#) -}
ada1205c0a2b634559ead13340102115
  isValidDec ::
    Agpl_syntax.IsValidFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.isValidDec1
                  `cast`
                (<Agpl_syntax.IsValidFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
1f90827578a7946f19bf2ab4f82caac1
  isValidDec1 ::
    Agpl_syntax.IsValidFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.IsValidFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.IsValidFun e ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      (Language.Haskell.TH.Syntax.ValD
                         CodeGen.isValidDec2
                         (Language.Haskell.TH.Syntax.NormalB e)
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
550970d637ccda258507eaddd8874420
  isValidDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.isValidDec3) -}
6f5b89c25a339b81c558b4ecab33faaf
  isValidDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.isValidDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
a7220a2b78cb414d67e68c0b80a21cd0
  isValidDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "isValid"#) -}
10ff2d3f4fdc1b18a6f3f376da09b360
  makeAGPLDecs ::
    Agpl_syntax.Game
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U> -}
62c69398a8fc62af8514f0eabc0b01f3
  moveDec ::
    Agpl_syntax.Move
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.moveDec1
                  `cast`
                (<Agpl_syntax.Move>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
7972df668ab8bee7fbd0aa9e54d8ede4
  moveDec1 ::
    Agpl_syntax.Move
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S,1*U(U)><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Agpl_syntax.Move
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild { Agpl_syntax.Move d ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Dec
                      d
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) }) -}
4d8532f462938215b59de50183e7d7e4
  nilD :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m3,
     Unfolding: (Language.Haskell.TH.Syntax.DataD
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pred)
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.nilD1
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name)) -}
f22b2ac9d2b6da823776f21d0df988bf
  nilD1 :: [Language.Haskell.TH.Syntax.Con]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Con
                   CodeGen.nilD2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Con)) -}
9251d15cc8e069140aae706dac5db8aa
  nilD2 :: Language.Haskell.TH.Syntax.Con
  {- Strictness: m1,
     Unfolding: (Language.Haskell.TH.Syntax.NormalC
                   CodeGen.nilD3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.StrictType)) -}
785a0663b1f54a9e18f60fa9a5809915
  nilD3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.nilD4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
3cec6af6a99129f1cb30e10b88b648b0
  nilD4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "NULL"#) -}
f9832d353de2dfeaf63f16c542b222dc
  otherPlayerClause ::
    Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Clause
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m,
     Unfolding: InlineRule (2, True, False)
                (\ p1 :: Language.Haskell.TH.Syntax.Name
                   p2 :: Language.Haskell.TH.Syntax.Name ->
                 Language.Haskell.TH.Syntax.Clause
                   (GHC.Types.:
                      @ Language.Haskell.TH.Syntax.Pat
                      (Language.Haskell.TH.Syntax.ConP
                         p1
                         (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat))
                      (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat))
                   (Language.Haskell.TH.Syntax.NormalB
                      (Language.Haskell.TH.Syntax.ConE p2))
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
6cc466994dc06bce49cc1c9642aad0a9
  otherPlayerDec ::
    Language.Haskell.TH.Syntax.Dec
    -> GHC.Types.Int
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2, Strictness: <S,1*U><L,A>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, True)
                (\ w :: Language.Haskell.TH.Syntax.Dec w1 :: GHC.Types.Int ->
                 CodeGen.$wotherPlayerDec w) -}
0ed6141a2c76bbdb42ee60867254f397
  otherPlayerDec1 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.otherPlayerDec2
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
ed388f9dc94f61ab5984df3f556d5fd0
  otherPlayerDec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "otherPlayer"#) -}
58539dd999e015ba5558e97f389d6d46
  otherPlayerDec3 ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: b -}
747a3c4a7f1ddeca9fe30fe659f38481
  otherPlayerDec_go ::
    [Language.Haskell.TH.Syntax.Name]
    -> Language.Haskell.TH.Syntax.Name
    -> Language.Haskell.TH.Syntax.Name
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*U(U,U)> -}
68e2bd4843c22f27a0b3765a59ac32ca
  outcomeDec ::
    Agpl_syntax.OutcomeFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ ds :: Agpl_syntax.OutcomeFun ->
                 case ds of wild {
                   Agpl_syntax.CustOutcomeFun e
                   -> let {
                        a9 :: Language.Haskell.TH.Syntax.Body
                        = Language.Haskell.TH.Syntax.NormalB e
                      } in
                      let {
                        a10 :: Language.Haskell.TH.Syntax.Dec
                        = Language.Haskell.TH.Syntax.ValD
                            CodeGen.outcomeDec19
                            a9
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                      } in
                      let {
                        x :: [Language.Haskell.TH.Syntax.Dec]
                        = GHC.Types.:
                            @ Language.Haskell.TH.Syntax.Dec
                            a10
                            (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                      } in
                      (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                       GHC.Base.return
                         @ m
                         (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                         @ [Language.Haskell.TH.Syntax.Dec]
                         x)
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <[Language.Haskell.TH.Syntax.Dec]>_N))
                   Agpl_syntax.OutcomeFun ipv ipv1 ipv2
                   -> case CodeGen.outcomeDec16 of wild1 {
                        Data.Either.Left err
                        -> let {
                             x :: [Language.Haskell.TH.Syntax.Dec]
                             = Debug.Trace.trace
                                 @ [Language.Haskell.TH.Syntax.Dec]
                                 err
                                 (GHC.Err.undefined @ [Language.Haskell.TH.Syntax.Dec])
                           } in
                           (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                            GHC.Base.return
                              @ m
                              (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                              @ [Language.Haskell.TH.Syntax.Dec]
                              x)
                             `cast`
                           (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <[Language.Haskell.TH.Syntax.Dec]>_N))
                        Data.Either.Right ds1
                        -> let {
                             a9 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv2
                           } in
                           let {
                             a10 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec11
                                 a9
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a11 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a10
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a12 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec9 a11
                           } in
                           let {
                             a13 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv
                           } in
                           let {
                             a14 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec5
                                 a13
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a15 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a14
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a16 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec3 a15
                           } in
                           let {
                             a17 :: Language.Haskell.TH.Syntax.Body
                             = Language.Haskell.TH.Syntax.NormalB ipv1
                           } in
                           let {
                             a18 :: Language.Haskell.TH.Syntax.Clause {- Strictness: m -}
                             = Language.Haskell.TH.Syntax.Clause
                                 CodeGen.outcomeDec5
                                 a17
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)
                           } in
                           let {
                             a19 :: [Language.Haskell.TH.Syntax.Clause]
                             = GHC.Types.:
                                 @ Language.Haskell.TH.Syntax.Clause
                                 a18
                                 (GHC.Types.[] @ Language.Haskell.TH.Syntax.Clause)
                           } in
                           let {
                             a20 :: Language.Haskell.TH.Syntax.Dec
                             = Language.Haskell.TH.Syntax.FunD CodeGen.outcomeDec1 a19
                           } in
                           let {
                             a21 :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a20 ds1
                           } in
                           let {
                             a22 :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a16 a21
                           } in
                           let {
                             x :: [Language.Haskell.TH.Syntax.Dec]
                             = GHC.Types.: @ Language.Haskell.TH.Syntax.Dec a12 a22
                           } in
                           (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                            GHC.Base.return
                              @ m
                              (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                              @ [Language.Haskell.TH.Syntax.Dec]
                              x)
                             `cast`
                           (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                     <[Language.Haskell.TH.Syntax.Dec]>_N)) } }) -}
4a1cc927808dceff5a29ed5f3b8f974e
  outcomeDec1 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec2
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
04394d45dbd3a5371ee555ab42108727
  outcomeDec10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "elsec"#) -}
da21599882882a096f8cd0c11d98b1c6
  outcomeDec11 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec6
                   CodeGen.outcomeDec12) -}
3db81fd2564ce21b6f55c14d9d7deedf
  outcomeDec12 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec13
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)) -}
f42ea4793cb05bcf2f26363665b3bb36
  outcomeDec13 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.outcomeDec14) -}
61cc6909107be89a296983bcdfd5dac4
  outcomeDec14 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec15
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
736d5ceef5483421bfa9acb6511481f0
  outcomeDec15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "move"#) -}
551827a6d5875ce658fc9e8bf0f0d221
  outcomeDec16 ::
    Data.Either.Either GHC.Base.String [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.outcomeDec17 of wild {
                   Data.Either.Left x1
                   -> Data.Either.Left
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        x1
                   Data.Either.Right y
                   -> Data.Either.Right
                        @ GHC.Base.String
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                         Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                           @ Language.Haskell.Exts.Syntax.Decl
                           Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                             `cast`
                           (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                     <Language.Haskell.Exts.Syntax.Decl>_N))
                           x1 }) }) -}
b156d39c59cf3eba43fdd6eda98d4997
  outcomeDec17 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.outcomeDec18) -}
81cdeb814919d93ad363231dfe91ccd0
  outcomeDec18 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "outcome game move = if (winc game) then (Win (currentTurn game), 1) else if (tiec game) then (Tie, 1) else let g = elsec game move in if (winc g) then (Win (currentTurn game), 1) else if (tiec g) then (Tie, 1) else (g, 1)"#) -}
a90f41215459057cf9d3336233c9e98b
  outcomeDec19 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.outcomeDec20) -}
004bee25077ccfaa7dcbfb80c6743e71
  outcomeDec2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tiec"#) -}
8c609369584b9691dda3b1ac4bc82f54
  outcomeDec20 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec21
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
d478863c3c3046a4e3d89f970cc7eb10
  outcomeDec21 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "outcome"#) -}
6560f0d503d99c6c6d9843a99d8dddf7
  outcomeDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
e69e245f125a303e0e447cd7bd291b56
  outcomeDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "winc"#) -}
c65a84076ab52a551d5394ec5197b664
  outcomeDec5 :: [Language.Haskell.TH.Syntax.Pat]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Pat
                   CodeGen.outcomeDec6
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Pat)) -}
d48f4147e4215728c7279fc5aa39392d
  outcomeDec6 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.outcomeDec7) -}
ce67f2c478e6e4d95805758c093bca75
  outcomeDec7 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec8
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
62122bcf18b33d04d2dfb78238cdc3ef
  outcomeDec8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "game"#) -}
5373bd745c5c7c3e74c2834b06240e86
  outcomeDec9 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.outcomeDec10
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
367eee6d7a3a72d9f4291577b3539ec1
  pieceT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.pieceT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.pieceT1)) -}
f6360ad45da01f8895364867940d6f29
  pieceT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.pieceT2) -}
f8da49daf9ff03910575136d624d7f39
  pieceT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
5e8b0ec403047552af1b6fe143edd6b8
  pieceT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Piece"#) -}
5c013f524421c95b272f79223520295d
  pieceT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.pieceT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
43dd10cfe794e1cb901b9071b9954f78
  pieceT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "piece"#) -}
3c11462e557e44f058dfa59e0aedcaaa
  placeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Unfolding: (case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Module
                        CodeGen.placeDec2 of wild {
                   Data.Either.Left x1
                   -> Debug.Trace.trace
                        @ (Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec])
                        (GHC.CString.unpackAppendCString# "placeDec error: "# x1)
                        CodeGen.placeDec1
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                  <[Language.Haskell.TH.Syntax.Dec]>_N))
                   Data.Either.Right y
                   -> let {
                        x :: [Language.Haskell.TH.Syntax.Dec]
                        = case y of wild1 { Language.Haskell.Exts.Syntax.Module ds ds1 ds2 ds3 ds4 ds5 x1 ->
                          Language.Haskell.Meta.Syntax.Translate.$fToDecs[]_$ctoDecs
                            @ Language.Haskell.Exts.Syntax.Decl
                            Language.Haskell.Meta.Syntax.Translate.$ctoDecs
                              `cast`
                            (Sym (Language.Haskell.Meta.Syntax.Translate.NTCo:ToDecs[0]
                                      <Language.Haskell.Exts.Syntax.Decl>_N))
                            x1 }
                      } in
                      (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                       GHC.Base.return
                         @ m
                         (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                         @ [Language.Haskell.TH.Syntax.Dec]
                         x)
                        `cast`
                      (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                <[Language.Haskell.TH.Syntax.Dec]>_N)) }) -}
33b8211644fe12898950f856de806f93
  placeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
7ce8d2ce505c212df7abfcbcce87fbc4
  placeDec2 ::
    Language.Haskell.Exts.ParseMonad.ParseResult
      Language.Haskell.Exts.Syntax.Module
  {- Unfolding: (Language.Haskell.Meta.Parse.parseDecs1
                   CodeGen.placeDec3) -}
82873d302850e56ca9792b7b887e1359
  placeDec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "place game piece coord = let b = setElem piece coord (board game)\n\
                   \                             t = otherPlayer (currentTurn game)\n\
                   \                         in GameState{board=b, currentTurn=t}"#) -}
014dd59dd55743000157896de37f64b7
  playerDec ::
    Agpl_syntax.Player
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1, Strictness: <S(S),1*U(1*U(U,A))>, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: Agpl_syntax.Player ->
                 case w of ww { Agpl_syntax.Player ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 -> CodeGen.$wplayerDec ww3 } }) -}
778128bcdce32dbdc815b03114e651b0
  possmovesDec ::
    Agpl_syntax.PossMovesFun
    -> Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.possmovesDec1
                  `cast`
                (<Agpl_syntax.PossMovesFun>_R
                 ->_R Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                               <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
efc6e947f387883dc2093e2ef33bc871
  possmovesDec1 ::
    Agpl_syntax.PossMovesFun
    -> forall (m :: * -> *).
       Language.Haskell.TH.Syntax.Quasi m =>
       m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 2,
     Strictness: <S,1*U><S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: (\ ds :: Agpl_syntax.PossMovesFun
                   @ (m :: * -> *)
                   eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 case ds of wild {
                   Agpl_syntax.PossMovesFun e
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.:
                           @ Language.Haskell.TH.Syntax.Dec
                           (Language.Haskell.TH.Syntax.ValD
                              CodeGen.possmovesDec2
                              (Language.Haskell.TH.Syntax.NormalB e)
                              (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                           (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec))
                   Agpl_syntax.PMNil
                   -> GHC.Base.return
                        @ m
                        (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                        @ [Language.Haskell.TH.Syntax.Dec]
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
2a458790289e52966a105b940d07363b
  possmovesDec2 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP
                   CodeGen.possmovesDec3) -}
f0cab2d76dc6e2d967a14422beee32e6
  possmovesDec3 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.possmovesDec4
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
31483cb8d8b5a1e7c0387c80b58e8372
  possmovesDec4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "possMoves"#) -}
8fa0790b60189ee80ed37b9074bc3018
  sizeDec :: GHC.Base.String -> Language.Haskell.TH.Syntax.Dec
  {- Arity: 1, Strictness: <L,U>m2, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 case Language.Haskell.Meta.Parse.parseResultToEither
                        @ Language.Haskell.Exts.Syntax.Exp
                        (Language.Haskell.Meta.Parse.parseExp1 w) of wild {
                   Data.Either.Left x1
                   -> case GHC.Err.undefined
                      ret_ty Language.Haskell.TH.Syntax.Dec
                      of {}
                   Data.Either.Right y
                   -> Language.Haskell.TH.Syntax.ValD
                        CodeGen.sizeDec1
                        (Language.Haskell.TH.Syntax.NormalB
                           (Language.Haskell.Meta.Syntax.Translate.$ctoExp1 y))
                        (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec) }) -}
70d7011005a918439906e55225c573d6
  sizeDec1 :: Language.Haskell.TH.Syntax.Pat
  {- Strictness: m2,
     Unfolding: (Language.Haskell.TH.Syntax.VarP CodeGen.sizeDec2) -}
f64ccbc7f1a2cdd81b0597e736cdb94a
  sizeDec2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.sizeDec3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
209644a08996511df01a9aed82dd5cb6
  sizeDec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "size"#) -}
649b678d5b4e9ea09531af0d2b2a8624
  testD ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.testD1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
511b0141d93391da397e19b13108b188
  testD1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LC(C(S))LLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: (\ @ (m :: * -> *)
                   $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 let {
                   lvl23 :: GHC.Base.Monad m
                   = Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi
                 } in
                 let {
                   lvl24 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD16
                 } in
                 let {
                   lvl25 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD15
                 } in
                 let {
                   lvl26 :: m Language.Haskell.TH.Syntax.Name
                   = Language.Haskell.TH.Syntax.qNewName @ m $dQuasi CodeGen.testD14
                 } in
                 GHC.Base.>>=
                   @ m
                   lvl23
                   @ Language.Haskell.TH.Syntax.Name
                   @ [Language.Haskell.TH.Syntax.Dec]
                   lvl26
                   (\ x :: Language.Haskell.TH.Syntax.Name ->
                    GHC.Base.>>=
                      @ m
                      lvl23
                      @ Language.Haskell.TH.Syntax.Name
                      @ [Language.Haskell.TH.Syntax.Dec]
                      lvl26
                      (\ x1 :: Language.Haskell.TH.Syntax.Name ->
                       GHC.Base.>>=
                         @ m
                         lvl23
                         @ Language.Haskell.TH.Syntax.Name
                         @ [Language.Haskell.TH.Syntax.Dec]
                         lvl25
                         (\ x2 :: Language.Haskell.TH.Syntax.Name ->
                          let {
                            a9 :: forall (m1 :: * -> *).
                                  Language.Haskell.TH.Syntax.Quasi m1 =>
                                  m1 Language.Haskell.TH.Syntax.VarStrictType
                              {- Arity: 1 -}
                            = Language.Haskell.TH.Lib.varStrictType1
                                x2
                                CodeGen.testD10
                                  `cast`
                                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                          <Language.Haskell.TH.Syntax.StrictType>_N))
                          } in
                          GHC.Base.>>=
                            @ m
                            lvl23
                            @ Language.Haskell.TH.Syntax.Name
                            @ [Language.Haskell.TH.Syntax.Dec]
                            lvl24
                            (\ x3 :: Language.Haskell.TH.Syntax.Name ->
                             Language.Haskell.TH.Syntax.sequenceQ2
                               @ Language.Haskell.TH.Syntax.Dec
                               (GHC.Types.:
                                  @ Language.Haskell.TH.Lib.DecQ
                                  (Language.Haskell.TH.Lib.dataD1
                                     CodeGen.testD9
                                       `cast`
                                     (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                               <[Language.Haskell.TH.Syntax.Pred]>_N))
                                     x
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                                     (GHC.Types.:
                                        @ Language.Haskell.TH.Lib.ConQ
                                        (Language.Haskell.TH.Lib.recC1
                                           x1
                                           (GHC.Types.:
                                              @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                              a9
                                                `cast`
                                              (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                        <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                              (GHC.Types.:
                                                 @ Language.Haskell.TH.Lib.VarStrictTypeQ
                                                 (Language.Haskell.TH.Lib.varStrictType1
                                                    x3
                                                    CodeGen.testD2
                                                      `cast`
                                                    (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                              <Language.Haskell.TH.Syntax.StrictType>_N)))
                                                   `cast`
                                                 (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                           <Language.Haskell.TH.Syntax.VarStrictType>_N))
                                                 (GHC.Types.[]
                                                    @ Language.Haskell.TH.Lib.VarStrictTypeQ))))
                                          `cast`
                                        (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                                  <Language.Haskell.TH.Syntax.Con>_N))
                                        (GHC.Types.[] @ Language.Haskell.TH.Lib.ConQ))
                                     (GHC.Types.[] @ Language.Haskell.TH.Syntax.Name))
                                    `cast`
                                  (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                                            <Language.Haskell.TH.Syntax.Dec>_N))
                                  (GHC.Types.[] @ Language.Haskell.TH.Lib.DecQ))
                               @ m
                               $dQuasi))))) -}
056b056269a07c88aa85dc0a02043d17
  testD10 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD11
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
5360e9d1e057931c4ecb1b02f3a14be9
  testD11 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD12)) -}
c783c50509f1e57cbe768008576f25f3
  testD12 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD13
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
e43653a50a87361499d16a91d3439deb
  testD13 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Int"#) -}
059705d2264ec9edb5b6be990e97bc43
  testD14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "A"#) -}
b5454a53737e82d71bb90cb7d1b6170f
  testD15 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "b"#) -}
36c44a30854aec740a948c3146d76dd2
  testD16 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "c"#) -}
0eda257a902746deeb745f22a7463781
  testD2 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.StrictType
  {- Arity: 1,
     Unfolding: (Language.Haskell.TH.Lib.strictType1
                   Language.Haskell.TH.Lib.notStrict1
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Strict>_N))
                   CodeGen.testD3
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                             <Language.Haskell.TH.Syntax.Type>_N))) -}
b5d4bba45a03b9e1a7a2e878cb85b68d
  testD3 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m Language.Haskell.TH.Syntax.Type
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m eta)
                   @ Language.Haskell.TH.Syntax.Type
                   (Language.Haskell.TH.Syntax.ConT CodeGen.testD4)) -}
f16287182692ef678e1bf926f117ba24
  testD4 :: Language.Haskell.TH.Syntax.Name
  {- Strictness: m,
     Unfolding: (Language.Haskell.TH.Syntax.Name
                   CodeGen.testD8
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                   CodeGen.testD5) -}
b06db7ce2fc426b5740758cf139c0ccc
  testD5 :: Language.Haskell.TH.Syntax.NameFlavour
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.NameG
                   Language.Haskell.TH.Syntax.TcClsName
                   CodeGen.testD7
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:PkgName[0]))
                   CodeGen.testD6
                     `cast`
                   (Sym (Language.Haskell.TH.Syntax.NTCo:ModName[0]))) -}
4bd70aeaf499e3e21899e961529c6536
  testD6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GHC.Types"#) -}
accd8d248e66ca38bac5aa37e4b5ba99
  testD7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "ghc-prim"#) -}
76216be83540500ca4c43b64f5258b0c
  testD8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Char"#) -}
f454aa6c4434f40b928acc2ef971c4ed
  testD9 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Pred]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(S(SLLLL)LLLLLLLLLLLLLLLL),U(U(U(U(U,U),U,U,U,U),U,U,U,U),U,U,U,U,U,U,U,U,U,U,U,U,U,U,U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) eta1 :: Language.Haskell.TH.Syntax.Quasi m ->
                 Language.Haskell.TH.Lib.cxt2
                   (GHC.Types.[] @ Language.Haskell.TH.Lib.TypeQ)
                   @ m
                   eta1) -}
6c98f4ec3b78b69feb6b89a1398ad6be
  turnT :: Language.Haskell.TH.Syntax.VarStrictType
  {- Strictness: m,
     Unfolding: ((CodeGen.turnT4,
                  Language.Haskell.TH.Syntax.NotStrict,
                  CodeGen.turnT1)) -}
9ec3705b82306ecafd826d1dd9e8dc23
  turnT1 :: Language.Haskell.TH.Syntax.Type
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.ConT CodeGen.turnT2) -}
77d65799037296a5d428ecaf48b2d983
  turnT2 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT3
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
b3e239a3ac7059513fd74b80a3052a9e
  turnT3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Turn"#) -}
e83b5423f9c88e33c282250dceaf260f
  turnT4 :: Language.Haskell.TH.Syntax.Name
  {- Unfolding: (case GHC.List.reverse1
                        @ GHC.Types.Char
                        CodeGen.turnT5
                        (GHC.Types.[] @ GHC.Types.Char) of wild {
                   []
                   -> Language.Haskell.TH.Syntax.Name
                        (GHC.Types.[] @ GHC.Types.Char)
                          `cast`
                        (Sym (Language.Haskell.TH.Syntax.NTCo:OccName[0]))
                        Language.Haskell.TH.Syntax.NameS
                   : ds rev
                   -> case ds of wild1 { GHC.Types.C# ds1 ->
                      case ds1 of ds2 {
                        DEFAULT
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 }
                        '.'
                        -> case Language.Haskell.TH.Syntax.mkName_$s$wsplit1
                                  wild1
                                  (GHC.Types.[] @ GHC.Types.Char)
                                  rev of ww { (#,#) ww1 ww2 ->
                           Language.Haskell.TH.Syntax.Name ww1 ww2 } } } }) -}
b6326929bad2cae2311f2dd77399d256
  turnT5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn"#) -}
49fb8351e5acbd48b9d5a089e2036791
  turnTypeDec ::
    Language.Haskell.TH.Syntax.Q [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (0, True, True)
                CodeGen.turnTypeDec1
                  `cast`
                (Sym (Language.Haskell.TH.Syntax.NTCo:Q[0]
                          <[Language.Haskell.TH.Syntax.Dec]>_N)) -}
01220742f124a4d897f2b274b08cbb63
  turnTypeDec1 ::
    Language.Haskell.TH.Syntax.Quasi m =>
    m [Language.Haskell.TH.Syntax.Dec]
  {- Arity: 1,
     Strictness: <S(S(LLLC(S)L)LLLLLLLLLLLLLLLL),1*U(1*U(A,A,A,1*C1(U),A),A,A,A,A,A,A,A,A,A,A,A,A,A,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) $dQuasi :: Language.Haskell.TH.Syntax.Quasi m ->
                 GHC.Base.return
                   @ m
                   (Language.Haskell.TH.Syntax.$p1Quasi @ m $dQuasi)
                   @ [Language.Haskell.TH.Syntax.Dec]
                   CodeGen.turnTypeDec2) -}
7ee4e9f73be1ff7610a4e2e319e40b25
  turnTypeDec2 :: [Language.Haskell.TH.Syntax.Dec]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Language.Haskell.TH.Syntax.Dec
                   CodeGen.turnTypeDec3
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.Dec)) -}
4368fd0a3517a8e3767170308f22abbc
  turnTypeDec3 :: Language.Haskell.TH.Syntax.Dec
  {- Strictness: m5,
     Unfolding: (Language.Haskell.TH.Syntax.TySynD
                   CodeGen.turnT2
                   (GHC.Types.[] @ Language.Haskell.TH.Syntax.TyVarBndr)
                   CodeGen.gsDec16) -}
"SPEC/CodeGen lift @ Integer" [ALWAYS] forall tpl :: Language.Haskell.TH.Syntax.Lift
                                                       GHC.Integer.Type.Integer
  Language.Haskell.TH.Syntax.lift @ GHC.Integer.Type.Integer tpl
  = Language.Haskell.TH.Syntax.$fLiftInteger_$clift
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

