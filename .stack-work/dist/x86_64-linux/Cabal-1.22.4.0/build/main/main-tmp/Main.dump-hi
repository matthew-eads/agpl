
==================== FINAL INTERFACE ====================
2015-11-30 16:50:46.656316 UTC

interface main@main:Main 7102
  interface hash: 33d574c803e03d89e7971518547bb017
  ABI hash: a94c82801fc9b9ddcfb6679b0a44f1d3
  export-list hash: f21a8cbd052de609a4a31021dfd9db12
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b9fdbf528949e233f3a610c29cd057f2
  sig of: Nothing
  used TH splices: True
  where
exports:
  Main.boardInitF
  Main.elsec
  Main.fromString
  Main.getDiags
  Main.getMove
  Main.iToC
  Main.inBounds
  Main.inCol
  Main.inDiag
  Main.inRow
  Main.inRowColOrDiag
  Main.isEmpty
  Main.isFull
  Main.isValid
  Main.lfoldi
  Main.main
  Main.mfold
  Main.mtoc
  Main.otherPlayer
  Main.outcome
  Main.place
  Main.playGame
  Main.playerToPiece
  Main.possMoves
  Main.size
  Main.slot
  Main.tie
  Main.tiec
  Main.turn
  Main.winc
  Main.won
  Main.xor
  Main.Board
  Main.GameState{Main.GameState Main.Tie Main.Win Main.board Main.currentTurn}
  Main.Move{Main.Move}
  Main.Piece{Main.Nil Main.O Main.X}
  Main.Player{Main.PO Main.PX}
  Main.Turn
module dependencies: Agpl_syntax CodeGen Parser Quote
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      split-0.2.2@split_E4yadeCDng9EtdbI5MZoDg template-haskell-2.10.0.0
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.List 2a4f5f92892d432e7113f64cd9dcca53
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Real 4c3b525ecbd4d62bb287aec36d4c2f0d
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:System.Environment 946ddc2d7c48138bb213316abaff2a8d
import  -/  base-4.8.1.0:System.IO d541b8bdf18c04de3ab7ea0277c4eba3
import  -/  base-4.8.1.0:Text.Read 30509137a501bd56d136aca29a7a35a6
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Parser c256dec1b1bce98fa78aa6ea379d6d00
  exports: 27a1bcc305332993e3a8d79c4b37cae6
import  -/  Quote c60ccfcdab4d59a3c7a8d62afb797d38
  exports: d0ec02e763329704e7da15c6df5027d3
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
import  -/  split-0.2.2@split_E4yadeCDng9EtdbI5MZoDg:Data.List.Split 191d865ea862c301707cccb38cecb628
import  -/  vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector 1ab51bec0be594f8c3b5e22942541591
addDependentFile "connect4.agpl"
dd7ca107a80fdba094b44299e3c23a8b
  $fEqGameState :: GHC.Classes.Eq Main.GameState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.GameState Main.$fEqGameState_$c== Main.$fEqGameState_$c/= -}
dd7ca107a80fdba094b44299e3c23a8b
  $fEqGameState_$c/= ::
    Main.GameState -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Main.GameState b :: Main.GameState ->
                 case Main.$fEqGameState_$c== a1 b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
dd7ca107a80fdba094b44299e3c23a8b
  $fEqGameState_$c== ::
    Main.GameState -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Main.GameState ds1 :: Main.GameState ->
                 case ds of wild {
                   Main.GameState a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Main.GameState b1 b2
                        -> case Data.Matrix.$fEqMatrix_$c==
                                  @ Main.Piece
                                  Main.$fEqPiece
                                  a1
                                  b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> Main.$fEqGameState_$c==1 a2 b2 } }
                   Main.Win a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Main.Win b1 -> Main.$fEqGameState_$c==1 a1 b1 }
                   Main.Tie
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.Tie -> GHC.Types.True } }) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fEqGameState_$c==1 :: Main.Player -> Main.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Player ds1 :: Main.Player ->
                 case ds of wild {
                   Main.PX
                   -> case ds1 of wild1 {
                        Main.PX -> GHC.Types.True Main.PO -> GHC.Types.False }
                   Main.PO
                   -> case ds1 of wild1 {
                        Main.PX -> GHC.Types.False Main.PO -> GHC.Types.True } }) -}
cea12406c446a8c9734c09bfc96bd92d
  $fEqMove :: GHC.Classes.Eq Main.Move
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Move Main.$fEqMove_$c== Main.$fEqMove_$c/= -}
cea12406c446a8c9734c09bfc96bd92d
  $fEqMove_$c/= :: Main.Move -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Main.Move b :: Main.Move ->
                 case a1 of wild { Main.Move a2 ->
                 case b of wild1 { Main.Move b1 ->
                 case a2 of wild2 { GHC.Types.I# x ->
                 case b1 of wild3 { GHC.Types.I# y ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# x y) of wild4 {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False } } } } }) -}
cea12406c446a8c9734c09bfc96bd92d
  $fEqMove_$c== :: Main.Move -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S),1*U(1*U(U))><S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Move ds1 :: Main.Move ->
                 case ds of wild { Main.Move a1 ->
                 case ds1 of wild1 { Main.Move b1 -> GHC.Classes.eqInt a1 b1 } }) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fEqPiece :: GHC.Classes.Eq Main.Piece
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Piece Main.$fEqPiece_$c== Main.$fEqPiece_$c/= -}
19f3c95061e42d4fe282f6073e8bb52d
  $fEqPiece_$c/= :: Main.Piece -> Main.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Main.Piece b :: Main.Piece ->
                 case a1 of wild {
                   Main.X
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.X -> GHC.Types.False }
                   Main.O
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.O -> GHC.Types.False }
                   Main.Nil
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.Nil -> GHC.Types.False } }) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fEqPiece_$c== :: Main.Piece -> Main.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Piece ds1 :: Main.Piece ->
                 case ds of wild {
                   Main.X
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.X -> GHC.Types.True }
                   Main.O
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.O -> GHC.Types.True }
                   Main.Nil
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.Nil -> GHC.Types.True } }) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fEqPlayer :: GHC.Classes.Eq Main.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Player Main.$fEqGameState_$c==1 Main.$fEqPlayer_$c/= -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fEqPlayer_$c/= :: Main.Player -> Main.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a1 :: Main.Player b :: Main.Player ->
                 case a1 of wild {
                   Main.PX
                   -> case b of wild1 {
                        Main.PX -> GHC.Types.False Main.PO -> GHC.Types.True }
                   Main.PO
                   -> case b of wild1 {
                        Main.PX -> GHC.Types.True Main.PO -> GHC.Types.False } }) -}
dd7ca107a80fdba094b44299e3c23a8b
  $fShowGameState :: GHC.Show.Show Main.GameState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.GameState
                  Main.$fShowGameState_$cshowsPrec
                  Main.$fShowGameState_$cshow
                  Main.$fShowGameState_$cshowList -}
dd7ca107a80fdba094b44299e3c23a8b
  $fShowGameState1 :: Main.GameState -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Main.$fShowGameState_$cshowsPrec
                   Main.$fShowGameState2) -}
2f7fd8a64a161a3f80dc89cf8fae2228
  $fShowGameState10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board = "#) -}
03d91f6c802d6ddf4f7c9c9348055912
  $fShowGameState11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState {"#) -}
9100f46b94ddc4f98d932ba07b8d55a9
  $fShowGameState2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
4a7fc083d3ad176e014f605fdd818ca9
  $fShowGameState3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
e45899e5de3288d3d65113ea57245022
  $fShowGameState4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win "#) -}
8d26bbe0427209bcbecab2792533a343
  $fShowGameState5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PO"#) -}
588538aa0c44ac4647ea2cd051be59f0
  $fShowGameState6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
6c7f2b9b27951a307ba82bdf9cd9afcf
  $fShowGameState7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PX"#) -}
9ad7745e11e29fc2feaeed0aeb673b56
  $fShowGameState8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn = "#) -}
13e921472717c5e1805fe8ebd7af6d71
  $fShowGameState9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
dd7ca107a80fdba094b44299e3c23a8b
  $fShowGameState_$cshow :: Main.GameState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.GameState ->
                 Main.$fShowGameState_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
dd7ca107a80fdba094b44299e3c23a8b
  $fShowGameState_$cshowList :: [Main.GameState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.GameState
                   Main.$fShowGameState1) -}
dd7ca107a80fdba094b44299e3c23a8b
  $fShowGameState_$cshowsPrec ::
    GHC.Types.Int -> Main.GameState -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a1 :: GHC.Types.Int
                   ds :: Main.GameState
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   Main.GameState b1 b2
                   -> case a1 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowGameState11
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Main.$fShowGameState10
                               (case b1 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (Data.Matrix.$wprettyMatrix
                                     @ Main.Piece
                                     Main.$fShowPiece
                                     ww1
                                     ww2
                                     ww3
                                     ww4
                                     ww5
                                     ww6)
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Main.$fShowGameState9
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        Main.$fShowGameState8
                                        (case b2 of wild2 {
                                           Main.PX
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Main.$fShowGameState7
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Main.$fShowGameState6
                                                   x1)
                                           Main.PO
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Main.$fShowGameState5
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Main.$fShowGameState6
                                                   x1) }))) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   Main.Win b1
                   -> case a1 of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowGameState4
                            (case b1 of wild2 {
                               Main.PX -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState7 x1
                               Main.PO -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState5 x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   Main.Tie
                   -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState3 eta }) -}
cea12406c446a8c9734c09bfc96bd92d
  $fShowMove :: GHC.Show.Show Main.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Move
                  Main.$fShowMove_$cshowsPrec
                  Main.$fShowMove_$cshow
                  Main.$fShowMove_$cshowList -}
cea12406c446a8c9734c09bfc96bd92d
  $fShowMove1 :: Main.Move -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Main.Move w1 :: GHC.Base.String ->
                 case w of ww { Main.Move ww1 -> Main.$w$cshowsPrec1 0 ww1 w1 }) -}
1d8214de8b8a42b6dac5b7abe1200838
  $fShowMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Move "#) -}
cea12406c446a8c9734c09bfc96bd92d
  $fShowMove_$cshow :: Main.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Move ->
                 Main.$fShowMove_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
cea12406c446a8c9734c09bfc96bd92d
  $fShowMove_$cshowList :: [Main.Move] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Main.Move Main.$fShowMove1) -}
cea12406c446a8c9734c09bfc96bd92d
  $fShowMove_$cshowsPrec ::
    GHC.Types.Int -> Main.Move -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(U))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.Move w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Main.Move ww3 ->
                 Main.$w$cshowsPrec1 ww1 ww3 w2 } }) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fShowPiece :: GHC.Show.Show Main.Piece
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Piece
                  Main.$fShowPiece_$cshowsPrec
                  Main.$fShowPiece_$cshow
                  Main.$fShowPiece_$cshowList -}
40f672ac49626e88fc4028d456035e60
  $fShowPiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nil"#) -}
0d1c6d496fa5dd73c571ac00bbf9e8b3
  $fShowPiece2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
aba7b090a3cdc9215c7b6362ac273280
  $fShowPiece3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "X"#) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fShowPiece_$cshow :: Main.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Piece ->
                 case x of wild {
                   Main.X -> Main.$fShowPiece3
                   Main.O -> Main.$fShowPiece2
                   Main.Nil -> Main.$fShowPiece1 }) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fShowPiece_$cshowList :: [Main.Piece] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Main.Piece Main.$w$cshowsPrec) -}
19f3c95061e42d4fe282f6073e8bb52d
  $fShowPiece_$cshowsPrec ::
    GHC.Types.Int -> Main.Piece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w :: GHC.Types.Int w1 :: Main.Piece w2 :: GHC.Base.String ->
                 Main.$w$cshowsPrec w1 w2) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fShowPlayer :: GHC.Show.Show Main.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Player
                  Main.$fShowPlayer_$cshowsPrec
                  Main.$fShowPlayer_$cshow
                  Main.$fShowPlayer_$cshowList -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fShowPlayer1 :: Main.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Player eta :: GHC.Base.String ->
                 case ds of wild {
                   Main.PX
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowGameState7)
                        eta
                   Main.PO
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowGameState5)
                        eta }) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fShowPlayer_$cshow :: Main.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Player ->
                 case x of wild {
                   Main.PX -> Main.$fShowGameState7
                   Main.PO -> Main.$fShowGameState5 }) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fShowPlayer_$cshowList :: [Main.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.Player
                   Main.$fShowPlayer1) -}
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> Main.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int ds1 :: Main.Player eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Main.PX
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowGameState7)
                        eta
                   Main.PO
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n Main.$fShowGameState5)
                        eta }) -}
19f3c95061e42d4fe282f6073e8bb52d
  $w$cshowsPrec :: Main.Piece -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w :: Main.Piece w1 :: GHC.Base.String ->
                 case w of wild {
                   Main.X -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece3 w1
                   Main.O -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece2 w1
                   Main.Nil -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece1 w1 }) -}
162191852e661df71c7bff3cc48206ea
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> GHC.Types.Int -> GHC.Base.String -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U(U)><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   w :: GHC.Base.String ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Main.$fShowMove2
                        (case ww1 of ww2 { GHC.Types.I# ww3 ->
                         case GHC.Show.$wshowSignedInt 11 ww3 w of ww4 { (#,#) ww5 ww6 ->
                         GHC.Types.: @ GHC.Types.Char ww5 ww6 } })
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Main.$fShowMove2
                           (case ww1 of ww2 { GHC.Types.I# ww3 ->
                            case GHC.Show.$wshowSignedInt
                                   11
                                   ww3
                                   (GHC.Types.:
                                      @ GHC.Types.Char
                                      GHC.Show.shows8
                                      w) of ww4 { (#,#) ww5 ww6 ->
                            GHC.Types.: @ GHC.Types.Char ww5 ww6 } })) }) -}
e1c6c5554a2c9ea7c4693d77bc5d9b7d
  $wgetDiags ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector t
    -> [[t]]
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0] -}
dd747367e6412919ffbc971621c8896b
  $wiToC ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,U><L,U><L,U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   w :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.># ww1 ww) of wild {
                   GHC.Types.False
                   -> let {
                        c :: GHC.Types.Int
                        = case ww1 of wild1 {
                            DEFAULT
                            -> case w of wild2 { GHC.Types.I# x ->
                               case GHC.Classes.modInt# x wild1 of ww2 {
                                 DEFAULT -> GHC.Types.I# ww2 0 -> GHC.Types.I# wild1 } }
                            (-1) -> Main.iToC2
                            0 -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} }
                      } in
                      (# case w of wild1 { GHC.Types.I# x ->
                         case c of wild2 { GHC.Types.I# y ->
                         case GHC.Prim./##
                                (GHC.Prim.int2Double# (GHC.Prim.-# x y))
                                (GHC.Prim.int2Double# ww1) of wild3 { DEFAULT ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.double2Int# wild3
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# n) wild3) of wild4 {
                           GHC.Types.False
                           -> case n of wild5 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild5 1) 0 -> Main.iToC1 }
                           GHC.Types.True
                           -> case GHC.Prim.+# n 1 of wild5 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild5 1)
                                0 -> Main.iToC1 } } } } },
                         c #)
                   GHC.Types.True
                   -> let {
                        c :: GHC.Types.Int
                        = case ww1 of wild1 {
                            DEFAULT
                            -> case w of wild2 { GHC.Types.I# x ->
                               case GHC.Classes.modInt# x wild1 of ww2 {
                                 DEFAULT -> GHC.Types.I# ww2 0 -> GHC.Types.I# wild1 } }
                            (-1) -> Main.iToC2
                            0 -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} }
                      } in
                      (# case w of wild1 { GHC.Types.I# x ->
                         case c of wild2 { GHC.Types.I# y ->
                         case GHC.Prim./##
                                (GHC.Prim.int2Double# (GHC.Prim.-# x y))
                                (GHC.Prim.int2Double# ww1) of wild3 { DEFAULT ->
                         let {
                           n :: GHC.Prim.Int# = GHC.Prim.double2Int# wild3
                         } in
                         case GHC.Prim.tagToEnum#
                                @ GHC.Types.Bool
                                (GHC.Prim.<## (GHC.Prim.int2Double# n) wild3) of wild4 {
                           GHC.Types.False
                           -> case n of wild5 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild5 1) 0 -> Main.iToC1 }
                           GHC.Types.True
                           -> case GHC.Prim.+# n 1 of wild5 {
                                DEFAULT -> GHC.Types.I# (GHC.Prim.+# wild5 1)
                                0 -> Main.iToC1 } } } } },
                         c #) }) -}
312ea6d954ede5c59e97edb441ee1d65
  $winBounds ::
    (GHC.Num.Num a, GHC.Num.Num a1, GHC.Classes.Ord a,
     GHC.Classes.Ord a1) =>
    a -> a1 -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a1
                   @ a2
                   w :: GHC.Num.Num a1
                   w1 :: GHC.Num.Num a2
                   w2 :: GHC.Classes.Ord a1
                   w3 :: GHC.Classes.Ord a2
                   ww :: a1
                   ww1 :: a2 ->
                 case GHC.Classes.<=
                        @ a1
                        w2
                        ww
                        (GHC.Num.fromInteger @ a1 w Main.inBounds3) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.>
                             @ a1
                             w2
                             ww
                             (GHC.Num.fromInteger @ a1 w Main.inBounds2) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.<=
                                  @ a2
                                  w3
                                  ww1
                                  (GHC.Num.fromInteger @ a2 w1 Main.inBounds1) of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.>
                                  @ a2
                                  w3
                                  ww1
                                  (GHC.Num.fromInteger @ a2 w1 Main.inBounds2) } } }) -}
edcb7652f880121f2e1d2dd7cee95a45
  $winCol ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   w1 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 case Data.Matrix.$wtranspose
                        @ Main.Piece
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5 of ww7 { (#,,,,,#) ww8 ww9 ww10 ww11 ww12 ww13 ->
                 letrec {
                   $wgo :: [Main.Piece] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w2 :: [Main.Piece] ww6 :: GHC.Prim.Int# ->
                     case w2 of wild {
                       [] -> ww6
                       : y ys
                       -> case w of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# ww6 y1) of wild2 {
                            GHC.Types.False
                            -> case y of wild3 {
                                 Main.X
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys (GHC.Prim.+# ww6 1) Main.PO -> $wgo ys 0 }
                                 Main.O
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys 0 Main.PO -> $wgo ys (GHC.Prim.+# ww6 1) }
                                 Main.Nil -> case w1 of wild4 { DEFAULT -> $wgo ys 0 } }
                            GHC.Types.True -> $wgo ys ww6 } } }
                 } in
                 letrec {
                   go :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case $wgo y 0 of ww6 { DEFAULT ->
                             case w of wild1 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 y1) of wild2 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go
                   (Data.Matrix.$wtoLists @ Main.Piece ww8 ww9 ww10 ww11 ww12 ww13)
                   GHC.Types.False }) -}
50efc955a60c4659bc920f8eea3e2510
  $winDiag ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   w1 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 letrec {
                   $wgo :: [Main.Piece] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w2 :: [Main.Piece] ww6 :: GHC.Prim.Int# ->
                     case w2 of wild {
                       [] -> ww6
                       : y ys
                       -> case w of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# ww6 y1) of wild2 {
                            GHC.Types.False
                            -> case y of wild3 {
                                 Main.X
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys (GHC.Prim.+# ww6 1) Main.PO -> $wgo ys 0 }
                                 Main.O
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys 0 Main.PO -> $wgo ys (GHC.Prim.+# ww6 1) }
                                 Main.Nil -> case w1 of wild4 { DEFAULT -> $wgo ys 0 } }
                            GHC.Types.True -> $wgo ys ww6 } } }
                 } in
                 letrec {
                   go :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case $wgo y 0 of ww6 { DEFAULT ->
                             case w of wild1 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 y1) of wild2 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go
                   (Main.$wgetDiags @ Main.Piece ww ww1 ww2 ww3 ww4 ww5)
                   GHC.Types.False) -}
c7cfa74ac2074b60994a624fe0a565f1
  $winRow ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   w1 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 letrec {
                   $wgo :: [Main.Piece] -> GHC.Prim.Int# -> GHC.Prim.Int#
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ w2 :: [Main.Piece] ww6 :: GHC.Prim.Int# ->
                     case w2 of wild {
                       [] -> ww6
                       : y ys
                       -> case w of wild1 { GHC.Types.I# y1 ->
                          case GHC.Prim.tagToEnum#
                                 @ GHC.Types.Bool
                                 (GHC.Prim.==# ww6 y1) of wild2 {
                            GHC.Types.False
                            -> case y of wild3 {
                                 Main.X
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys (GHC.Prim.+# ww6 1) Main.PO -> $wgo ys 0 }
                                 Main.O
                                 -> case w1 of wild4 {
                                      Main.PX -> $wgo ys 0 Main.PO -> $wgo ys (GHC.Prim.+# ww6 1) }
                                 Main.Nil -> case w1 of wild4 { DEFAULT -> $wgo ys 0 } }
                            GHC.Types.True -> $wgo ys ww6 } } }
                 } in
                 letrec {
                   go :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case $wgo y 0 of ww6 { DEFAULT ->
                             case w of wild1 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# ww6 y1) of wild2 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go
                   (Data.Matrix.$wtoLists @ Main.Piece ww ww1 ww2 ww3 ww4 ww5)
                   GHC.Types.False) -}
24c18917bd9181549b08d0af736da114
  $winRowColOrDiag ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   w1 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 case Main.$winDiag w w1 ww ww1 ww2 ww3 ww4 ww5 of wild {
                   GHC.Types.False
                   -> case Main.$winCol w w1 ww ww1 ww2 ww3 ww4 ww5 of wild1 {
                        GHC.Types.False -> Main.$winRow w w1 ww ww1 ww2 ww3 ww4 ww5
                        GHC.Types.True -> GHC.Types.True }
                   GHC.Types.True -> GHC.Types.True }) -}
56e840a26c5a0d8a960b525a1b4f40cd
  $wisEmpty ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> Main.GameState -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   w :: Main.GameState ->
                 case w of wild {
                   DEFAULT -> case Main.board1 ret_ty GHC.Types.Bool of {}
                   Main.GameState ds ds1
                   -> case ds of ww2 { Data.Matrix.M ww3 ww4 ww5 ww6 ww7 ww8 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww ww3) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># ww1 ww4) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# ww 1) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# ww1 1) of wild4 {
                                       GHC.Types.False
                                       -> case ww8 of wild5 { Data.Vector.Vector dt dt1 dt2 ->
                                          case GHC.Prim.indexArray#
                                                 @ Main.Piece
                                                 dt2
                                                 (GHC.Prim.+#
                                                    dt
                                                    (GHC.Prim.-#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.*#
                                                             (GHC.Prim.-# (GHC.Prim.+# ww ww5) 1)
                                                             ww7)
                                                          (GHC.Prim.+# ww1 ww6))
                                                       1)) of ds2 { (##) ipv ->
                                          case ipv of wild8 {
                                            DEFAULT -> GHC.Types.False
                                            Main.Nil -> GHC.Types.True } } }
                                       GHC.Types.True
                                       -> case Main.isEmpty1 ww3 ww4 ww ww1
                                          ret_ty GHC.Types.Bool
                                          of {} }
                                  GHC.Types.True
                                  -> case Main.isEmpty1 ww3 ww4 ww ww1 ret_ty GHC.Types.Bool of {} }
                             GHC.Types.True
                             -> case Main.isEmpty1 ww3 ww4 ww ww1 ret_ty GHC.Types.Bool of {} }
                        GHC.Types.True
                        -> case Main.isEmpty1 ww3 ww4 ww ww1
                           ret_ty GHC.Types.Bool
                           of {} } } }) -}
effd23906b20d34160cb22ed47a7fd8e
  $wisValid :: Main.GameState -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0],
     Unfolding: (\ w :: Main.GameState ww :: GHC.Prim.Int# ->
                 case w of wild {
                   DEFAULT -> case Main.board1 ret_ty GHC.Types.Bool of {}
                   Main.GameState ds ds1
                   -> case ds of ww1 { Data.Matrix.M ww2 ww3 ww4 ww5 ww6 ww7 ->
                      case ww7 of ww8 { Data.Vector.Vector ww9 ww10 ww11 ->
                      case Main.$wslot
                             ww3
                             ww4
                             ww5
                             ww6
                             ww9
                             ww10
                             ww11
                             ww of ww12 { (,) ww13 ww14 ->
                      case ww13 of wild1 { GHC.Types.I# x ->
                      case x of wild2 {
                        DEFAULT -> GHC.Types.True
                        (-1)
                        -> case ww14 of wild3 { GHC.Types.I# x1 ->
                           case x1 of wild4 {
                             DEFAULT -> GHC.Types.True
                             (-1) -> GHC.Types.False } } } } } } } }) -}
7b9035bd31486b7833b07126b2c2c8a6
  $wmfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector a
    -> b
  {- Arity: 8,
     Strictness: <L,C(U)><L,1*U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ @ a1
                   @ b
                   w :: ((GHC.Types.Int, GHC.Types.Int), a1, b) -> b
                   w1 :: b
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector a1 ->
                 let {
                   l :: [a1] = Data.Matrix.$wtoList @ a1 ww ww1 ww2 ww3 ww4 ww5
                 } in
                 Main.lfoldi
                   @ a1
                   @ b
                   (\ w2 :: GHC.Types.Int ->
                    case Main.$wiToC ww ww1 w2 of ww6 { (#,#) ww7 ww8 -> (ww7, ww8) })
                   (case GHC.List.$wlenAcc @ a1 l 0 of ww6 { DEFAULT ->
                    GHC.Types.I# ww6 })
                   w
                   w1
                   l) -}
11955830b1d19303db17028aac5cecf3
  $woutcome ::
    GHC.Num.Num t =>
    Main.GameState -> Main.Move -> (# Main.GameState, t #)
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S,U><L,1*U(1*U(U))>,
     Inline: [0],
     Unfolding: (\ @ t
                   w :: GHC.Num.Num t
                   w1 :: Main.GameState
                   w2 :: Main.Move ->
                 case Main.winc w1 of wild {
                   GHC.Types.False
                   -> case w1 of wild1 {
                        DEFAULT -> case Main.board1 ret_ty (# Main.GameState, t #) of {}
                        Main.GameState ds ds1
                        -> case ds of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                           case Main.$wmfold
                                  @ Main.Piece
                                  @ GHC.Types.Bool
                                  Main.isFull1
                                  GHC.Types.True
                                  ww1
                                  ww2
                                  ww3
                                  ww4
                                  ww5
                                  ww6 of wild2 {
                             GHC.Types.False
                             -> let {
                                  g :: Main.GameState = Main.elsec wild1 w2
                                } in
                                case Main.winc g of wild3 {
                                  GHC.Types.False
                                  -> case g of wild4 {
                                       DEFAULT
                                       -> case Main.board1 ret_ty (# Main.GameState, t #) of {}
                                       Main.GameState ds2 ds3
                                       -> case ds2 of ww7 { Data.Matrix.M ww8 ww9 ww10 ww11 ww12 ww13 ->
                                          case Main.$wmfold
                                                 @ Main.Piece
                                                 @ GHC.Types.Bool
                                                 Main.isFull1
                                                 GHC.Types.True
                                                 ww8
                                                 ww9
                                                 ww10
                                                 ww11
                                                 ww12
                                                 ww13 of wild5 {
                                            GHC.Types.False
                                            -> (# wild4, GHC.Num.fromInteger @ t w Main.outcome1 #)
                                            GHC.Types.True
                                            -> (# Main.Tie,
                                                  GHC.Num.fromInteger @ t w Main.outcome1 #) } } }
                                  GHC.Types.True
                                  -> (# Main.Win ds1, GHC.Num.fromInteger @ t w Main.outcome1 #) }
                             GHC.Types.True
                             -> (# Main.Tie, GHC.Num.fromInteger @ t w Main.outcome1 #) } } }
                   GHC.Types.True
                   -> (# Main.Win
                           (case w1 of wild1 {
                              DEFAULT -> Main.currentTurn1 Main.GameState ds ds1 -> ds1 }),
                         GHC.Num.fromInteger @ t w Main.outcome1 #) }) -}
633c15d9aa5717c1250ec870252545b1
  $wplace ::
    Main.GameState
    -> Main.Piece
    -> (GHC.Types.Int, GHC.Types.Int)
    -> (# Main.Board, Main.Turn #)
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(1*U(U),1*U(U))>,
     Inline: [0],
     Unfolding: (\ w :: Main.GameState
                   w1 :: Main.Piece
                   w2 :: (GHC.Types.Int, GHC.Types.Int) ->
                 (# case w of wild {
                      DEFAULT -> Main.board1
                      Main.GameState ds ds1
                      -> case ds of wild1 { Data.Matrix.M dt dt1 dt2 dt3 dt4 v ->
                         Data.Matrix.M
                           @ Main.Piece
                           dt
                           dt1
                           dt2
                           dt3
                           dt4
                           (case v of v1 { Data.Vector.Vector ipv ipv1 ipv2 ->
                            GHC.ST.runSTRep
                              @ (Data.Vector.Vector Main.Piece)
                              (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.>=# ipv1 0) of wild2 {
                                 GHC.Types.False
                                 -> case Main.elsec2 @ s ipv1
                                    ret_ty (# GHC.Prim.State# s, Data.Vector.Vector Main.Piece #)
                                    of {}
                                 GHC.Types.True
                                 -> case GHC.Prim.newArray#
                                           @ Main.Piece
                                           @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                           ipv1
                                           (Data.Vector.Mutable.uninitialised @ Main.Piece)
                                           s1
                                             `cast`
                                           (GHC.Prim.State#
                                              (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                        <s>_N)))_R of ds2 { (#,#) ipv3 ipv4 ->
                                    case GHC.Prim.copyArray#
                                           @ Main.Piece
                                           @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                           ipv2
                                           ipv
                                           ipv4
                                           0
                                           ipv1
                                           ipv3 of s'# { DEFAULT ->
                                    case w2 of wild3 { (,) i j ->
                                    case i of wild4 { GHC.Types.I# x ->
                                    case j of wild5 { GHC.Types.I# x1 ->
                                    let {
                                      x2 :: GHC.Prim.Int#
                                      = GHC.Prim.-#
                                          (GHC.Prim.+#
                                             (GHC.Prim.*# (GHC.Prim.-# (GHC.Prim.+# x dt2) 1) dt4)
                                             (GHC.Prim.+# x1 dt3))
                                          1
                                    } in
                                    case GHC.Prim.tagToEnum#
                                           @ GHC.Types.Bool
                                           (GHC.Prim.>=# x2 0) of wild6 {
                                      GHC.Types.False
                                      -> case Main.elsec1 @ s x2 ipv1
                                         ret_ty (# GHC.Prim.State# s,
                                                   Data.Vector.Vector Main.Piece #)
                                         of {}
                                      GHC.Types.True
                                      -> case GHC.Prim.tagToEnum#
                                                @ GHC.Types.Bool
                                                (GHC.Prim.<# x2 ipv1) of wild7 {
                                           GHC.Types.False
                                           -> case Main.elsec1 @ s x2 ipv1
                                              ret_ty (# GHC.Prim.State# s,
                                                        Data.Vector.Vector Main.Piece #)
                                              of {}
                                           GHC.Types.True
                                           -> case GHC.Prim.writeArray#
                                                     @ (Control.Monad.Primitive.PrimState
                                                          (GHC.ST.ST s))
                                                     @ Main.Piece
                                                     ipv4
                                                     x2
                                                     w1
                                                     s'# of s'#1 { DEFAULT ->
                                              case GHC.Prim.unsafeFreezeArray#
                                                     @ (Control.Monad.Primitive.PrimState
                                                          (GHC.ST.ST s))
                                                     @ Main.Piece
                                                     ipv4
                                                     s'#1 of ds3 { (#,#) ipv5 ipv6 ->
                                              (# ipv5
                                                   `cast`
                                                 (GHC.Prim.State#
                                                    (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                         <s>_N))_R,
                                                 Data.Vector.Vector
                                                   @ Main.Piece
                                                   0
                                                   ipv1
                                                   ipv6 #) } } } } } } } } } }) }) } },
                    case w of wild {
                      DEFAULT -> Main.currentTurn1
                      Main.GameState ds ds1
                      -> case ds1 of wild1 {
                           Main.PX -> Main.PO Main.PO -> Main.PX } } #)) -}
ed160d04e731b3b0d86439411bf4f8f9
  $wslot ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Array# Main.Piece
    -> GHC.Prim.Int#
    -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 8, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U><L,U><L,U>,
     Inline: [0] -}
c3579c38a22d395657c1e7ac54182983
  type Board = Data.Matrix.Matrix Main.Piece
dd7ca107a80fdba094b44299e3c23a8b
  data GameState
    = GameState {board :: Main.Board, currentTurn :: Main.Turn}
    | Win Main.Player
    | Tie
cea12406c446a8c9734c09bfc96bd92d
  data Move = Move GHC.Types.Int
19f3c95061e42d4fe282f6073e8bb52d
  data Piece = X | O | Nil
    Promotable
61750bcb6cd4eaa7caa5acf9bf6a2c4f
  data Player = PX | PO
    Promotable
03ac1ba4c53deb8dcd8ffd2a16f197d3
  type Turn = Main.Player
82f050f8761c2bf002c1e5a43b7c798b
  board :: Main.GameState -> Main.Board
  RecSel Main.GameState
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.GameState ->
                 case ds of wild {
                   DEFAULT -> Main.board1 Main.GameState ds1 ds2 -> ds1 }) -}
6ac1667d187113ca16bc2fbed54b4c71
  board1 :: Main.Board
  {- Strictness: b -}
4aa8550e34961b0a6e79a589be58ad8e
  boardInitF :: Data.Matrix.Matrix Main.Piece
  {- Strictness: m,
     Unfolding: (Data.Matrix.M
                   @ Main.Piece
                   7
                   6
                   0
                   0
                   6
                   Main.boardInitF1) -}
9de348d471053c7f0f3d9152fba8bf8f
  boardInitF1 :: Data.Vector.Vector Main.Piece
  {- Unfolding: (GHC.ST.runSTRep
                   @ (Data.Vector.Vector Main.Piece)
                   Main.boardInitF2) -}
612a515fb7d69ef3a6a08099f1c469bf
  boardInitF2 ::
    GHC.Prim.State# s
    -> (# GHC.Prim.State# s, Data.Vector.Vector Main.Piece #)
  {- Arity: 1,
     Unfolding: (\ @ s s1 :: GHC.Prim.State# s[OneShot] ->
                 case GHC.Prim.newArray#
                        @ Main.Piece
                        @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                        42
                        (Data.Vector.Mutable.uninitialised @ Main.Piece)
                        s1
                          `cast`
                        (GHC.Prim.State#
                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                     <s>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                 letrec {
                   $wa1 :: GHC.Prim.Int#
                           -> GHC.Prim.State# s -> (# GHC.Prim.State# s, () #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ ww :: GHC.Prim.Int# w :: GHC.Prim.State# s[OneShot] ->
                     case ww of wild {
                       DEFAULT
                       -> case GHC.Prim.writeArray#
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 @ Main.Piece
                                 ipv1
                                 (GHC.Prim.-# (GHC.Prim.+# 36 wild) 1)
                                 Main.Nil
                                 w `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of s'# { DEFAULT ->
                          $wa1
                            (GHC.Prim.+# wild 1)
                            s'#
                              `cast`
                            (GHC.Prim.State#
                               (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R }
                       6
                       -> case GHC.Prim.writeArray#
                                 @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                 @ Main.Piece
                                 ipv1
                                 41
                                 Main.Nil
                                 w `cast`
                                 (GHC.Prim.State#
                                    (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                              <s>_N)))_R of s'# { DEFAULT ->
                          (# s'#, GHC.Tuple.() #)
                            `cast`
                          ((# (GHC.Prim.State#
                                 (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                              <()>_R #))_R } }
                 } in
                 letrec {
                   $wa2 :: GHC.Prim.Int#
                           -> GHC.Prim.State# s -> (# GHC.Prim.State# s, () #)
                     {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                   = \ ww :: GHC.Prim.Int# w :: GHC.Prim.State# s[OneShot] ->
                     case ww of wild {
                       DEFAULT
                       -> letrec {
                            $wa3 :: GHC.Prim.Int#
                                    -> GHC.Prim.State# s -> (# GHC.Prim.State# s, () #)
                              {- Arity: 2, Strictness: <S,1*U><L,U>, Inline: [0] -}
                            = \ ww1 :: GHC.Prim.Int# w1 :: GHC.Prim.State# s[OneShot] ->
                              case ww1 of wild1 {
                                DEFAULT
                                -> case GHC.Prim.writeArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          @ Main.Piece
                                          ipv1
                                          (GHC.Prim.-#
                                             (GHC.Prim.+#
                                                (GHC.Prim.*# (GHC.Prim.-# wild 1) 6)
                                                wild1)
                                             1)
                                          Main.Nil
                                          w1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                       <s>_N)))_R of s'# { DEFAULT ->
                                   $wa3
                                     (GHC.Prim.+# wild1 1)
                                     s'#
                                       `cast`
                                     (GHC.Prim.State#
                                        (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R }
                                6
                                -> case GHC.Prim.writeArray#
                                          @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                                          @ Main.Piece
                                          ipv1
                                          (GHC.Prim.-#
                                             (GHC.Prim.+# (GHC.Prim.*# (GHC.Prim.-# wild 1) 6) 6)
                                             1)
                                          Main.Nil
                                          w1
                                            `cast`
                                          (GHC.Prim.State#
                                             (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                       <s>_N)))_R of s'# { DEFAULT ->
                                   (# s'#, GHC.Tuple.() #)
                                     `cast`
                                   ((# (GHC.Prim.State#
                                          (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                                       <()>_R #))_R } }
                          } in
                          case $wa3 1 w of ds { (#,#) ipv2 ipv3 ->
                          $wa2 (GHC.Prim.+# wild 1) ipv2 }
                       7 -> $wa1 1 w }
                 } in
                 case $wa2
                        1
                        ipv
                          `cast`
                        (GHC.Prim.State#
                           (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                <s>_N))_R of ds { (#,#) ipv2 ipv3 ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
                        @ Main.Piece
                        ipv1
                        ipv2
                          `cast`
                        (GHC.Prim.State#
                           (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                     <s>_N)))_R of ds2 { (#,#) ipv4 ipv5 ->
                 (# ipv4
                      `cast`
                    (GHC.Prim.State#
                       (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s>_N))_R,
                    Data.Vector.Vector @ Main.Piece 0 42 ipv5 #) } } }) -}
b810880ae4bac141f34fdc49d684786e
  currentTurn :: Main.GameState -> Main.Turn
  RecSel Main.GameState
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.GameState ->
                 case ds of wild {
                   DEFAULT -> Main.currentTurn1 Main.GameState ds1 ds2 -> ds2 }) -}
94d90a9ecf1940875773e8427d3f2ffe
  currentTurn1 :: Main.Turn
  {- Strictness: b -}
387afd1e083a1e2ff847c05ca1c37cf0
  elsec :: Main.GameState -> Main.Move -> Main.GameState
  {- Arity: 2, Strictness: <L,U><L,1*U(1*U(U))>,
     Unfolding: (\ game :: Main.GameState move :: Main.Move ->
                 Debug.Trace.trace
                   @ Main.GameState
                   Main.elsec3
                   (case Main.$wplace
                           game
                           (case game of wild {
                              DEFAULT -> case Main.currentTurn1 ret_ty Main.Piece of {}
                              Main.GameState ds ds1
                              -> case ds1 of wild1 { Main.PX -> Main.X Main.PO -> Main.O } })
                           (case game of wild {
                              DEFAULT
                              -> case Main.board1 ret_ty (GHC.Types.Int, GHC.Types.Int) of {}
                              Main.GameState ds ds1
                              -> case ds of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                                 case ww6 of ww7 { Data.Vector.Vector ww8 ww9 ww10 ->
                                 case move of wild1 { Main.Move c ->
                                 case c of ww11 { GHC.Types.I# ww12 ->
                                 Main.$wslot
                                   ww2
                                   ww3
                                   ww4
                                   ww5
                                   ww8
                                   ww9
                                   ww10
                                   ww12 } } } } }) of ww { (#,#) ww1 ww2 ->
                    Main.GameState ww1 ww2 })) -}
660c6a9b1afaf9cbca219ee2e70dc458
  elsec1 :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.ST.ST s ()
  {- Arity: 2, Strictness: <L,U><L,U>b -}
7f1983be48ee4d73ef9758ca3d977f0f
  elsec2 ::
    GHC.Prim.Int#
    -> GHC.ST.ST
         s
         (Data.Vector.Generic.Base.Mutable
            Data.Vector.Vector
            (Control.Monad.Primitive.PrimState (GHC.ST.ST s))
            Main.Piece)
  {- Arity: 1, Strictness: <L,U>b -}
60c2bab4344a063ae5464ee6f98c9c5c
  elsec3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "placing"#) -}
c2f28bc660a44612b3b8640f9bdc1740
  fromString :: GHC.Base.String -> Main.Move
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w :: GHC.Base.String ->
                 Main.Move
                   (case Text.Read.readEither6
                           @ GHC.Types.Int
                           (Text.ParserCombinators.ReadP.run
                              @ GHC.Types.Int
                              Main.fromString3
                              w) of wild {
                      [] -> Main.fromString2
                      : x ds
                      -> case ds of wild1 {
                           [] -> x : ipv ipv1 -> Main.fromString1 } })) -}
51abc93480be710bf6d6e6a47b1bfc97
  fromString1 :: GHC.Types.Int
  {- Strictness: b -}
64af466d8905ea309b9af0a6a87ee174
  fromString2 :: GHC.Types.Int
  {- Strictness: b -}
f6f9a0764de8e64a5005b481efa8d5fd
  fromString3 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: ((GHC.Read.$fReadInt3
                    GHC.Read.$fReadInt_$sconvertInt
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <GHC.Types.Int>_R)
                   @ GHC.Types.Int
                   (Text.Read.readEither5 @ GHC.Types.Int)) -}
72f7c760ffa86903fdf86d8596524dc4
  getDiags :: Data.Matrix.Matrix t -> [[t]]
  {- Arity: 1, Strictness: <S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t w :: Data.Matrix.Matrix t ->
                 case w of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$wgetDiags @ t ww1 ww2 ww3 ww4 ww5 ww6 }) -}
242b18f26ccf7be00d5d57ae386ab869
  getMove :: Main.GameState -> GHC.Types.IO Main.Move
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.getMove1
                  `cast`
                (<Main.GameState>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Main.Move>_R)) -}
122da5561bf30ae89319f657df5c2330
  getMove1 ::
    Main.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.Move #)
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ gs :: Main.GameState
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Player "#
                           (case gs of wild {
                              DEFAULT -> case Main.currentTurn1 ret_ty [GHC.Types.Char] of {}
                              Main.GameState ds ds1
                              -> case ds1 of wild1 {
                                   Main.PX -> Main.getMove4 Main.PO -> Main.getMove2 } }))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Internals.wantReadableHandle_1
                        @ GHC.Base.String
                        GHC.IO.Handle.Text.hGetLine4
                        GHC.IO.Handle.FD.stdin
                        GHC.IO.Handle.Text.hGetLine2
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Base.String>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (Debug.Trace.trace
                    @ (GHC.Types.IO Main.Move)
                    (GHC.CString.unpackAppendCString#
                       "got move: "#
                       (Main.$w$cshowsPrec1
                          0
                          (case Text.Read.readEither6
                                  @ GHC.Types.Int
                                  (Text.ParserCombinators.ReadP.run
                                     @ GHC.Types.Int
                                     Main.fromString3
                                     ipv3) of wild {
                             [] -> Main.fromString2
                             : x ds
                             -> case ds of wild1 { [] -> x : ipv4 ipv5 -> Main.fromString1 } })
                          (GHC.Types.[] @ GHC.Types.Char)))
                    (\ s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                     (# s1, Main.fromString ipv3 #))
                      `cast`
                    (Sym (GHC.Types.NTCo:IO[0] <Main.Move>_R)))
                   `cast`
                 (GHC.Types.NTCo:IO[0] <Main.Move>_R)
                   ipv2 } }) -}
eb01401792f331164eeec8a42cebf1ea
  getMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState5
                   Main.getMove3) -}
135808afc4b5cc3d0a68b9d730fdf5e1
  getMove3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "'s turn.Please enter a move:"#) -}
7c67328fcfe0380c236e6a9043cd6704
  getMove4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState7
                   Main.getMove3) -}
c68dac399dd25a57a3b7b2b1978c198e
  iToC ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { GHC.Types.I# ww3 ->
                 case Main.$wiToC ww1 ww3 w2 of ww4 { (#,#) ww5 ww6 ->
                 (ww5, ww6) } } }) -}
e27d5d3e010156474c48ced87190e67f
  iToC1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 1) -}
47a517a295b54385e53328bcabfd5f61
  iToC2 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# (-1)) -}
0e59525e41a93f427a15c4cc0e27136d
  inBounds ::
    (GHC.Num.Num a, GHC.Num.Num a1, GHC.Classes.Ord a,
     GHC.Classes.Ord a1) =>
    (a, a1) -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a1
                   @ a2
                   w :: GHC.Num.Num a1
                   w1 :: GHC.Num.Num a2
                   w2 :: GHC.Classes.Ord a1
                   w3 :: GHC.Classes.Ord a2
                   w4 :: (a1, a2) ->
                 case w4 of ww { (,) ww1 ww2 ->
                 Main.$winBounds @ a1 @ a2 w w1 w2 w3 ww1 ww2 }) -}
abf842e394228180ac20c1df661cc436
  inBounds1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 6) -}
01fb82d0c438b1a5c648e53d9c287d5a
  inBounds2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
ffe267953b0f96eddbab3d4471e71f89
  inBounds3 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 7) -}
e9163ca7cde44c7e073d8db0246a3c84
  inCol ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,1*U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.Player w2 :: Main.Board ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winCol w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
be5cc5505043ba6944d831ac4fa27659
  inDiag ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.Player w2 :: Main.Board ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winDiag w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
a6959308228bd203905fcd9810c51d57
  inRow ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U)><L,U><S,1*U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.Player w2 :: Main.Board ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winRow w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
a96d52a04d94203827e5ae258fdd1c47
  inRowColOrDiag ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: Main.Player w2 :: Main.Board ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winRowColOrDiag w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
5fad5829cdb2c7da360b0b8d88aedc32
  isEmpty ::
    (GHC.Types.Int, GHC.Types.Int) -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SS),1*U(1*U(U),U(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: (GHC.Types.Int, GHC.Types.Int) w1 :: Main.GameState ->
                 case w of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 Main.$wisEmpty ww4 ww6 w1 } } }) -}
99094fe26634f6c9f0485a2ee8e46e90
  isEmpty1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> Main.Piece
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>b -}
4722a0f7aefd682de2720c4ca122c8c6
  isFull :: Data.Matrix.Matrix Main.Piece -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U(U,U,U,U,U,U(U,A,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ b :: Data.Matrix.Matrix Main.Piece ->
                 Main.mfold
                   @ Main.Piece
                   @ GHC.Types.Bool
                   Main.isFull1
                   GHC.Types.True
                   b) -}
d3af05186de0dedea82212513e31ddeb
  isFull1 ::
    ((GHC.Types.Int, GHC.Types.Int), Main.Piece, GHC.Types.Bool)
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSL),1*U(1*H,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: ((GHC.Types.Int, GHC.Types.Int),
                          Main.Piece,
                          GHC.Types.Bool) ->
                 case ds of wild { (,,) ds1 piece acc ->
                 case ds1 of wild1 { (,) i j ->
                 case piece of wild2 {
                   DEFAULT -> acc Main.Nil -> GHC.Types.False } } }) -}
1f6c49949c202aff05402312518a0395
  isValid :: Main.GameState -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S(S),1*U(1*U(U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.GameState w1 :: Main.Move ->
                 case w1 of ww { Main.Move ww1 ->
                 case ww1 of ww2 { GHC.Types.I# ww3 -> Main.$wisValid w ww3 } }) -}
0b01ab912a9150549937adbdd209f272
  lfoldi ::
    (GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int))
    -> GHC.Types.Int
    -> (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> [a]
    -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(U)><L,U(U)><L,C(U)><L,1*U><S,1*U> -}
4009afc663757261a9edc43f455d605d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
ffe3e92e7cbb202b0aa198a448821942
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Main.main2
                        (Main.GameState Main.boardInitF Main.PX)
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
b6b4f204069c0664ed990718c2a65422
  main2 ::
    Main.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><L,U> -}
cb3cc746fd145fdedadc48e4460c11f3
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
86a7d946f1b2dd8a3edefeedce39ec81
  mfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b -> Data.Matrix.Matrix a -> b
  {- Arity: 3, Strictness: <L,C(U)><L,1*U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a1
                   @ b
                   w :: ((GHC.Types.Int, GHC.Types.Int), a1, b) -> b
                   w1 :: b
                   w2 :: Data.Matrix.Matrix a1 ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$wmfold @ a1 @ b w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
8fd61f0327d1ce84e6a6b5bd38e26e0a
  mtoc :: Main.Move -> GHC.Types.Int
  {- Arity: 1, HasNoCafRefs, Strictness: <S(S),1*U(1*U(U))>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Move -> case ds of wild { Main.Move c -> c }) -}
4a24f0e322eb796af9016e53c22518cb
  otherPlayer :: Main.Player -> Main.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Player ->
                 case ds of wild { Main.PX -> Main.PO Main.PO -> Main.PX }) -}
bae9a15101665a16f5f9cde53fdf4495
  outcome ::
    GHC.Num.Num t => Main.GameState -> Main.Move -> (Main.GameState, t)
  {- Arity: 3,
     Strictness: <L,1*U(A,A,A,A,A,A,1*C1(U))><S,U><L,1*U(1*U(U))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t w :: GHC.Num.Num t w1 :: Main.GameState w2 :: Main.Move ->
                 case Main.$woutcome @ t w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
fa8ebc27f554db6b7dc60beb3b5d1382
  outcome1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
d90cd63ccc130f7bca196ab75f50f4f6
  place ::
    Main.GameState
    -> Main.Piece -> (GHC.Types.Int, GHC.Types.Int) -> Main.GameState
  {- Arity: 3, Strictness: <L,U><L,U><L,1*U(1*U(U),1*U(U))>m1,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: Main.GameState
                   w1 :: Main.Piece
                   w2 :: (GHC.Types.Int, GHC.Types.Int) ->
                 case Main.$wplace w w1 w2 of ww { (#,#) ww1 ww2 ->
                 Main.GameState ww1 ww2 }) -}
99cf7544b420ca722745c9f7728ee2de
  playGame :: Main.GameState -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main2
                  `cast`
                (<Main.GameState>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
9fab3af0866facb9d78c2e394578b063
  playerToPiece :: Main.Player -> Main.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Player ->
                 case ds of wild { Main.PX -> Main.X Main.PO -> Main.O }) -}
739db4704aee4336f89876c67a786923
  possMoves :: Main.GameState -> [Main.Move]
  {- Arity: 1, Strictness: <B,A>b,
     Unfolding: InlineRule (1, True, True)
                (\ game :: Main.GameState -> GHC.Err.undefined @ [Main.Move]) -}
53afa9032633dcd59e285bef6854d3da
  size :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Main.inBounds3, Main.inBounds1)) -}
5b4984640d97669cceb071b4f1b36578
  slot ::
    Main.Board -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 2,
     Strictness: <S(LLLLLS),1*U(A,U,U,U,U,U(U,U,U))><S,1*U(U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: Main.Board w1 :: GHC.Types.Int ->
                 case w of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 case ww6 of ww7 { Data.Vector.Vector ww8 ww9 ww10 ->
                 case w1 of ww11 { GHC.Types.I# ww12 ->
                 Main.$wslot ww2 ww3 ww4 ww5 ww8 ww9 ww10 ww12 } } }) -}
dfc3c494e2733479d95c0db6fb9733f0
  tie :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.tie1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
fa308e21bd20b1c671855d1a70134f95
  tie1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.tie2
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
b377a1833b3a98befe2ea3b5fe927a33
  tie2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "The game has ended in a tie."#) -}
8f73831b6c6bb6415e3b042f3a554c46
  tiec :: Main.GameState -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ game :: Main.GameState ->
                 case game of wild {
                   DEFAULT -> case Main.board1 ret_ty GHC.Types.Bool of {}
                   Main.GameState ds ds1
                   -> Main.mfold
                        @ Main.Piece
                        @ GHC.Types.Bool
                        Main.isFull1
                        GHC.Types.True
                        ds }) -}
31bd13caf5bcedb2928231af730713ef
  turn :: Main.Player
  {- HasNoCafRefs, Unfolding: InlineRule (0, True, True) Main.PX -}
d344d989cf26da866a0aaa433eac7038
  winc :: Main.GameState -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ game :: Main.GameState ->
                 case game of wild {
                   DEFAULT -> case Main.board1 ret_ty GHC.Types.Bool of {}
                   Main.GameState ds ds1
                   -> case ds of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                      case Main.$winRowColOrDiag
                             Main.winc1
                             Main.PX
                             ww1
                             ww2
                             ww3
                             ww4
                             ww5
                             ww6 of wild1 {
                        GHC.Types.False
                        -> Main.$winRowColOrDiag Main.winc1 Main.PO ww1 ww2 ww3 ww4 ww5 ww6
                        GHC.Types.True -> GHC.Types.True } } }) -}
f7d56763cc992868b73137a4b01f563b
  winc1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 4) -}
aca2bbcdd5256f101cf03f0f2fffdc73
  won :: Main.Player -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.won1
                  `cast`
                (<Main.Player>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
fc1912c5b65be3599f45884556639360
  won1 ::
    Main.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ p :: Main.Player
                   s :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Player "#
                           (case p of wild { Main.PX -> Main.won4 Main.PO -> Main.won2 }))
                        GHC.Types.True
                        s of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
cb7086b7ff6f63af6bcc13cf04f373ff
  won2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState5
                   Main.won3) -}
9813d1c3398962e835d4c2d15783178c
  won3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " has won!"#) -}
43c5fb605ae25843dc571b4c6c3bc340
  won4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState7
                   Main.won3) -}
32e05893ed19f81e188ce44d3ac0f086
  xor :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: GHC.Types.Bool ds1 :: GHC.Types.Bool ->
                 case ds of wild {
                   GHC.Types.False -> ds1
                   GHC.Types.True
                   -> case ds1 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
instance GHC.Classes.Eq [Main.GameState] = Main.$fEqGameState
instance GHC.Classes.Eq [Main.Move] = Main.$fEqMove
instance GHC.Classes.Eq [Main.Piece] = Main.$fEqPiece
instance GHC.Classes.Eq [Main.Player] = Main.$fEqPlayer
instance GHC.Show.Show [Main.GameState] = Main.$fShowGameState
instance GHC.Show.Show [Main.Move] = Main.$fShowMove
instance GHC.Show.Show [Main.Piece] = Main.$fShowPiece
instance GHC.Show.Show [Main.Player] = Main.$fShowPlayer
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

