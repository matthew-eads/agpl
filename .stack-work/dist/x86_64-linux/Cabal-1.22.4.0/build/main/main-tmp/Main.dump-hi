
==================== FINAL INTERFACE ====================
2015-11-20 03:52:08.785259 UTC

interface main@main:Main 7102
  interface hash: 9a09b994f77952bf5132dbdde6d738ea
  ABI hash: d53b11b8b7b77accaaae5f48d85e9b10
  export-list hash: ca3630d93aee4cef767eb6ed3caeb145
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b9fdbf528949e233f3a610c29cd057f2
  sig of: Nothing
  used TH splices: True
  where
exports:
  Main.boardInitF
  Main.e
  Main.fromString
  Main.getDiags
  Main.getMove
  Main.iToC
  Main.inBounds
  Main.inCol
  Main.inDiag
  Main.inRow
  Main.isEmpty
  Main.isFull
  Main.isValid
  Main.lfoldi
  Main.main
  Main.mfold
  Main.n
  Main.ne
  Main.nw
  Main.otherPlayer
  Main.outcome
  Main.pieceToPlayer
  Main.playGame
  Main.playerToPiece
  Main.possMoves
  Main.s
  Main.se
  Main.size
  Main.sw
  Main.tie
  Main.turn
  Main.w
  Main.won
  Main.xor
  Main.Board
  Main.GameState{Main.GameState Main.Tie Main.Win Main.board Main.currentTurn}
  Main.Move{Main.Move}
  Main.Piece{Main.Nil Main.O Main.X}
  Main.Player{Main.PO Main.PX}
  Main.Turn
module dependencies: Agpl_syntax CodeGen Parser Quote
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd
                      bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH
                      containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN
                      deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o ghc-prim-0.4.0.0
                      haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT
                      haskell-src-meta-0.6.0.11@haske_DSABzgEPWpw1dF6z3BP4C8
                      integer-gmp-1.0.0.0 loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      mtl-2.2.1@mtl_KMpng31YRYc5JfMWFZ3FCU
                      parsec-3.1.9@parse_8fSmqig53hOL2SEu1k9Tv0
                      pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      split-0.2.2@split_E4yadeCDng9EtdbI5MZoDg template-haskell-2.10.0.0
                      text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         binary-0.7.5.0@binar_IvYoLp9H6Xy3zEH13MmZwd:Data.Binary.Generic
         bytestring-0.10.6.0@bytes_6elQVSg5cWdFrvRnfxTUrH:Data.ByteString.Builder
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Show
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntMap.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.IntSet.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Map.Base
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Sequence
                         containers-0.5.6.2@conta_LKCPrTJwOTOLk4OU37YmeN:Data.Set.Base
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Annotated.Syntax
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.SrcLoc
                         haskell-src-exts-1.16.0.1@haske_2mzIFu6itP1JzQr9p1IAHT:Language.Haskell.Exts.Syntax
                         pretty-1.1.2.0@prett_7UQTOB05U7lIYPkFOVraeR:Text.PrettyPrint.HughesPJ
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text
                         text-1.2.1.3@text_1l1AN4I48k37RaQ6fm6CEh:Data.Text.Lazy
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:Data.List 2a4f5f92892d432e7113f64cd9dcca53
import  -/  base-4.8.1.0:Debug.Trace 7cf679861c4b1d69175105437aae1212
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.List f31ed8784b3e05f1397195751f7d74ea
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Real 4c3b525ecbd4d62bb287aec36d4c2f0d
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  base-4.8.1.0:System.Environment 946ddc2d7c48138bb213316abaff2a8d
import  -/  base-4.8.1.0:System.IO d541b8bdf18c04de3ab7ea0277c4eba3
import  -/  base-4.8.1.0:Text.Read 30509137a501bd56d136aca29a7a35a6
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  ghc-prim-0.4.0.0:GHC.Types 6b27fb3fdbd0e3f0925a4496c66513bb
import  -/  Parser c25f636d10a6b8d3ee162938673e72ed
  exports: 1f9ec8c56c5e3b4aa932d4bab54c92c1
import  -/  Quote 365c18ac848a46ba4abd63d50b386502
  exports: d0ec02e763329704e7da15c6df5027d3
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
import  -/  split-0.2.2@split_E4yadeCDng9EtdbI5MZoDg:Data.List.Split 191d865ea862c301707cccb38cecb628
import  -/  split-0.2.2@split_E4yadeCDng9EtdbI5MZoDg:Data.List.Split.Internals 9a9700f4e3c2bb24917a9d1daa5a114d
import  -/  vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector 1ab51bec0be594f8c3b5e22942541591
addDependentFile "ttt.agpl"
a514cc793dc35ea9306d252c2be5b6b1
  $fEqGameState :: GHC.Classes.Eq Main.GameState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.GameState Main.$fEqGameState_$c== Main.$fEqGameState_$c/= -}
a514cc793dc35ea9306d252c2be5b6b1
  $fEqGameState_$c/= ::
    Main.GameState -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Main.GameState b :: Main.GameState ->
                 case Main.$fEqGameState_$c== a b of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True -> GHC.Types.False }) -}
a514cc793dc35ea9306d252c2be5b6b1
  $fEqGameState_$c== ::
    Main.GameState -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S,1*U><S,1*U>,
     Unfolding: (\ ds :: Main.GameState ds1 :: Main.GameState ->
                 case ds of wild {
                   Main.GameState a1 a2
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Main.GameState b1 b2
                        -> case Data.Matrix.$fEqMatrix_$c==
                                  @ Main.Piece
                                  Main.$fEqPiece
                                  a1
                                  b1 of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True -> Main.$fEqGameState_$c==1 a2 b2 } }
                   Main.Win a1
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False
                        Main.Win b1 -> Main.$fEqGameState_$c==1 a1 b1 }
                   Main.Tie
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.Tie -> GHC.Types.True } }) -}
98212b57c8c879b232f87aa847ce388a
  $fEqGameState_$c==1 :: Main.Player -> Main.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Player ds1 :: Main.Player ->
                 case ds of wild {
                   Main.PX
                   -> case ds1 of wild1 {
                        Main.PX -> GHC.Types.True Main.PO -> GHC.Types.False }
                   Main.PO
                   -> case ds1 of wild1 {
                        Main.PX -> GHC.Types.False Main.PO -> GHC.Types.True } }) -}
5d5942dc591a7332cde7597b9f224101
  $fEqMove :: GHC.Classes.Eq Main.Move
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Move Main.$fEqMove_$c== Main.$fEqMove_$c/= -}
5d5942dc591a7332cde7597b9f224101
  $fEqMove_$c/= :: Main.Move -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)),1*U(1*U(1*U(U),1*U(U)))><S(S(SL)),1*U(1*U(1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w1 :: Main.Move w2 :: Main.Move ->
                 case w1 of ww { Main.Move ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case w2 of ww7 { Main.Move ww8 ->
                 case ww8 of ww9 { (,) ww10 ww11 ->
                 case ww10 of ww12 { GHC.Types.I# ww13 ->
                 Main.$w$c/= ww6 ww4 ww13 ww11 } } } } } }) -}
5d5942dc591a7332cde7597b9f224101
  $fEqMove_$c== :: Main.Move -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(S(SL)),1*U(1*U(1*U(U),1*U(U)))><S(S(SL)),1*U(1*U(1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w1 :: Main.Move w2 :: Main.Move ->
                 case w1 of ww { Main.Move ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 case w2 of ww7 { Main.Move ww8 ->
                 case ww8 of ww9 { (,) ww10 ww11 ->
                 case ww10 of ww12 { GHC.Types.I# ww13 ->
                 Main.$w$c== ww6 ww4 ww13 ww11 } } } } } }) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fEqPiece :: GHC.Classes.Eq Main.Piece
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Piece Main.$fEqPiece_$c== Main.$fEqPiece_$c/= -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fEqPiece_$c/= :: Main.Piece -> Main.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Main.Piece b :: Main.Piece ->
                 case a of wild {
                   Main.X
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.X -> GHC.Types.False }
                   Main.O
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.O -> GHC.Types.False }
                   Main.Nil
                   -> case b of wild1 {
                        DEFAULT -> GHC.Types.True Main.Nil -> GHC.Types.False } }) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fEqPiece_$c== :: Main.Piece -> Main.Piece -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Piece ds1 :: Main.Piece ->
                 case ds of wild {
                   Main.X
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.X -> GHC.Types.True }
                   Main.O
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.O -> GHC.Types.True }
                   Main.Nil
                   -> case ds1 of wild1 {
                        DEFAULT -> GHC.Types.False Main.Nil -> GHC.Types.True } }) -}
98212b57c8c879b232f87aa847ce388a
  $fEqPlayer :: GHC.Classes.Eq Main.Player
  DFunId[0]
  {- HasNoCafRefs, Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Player Main.$fEqGameState_$c==1 Main.$fEqPlayer_$c/= -}
98212b57c8c879b232f87aa847ce388a
  $fEqPlayer_$c/= :: Main.Player -> Main.Player -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ a :: Main.Player b :: Main.Player ->
                 case a of wild {
                   Main.PX
                   -> case b of wild1 {
                        Main.PX -> GHC.Types.False Main.PO -> GHC.Types.True }
                   Main.PO
                   -> case b of wild1 {
                        Main.PX -> GHC.Types.True Main.PO -> GHC.Types.False } }) -}
a514cc793dc35ea9306d252c2be5b6b1
  $fShowGameState :: GHC.Show.Show Main.GameState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.GameState
                  Main.$fShowGameState_$cshowsPrec
                  Main.$fShowGameState_$cshow
                  Main.$fShowGameState_$cshowList -}
a514cc793dc35ea9306d252c2be5b6b1
  $fShowGameState1 :: Main.GameState -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Main.$fShowGameState_$cshowsPrec
                   Main.$fShowGameState2) -}
2f7fd8a64a161a3f80dc89cf8fae2228
  $fShowGameState10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board = "#) -}
03d91f6c802d6ddf4f7c9c9348055912
  $fShowGameState11 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState {"#) -}
9100f46b94ddc4f98d932ba07b8d55a9
  $fShowGameState2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
4a7fc083d3ad176e014f605fdd818ca9
  $fShowGameState3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Tie"#) -}
e45899e5de3288d3d65113ea57245022
  $fShowGameState4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Win "#) -}
8d26bbe0427209bcbecab2792533a343
  $fShowGameState5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PO"#) -}
588538aa0c44ac4647ea2cd051be59f0
  $fShowGameState6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
6c7f2b9b27951a307ba82bdf9cd9afcf
  $fShowGameState7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PX"#) -}
9ad7745e11e29fc2feaeed0aeb673b56
  $fShowGameState8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "currentTurn = "#) -}
13e921472717c5e1805fe8ebd7af6d71
  $fShowGameState9 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
a514cc793dc35ea9306d252c2be5b6b1
  $fShowGameState_$cshow :: Main.GameState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.GameState ->
                 Main.$fShowGameState_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
a514cc793dc35ea9306d252c2be5b6b1
  $fShowGameState_$cshowList :: [Main.GameState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.GameState
                   Main.$fShowGameState1) -}
a514cc793dc35ea9306d252c2be5b6b1
  $fShowGameState_$cshowsPrec ::
    GHC.Types.Int -> Main.GameState -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U>,
     Unfolding: (\ a :: GHC.Types.Int
                   ds :: Main.GameState
                   eta :: GHC.Base.String ->
                 case ds of wild {
                   Main.GameState b1 b2
                   -> case a of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowGameState11
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Main.$fShowGameState10
                               (case b1 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                                GHC.Base.++
                                  @ GHC.Types.Char
                                  (Data.Matrix.$wprettyMatrix
                                     @ Main.Piece
                                     Main.$fShowPiece
                                     ww1
                                     ww2
                                     ww3
                                     ww4
                                     ww5
                                     ww6)
                                  (GHC.Base.++
                                     @ GHC.Types.Char
                                     Main.$fShowGameState9
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        Main.$fShowGameState8
                                        (case b2 of wild2 {
                                           Main.PX
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Main.$fShowGameState7
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Main.$fShowGameState6
                                                   x1)
                                           Main.PO
                                           -> GHC.Base.++
                                                @ GHC.Types.Char
                                                Main.$fShowGameState5
                                                (GHC.Base.++
                                                   @ GHC.Types.Char
                                                   Main.$fShowGameState6
                                                   x1) }))) }))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   Main.Win b1
                   -> case a of wild1 { GHC.Types.I# x ->
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x1 :: GHC.Base.String[OneShot] ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Main.$fShowGameState4
                            (case b1 of wild2 {
                               Main.PX -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState7 x1
                               Main.PO -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState5 x1 })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False -> p eta
                        GHC.Types.True
                        -> GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 eta)) } }
                   Main.Tie
                   -> GHC.Base.++ @ GHC.Types.Char Main.$fShowGameState3 eta }) -}
5d5942dc591a7332cde7597b9f224101
  $fShowMove :: GHC.Show.Show Main.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Move
                  Main.$fShowMove_$cshowsPrec
                  Main.$fShowMove_$cshow
                  Main.$fShowMove_$cshowList -}
5d5942dc591a7332cde7597b9f224101
  $fShowMove1 :: Main.Move -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w1 :: Main.Move w2 :: GHC.Base.String ->
                 case w1 of ww { Main.Move ww1 -> Main.$w$cshowsPrec1 0 ww1 w2 }) -}
1d8214de8b8a42b6dac5b7abe1200838
  $fShowMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Move "#) -}
5d5942dc591a7332cde7597b9f224101
  $fShowMove_$cshow :: Main.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U(U),U(U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Move ->
                 Main.$fShowMove_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
5d5942dc591a7332cde7597b9f224101
  $fShowMove_$cshowList :: [Main.Move] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Main.Move Main.$fShowMove1) -}
5d5942dc591a7332cde7597b9f224101
  $fShowMove_$cshowsPrec ::
    GHC.Types.Int -> Main.Move -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(1*U(U),U(U)))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w1 :: GHC.Types.Int w2 :: Main.Move w3 :: GHC.Base.String ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 case w2 of ww2 { Main.Move ww3 ->
                 Main.$w$cshowsPrec1 ww1 ww3 w3 } }) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fShowPiece :: GHC.Show.Show Main.Piece
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Piece
                  Main.$fShowPiece_$cshowsPrec
                  Main.$fShowPiece_$cshow
                  Main.$fShowPiece_$cshowList -}
40f672ac49626e88fc4028d456035e60
  $fShowPiece1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Nil"#) -}
0d1c6d496fa5dd73c571ac00bbf9e8b3
  $fShowPiece2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "O"#) -}
aba7b090a3cdc9215c7b6362ac273280
  $fShowPiece3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "X"#) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fShowPiece_$cshow :: Main.Piece -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Piece ->
                 case x of wild {
                   Main.X -> Main.$fShowPiece3
                   Main.O -> Main.$fShowPiece2
                   Main.Nil -> Main.$fShowPiece1 }) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fShowPiece_$cshowList :: [Main.Piece] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__ @ Main.Piece Main.$w$cshowsPrec) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $fShowPiece_$cshowsPrec ::
    GHC.Types.Int -> Main.Piece -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (3, True, True)
                (\ w1 :: GHC.Types.Int w2 :: Main.Piece w3 :: GHC.Base.String ->
                 Main.$w$cshowsPrec w2 w3) -}
98212b57c8c879b232f87aa847ce388a
  $fShowPlayer :: GHC.Show.Show Main.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Player
                  Main.$fShowPlayer_$cshowsPrec
                  Main.$fShowPlayer_$cshow
                  Main.$fShowPlayer_$cshowList -}
98212b57c8c879b232f87aa847ce388a
  $fShowPlayer1 :: Main.Player -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U><L,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: Main.Player eta :: GHC.Base.String ->
                 case ds of wild {
                   Main.PX
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 Main.$fShowGameState7)
                        eta
                   Main.PO
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 Main.$fShowGameState5)
                        eta }) -}
98212b57c8c879b232f87aa847ce388a
  $fShowPlayer_$cshow :: Main.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Main.Player ->
                 case x of wild {
                   Main.PX -> Main.$fShowGameState7
                   Main.PO -> Main.$fShowGameState5 }) -}
98212b57c8c879b232f87aa847ce388a
  $fShowPlayer_$cshowList :: [Main.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Main.Player
                   Main.$fShowPlayer1) -}
98212b57c8c879b232f87aa847ce388a
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> Main.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,A><S,1*U><L,1*U>,
     Unfolding: InlineRule (3, True, False)
                (\ ds :: GHC.Types.Int ds1 :: Main.Player eta :: GHC.Base.String ->
                 case ds1 of wild {
                   Main.PX
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 Main.$fShowGameState7)
                        eta
                   Main.PO
                   -> GHC.Base.augment
                        @ GHC.Types.Char
                        (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n1 :: b[OneShot] ->
                         GHC.Base.foldr @ GHC.Types.Char @ b c n1 Main.$fShowGameState5)
                        eta }) -}
88d598eec4da4e6fce2cd618c423716d
  $w$c/= ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.True
                   GHC.Types.True
                   -> case ww1 of wild1 { GHC.Types.I# x ->
                      case ww3 of wild2 { GHC.Types.I# y ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.==# x y) of wild3 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } } } }) -}
04ce371ae3b99bb53b991528da0ff47d
  $w$c== ::
    GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Prim.Int#
    -> GHC.Types.Int
    -> GHC.Types.Bool
  {- Arity: 4, HasNoCafRefs,
     Strictness: <L,U><L,1*U(U)><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.==# ww ww2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True -> GHC.Classes.eqInt ww1 ww3 }) -}
bb9271c29a8c95a8aa6826ad6bbb096d
  $w$cshowsPrec :: Main.Piece -> GHC.Base.String -> GHC.Base.String
  {- Arity: 2, Strictness: <S,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ w1 :: Main.Piece w2 :: GHC.Base.String ->
                 case w1 of wild {
                   Main.X -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece3 w2
                   Main.O -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece2 w2
                   Main.Nil -> GHC.Base.++ @ GHC.Types.Char Main.$fShowPiece1 w2 }) -}
692d0699b2cc44fdda376f2a32c09342
  $w$cshowsPrec1 ::
    GHC.Prim.Int#
    -> (GHC.Types.Int, GHC.Types.Int)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U(1*U(U),U(U))><L,U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: (GHC.Types.Int, GHC.Types.Int)
                   w1 :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowMove2
                       (case ww1 of ww2 { (,) ww3 ww4 ->
                        GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows9
                          (case ww3 of ww5 { GHC.Types.I# ww6 ->
                           case GHC.Show.$wshowSignedInt
                                  0
                                  ww6
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__1
                                     (GHC.List.foldr1_$sfoldr1
                                        @ (GHC.Base.String -> GHC.Base.String)
                                        GHC.Show.$fShow(,)1
                                        (\ w2 :: GHC.Base.String ->
                                         case ww4 of ww7 { GHC.Types.I# ww8 ->
                                         case GHC.Show.$wshowSignedInt
                                                0
                                                ww8
                                                w2 of ww9 { (#,#) ww10 ww11 ->
                                         GHC.Types.: @ GHC.Types.Char ww10 ww11 } })
                                        (GHC.Types.[] @ GHC.Show.ShowS)
                                        (GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows8
                                           x))) of ww7 { (#,#) ww8 ww9 ->
                           GHC.Types.: @ GHC.Types.Char ww8 ww9 } }) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w1
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w1)) }) -}
de40dd42e4b1777a205415e9060e5b7b
  $wfromString ::
    [GHC.Types.Char] -> (# (GHC.Types.Int, GHC.Types.Int) #)
  {- Arity: 1, Strictness: <L,U>, Inline: [0],
     Unfolding: (\ w1 :: [GHC.Types.Char] ->
                 (# let {
                      move :: [GHC.Types.Int]
                      = GHC.Base.map
                          @ [GHC.Types.Char]
                          @ GHC.Types.Int
                          Main.fromString3
                          (Main.fromString1 w1)
                    } in
                    (GHC.List.head @ GHC.Types.Int move,
                     case move of wild {
                       [] -> case GHC.List.tail1 ret_ty GHC.Types.Int of {}
                       : ds1 xs -> GHC.List.head @ GHC.Types.Int xs }) #)) -}
e1c6c5554a2c9ea7c4693d77bc5d9b7d
  $wgetDiags ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector t
    -> [[t]]
  {- Arity: 6, Strictness: <L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0] -}
83a1064a4e88f49fe65e89151bacc3e2
  $wiToC ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><L,U(U)>, Inline: [0],
     Unfolding: (\ w1 :: GHC.Types.Int
                   w2 :: GHC.Types.Int
                   w3 :: GHC.Types.Int ->
                 (# case w3 of wild { GHC.Types.I# i ->
                    case w1 of wild1 { GHC.Types.I# i1 ->
                    case GHC.Prim./##
                           (GHC.Prim.int2Double# i)
                           (GHC.Prim.int2Double# i1) of wild2 { DEFAULT ->
                    let {
                      n1 :: GHC.Prim.Int# = GHC.Prim.double2Int# wild2
                    } in
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<## (GHC.Prim.int2Double# n1) wild2) of wild3 {
                      GHC.Types.False -> GHC.Types.I# n1
                      GHC.Types.True -> GHC.Types.I# (GHC.Prim.+# n1 1) } } } },
                    case w2 of ww { GHC.Types.I# ww1 ->
                    case ww1 of wild {
                      DEFAULT
                      -> case w3 of wild1 { GHC.Types.I# x ->
                         case GHC.Classes.modInt# x wild of ww2 {
                           DEFAULT -> GHC.Types.I# ww2 0 -> ww } }
                      (-1) -> ww
                      0
                      -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} } } #)) -}
63ff4ad7422e10ccd50e3661bbd9daf6
  $winBounds ::
    (GHC.Num.Num a, GHC.Num.Num a1, GHC.Classes.Ord a,
     GHC.Classes.Ord a1) =>
    a -> a1 -> GHC.Types.Bool
  {- Arity: 6, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ a1
                   w1 :: GHC.Num.Num a
                   w2 :: GHC.Num.Num a1
                   w3 :: GHC.Classes.Ord a
                   w4 :: GHC.Classes.Ord a1
                   ww :: a
                   ww1 :: a1 ->
                 case GHC.Classes.<=
                        @ a
                        w3
                        ww
                        (GHC.Num.fromInteger @ a w1 Main.inBounds2) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Classes.>
                             @ a
                             w3
                             ww
                             (GHC.Num.fromInteger @ a w1 Main.inBounds1) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case GHC.Classes.<=
                                  @ a1
                                  w4
                                  ww1
                                  (GHC.Num.fromInteger @ a1 w2 Main.inBounds2) of wild2 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> GHC.Classes.>
                                  @ a1
                                  w4
                                  ww1
                                  (GHC.Num.fromInteger @ a1 w2 Main.inBounds1) } } }) -}
e77f960c082ddc7c6e4a1889099b7e06
  $winCol ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w1 :: GHC.Types.Int
                   w2 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 case Data.Matrix.$wtranspose
                        @ Main.Piece
                        ww
                        ww1
                        ww2
                        ww3
                        ww4
                        ww5 of ww7 { (#,,,,,#) ww8 ww9 ww10 ww11 ww12 ww13 ->
                 letrec {
                   go :: [Main.Piece] -> GHC.Types.Int -> GHC.Types.Int
                     {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
                   = \ ds :: [Main.Piece] eta :: GHC.Types.Int ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case y of wild1 {
                               Main.X
                               -> case w2 of wild2 {
                                    Main.PX
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) }
                                    Main.PO -> Main.$fShowGameState2 }
                               Main.O
                               -> case w2 of wild2 {
                                    Main.PX -> Main.$fShowGameState2
                                    Main.PO
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) } }
                               Main.Nil
                               -> case w2 of wild2 { DEFAULT -> Main.$fShowGameState2 } }) }
                 } in
                 letrec {
                   go1 :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go1
                            ys
                            (case go y Main.$fShowGameState2 of wild1 { GHC.Types.I# x ->
                             case w1 of wild2 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x y1) of wild3 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go1
                   (Data.Matrix.$wtoLists @ Main.Piece ww8 ww9 ww10 ww11 ww12 ww13)
                   GHC.Types.False }) -}
2f91fe4b47c48eb4ba313ca5978ea0bf
  $winDiag ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w1 :: GHC.Types.Int
                   w2 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 letrec {
                   go :: [Main.Piece] -> GHC.Types.Int -> GHC.Types.Int
                     {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
                   = \ ds :: [Main.Piece] eta :: GHC.Types.Int ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case y of wild1 {
                               Main.X
                               -> case w2 of wild2 {
                                    Main.PX
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) }
                                    Main.PO -> Main.$fShowGameState2 }
                               Main.O
                               -> case w2 of wild2 {
                                    Main.PX -> Main.$fShowGameState2
                                    Main.PO
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) } }
                               Main.Nil
                               -> case w2 of wild2 { DEFAULT -> Main.$fShowGameState2 } }) }
                 } in
                 letrec {
                   go1 :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go1
                            ys
                            (case go y Main.$fShowGameState2 of wild1 { GHC.Types.I# x ->
                             case w1 of wild2 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x y1) of wild3 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go1
                   (Main.$wgetDiags @ Main.Piece ww ww1 ww2 ww3 ww4 ww5)
                   GHC.Types.False) -}
9d46be960531addb55245e12b0f9cab1
  $winRow ::
    GHC.Types.Int
    -> Main.Player
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector Main.Piece
    -> GHC.Types.Bool
  {- Arity: 8, HasNoCafRefs,
     Strictness: <L,U(U)><L,U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ w1 :: GHC.Types.Int
                   w2 :: Main.Player
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector Main.Piece ->
                 letrec {
                   go :: [Main.Piece] -> GHC.Types.Int -> GHC.Types.Int
                     {- Arity: 2, Strictness: <S,1*U><L,1*U(U)> -}
                   = \ ds :: [Main.Piece] eta :: GHC.Types.Int ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go
                            ys
                            (case y of wild1 {
                               Main.X
                               -> case w2 of wild2 {
                                    Main.PX
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) }
                                    Main.PO -> Main.$fShowGameState2 }
                               Main.O
                               -> case w2 of wild2 {
                                    Main.PX -> Main.$fShowGameState2
                                    Main.PO
                                    -> case eta of wild3 { GHC.Types.I# x ->
                                       GHC.Types.I# (GHC.Prim.+# x 1) } }
                               Main.Nil
                               -> case w2 of wild2 { DEFAULT -> Main.$fShowGameState2 } }) }
                 } in
                 letrec {
                   go1 :: [[Main.Piece]] -> GHC.Types.Bool -> GHC.Types.Bool
                     {- Arity: 2, Strictness: <S,1*U><L,1*U> -}
                   = \ ds :: [[Main.Piece]] eta :: GHC.Types.Bool ->
                     case ds of wild {
                       [] -> eta
                       : y ys
                       -> go1
                            ys
                            (case go y Main.$fShowGameState2 of wild1 { GHC.Types.I# x ->
                             case w1 of wild2 { GHC.Types.I# y1 ->
                             case GHC.Prim.tagToEnum#
                                    @ GHC.Types.Bool
                                    (GHC.Prim.>=# x y1) of wild3 {
                               GHC.Types.False -> eta GHC.Types.True -> GHC.Types.True } } }) }
                 } in
                 go1
                   (Data.Matrix.$wtoLists @ Main.Piece ww ww1 ww2 ww3 ww4 ww5)
                   GHC.Types.False) -}
4d7f4ecfe664637452aacf15cd56873e
  $wisEmpty ::
    GHC.Prim.Int# -> GHC.Prim.Int# -> Main.GameState -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U><L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   w1 :: Main.GameState ->
                 case w1 of wild {
                   DEFAULT -> case Main.board1 ret_ty GHC.Types.Bool of {}
                   Main.GameState ds ds1
                   -> case ds of ww2 { Data.Matrix.M ww3 ww4 ww5 ww6 ww7 ww8 ->
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww ww3) of wild1 {
                        GHC.Types.False
                        -> case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.># ww1 ww4) of wild2 {
                             GHC.Types.False
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.<# ww 1) of wild3 {
                                  GHC.Types.False
                                  -> case GHC.Prim.tagToEnum#
                                            @ GHC.Types.Bool
                                            (GHC.Prim.<# ww1 1) of wild4 {
                                       GHC.Types.False
                                       -> case ww8 of wild5 { Data.Vector.Vector dt dt1 dt2 ->
                                          case GHC.Prim.indexArray#
                                                 @ Main.Piece
                                                 dt2
                                                 (GHC.Prim.+#
                                                    dt
                                                    (GHC.Prim.-#
                                                       (GHC.Prim.+#
                                                          (GHC.Prim.*#
                                                             (GHC.Prim.-# (GHC.Prim.+# ww ww5) 1)
                                                             ww7)
                                                          (GHC.Prim.+# ww1 ww6))
                                                       1)) of ds2 { (##) ipv ->
                                          case ipv of wild8 {
                                            DEFAULT -> GHC.Types.False
                                            Main.Nil -> GHC.Types.True } } }
                                       GHC.Types.True
                                       -> case Main.isEmpty1 ww3 ww4 ww ww1
                                          ret_ty GHC.Types.Bool
                                          of {} }
                                  GHC.Types.True
                                  -> case Main.isEmpty1 ww3 ww4 ww ww1 ret_ty GHC.Types.Bool of {} }
                             GHC.Types.True
                             -> case Main.isEmpty1 ww3 ww4 ww ww1 ret_ty GHC.Types.Bool of {} }
                        GHC.Types.True
                        -> case Main.isEmpty1 ww3 ww4 ww ww1
                           ret_ty GHC.Types.Bool
                           of {} } } }) -}
acf3c0a7704eb54e890a712f7f87e06e
  $wisValid ::
    Main.GameState -> GHC.Prim.Int# -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,1*U><L,U><L,1*U(U)>, Inline: [0],
     Unfolding: (\ w1 :: Main.GameState
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Types.Int ->
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.<=# ww 3) of wild {
                   GHC.Types.False -> GHC.Types.False
                   GHC.Types.True
                   -> case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.># ww 0) of wild1 {
                        GHC.Types.False -> GHC.Types.False
                        GHC.Types.True
                        -> case ww1 of wild2 { GHC.Types.I# x ->
                           case GHC.Prim.tagToEnum#
                                  @ GHC.Types.Bool
                                  (GHC.Prim.<=# x 3) of wild3 {
                             GHC.Types.False -> GHC.Types.False
                             GHC.Types.True
                             -> case GHC.Prim.tagToEnum#
                                       @ GHC.Types.Bool
                                       (GHC.Prim.># x 0) of wild4 {
                                  GHC.Types.False -> GHC.Types.False
                                  GHC.Types.True -> Main.$wisEmpty ww x w1 } } } } }) -}
af4d152c243d02a8017ec2e121e2b60b
  $wmfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector a
    -> b
  {- Arity: 8,
     Strictness: <L,C(U)><L,1*U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   w1 :: ((GHC.Types.Int, GHC.Types.Int), a, b) -> b
                   w2 :: b
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector a ->
                 let {
                   l :: [a] = Data.Matrix.$wtoList @ a ww ww1 ww2 ww3 ww4 ww5
                 } in
                 Main.lfoldi
                   @ a
                   @ b
                   (let {
                      w3 :: GHC.Types.Int = GHC.Types.I# ww1
                    } in
                    \ w4 :: GHC.Types.Int ->
                    (case w4 of wild { GHC.Types.I# i ->
                     case GHC.Prim./##
                            (GHC.Prim.int2Double# i)
                            (GHC.Prim.int2Double# ww) of wild2 { DEFAULT ->
                     let {
                       n1 :: GHC.Prim.Int# = GHC.Prim.double2Int# wild2
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<## (GHC.Prim.int2Double# n1) wild2) of wild1 {
                       GHC.Types.False -> GHC.Types.I# n1
                       GHC.Types.True -> GHC.Types.I# (GHC.Prim.+# n1 1) } } },
                     case ww1 of wild {
                       DEFAULT
                       -> case w4 of wild1 { GHC.Types.I# x ->
                          case GHC.Classes.modInt# x wild of ww6 {
                            DEFAULT -> GHC.Types.I# ww6 0 -> w3 } }
                       (-1) -> w3
                       0 -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} }))
                   (case GHC.List.$wlenAcc @ a l 0 of ww6 { DEFAULT ->
                    GHC.Types.I# ww6 })
                   w1
                   w2
                   l) -}
13a5d4f98305fca6f80d4f974c2a1867
  $woutcome ::
    Main.GameState
    -> (GHC.Types.Int, GHC.Types.Int)
    -> (# Main.GameState, GHC.Types.Int #)
  {- Arity: 2, Strictness: <S,U><L,1*U(1*U(U),1*U(U))>,
     Inline: [0] -}
ce7c3823a57e3665c0a17db8a1500187
  type Board = Data.Matrix.Matrix Main.Piece
a514cc793dc35ea9306d252c2be5b6b1
  data GameState
    = GameState {board :: Main.Board, currentTurn :: Main.Turn}
    | Win Main.Player
    | Tie
5d5942dc591a7332cde7597b9f224101
  data Move = Move (GHC.Types.Int, GHC.Types.Int)
bb9271c29a8c95a8aa6826ad6bbb096d
  data Piece = X | O | Nil
    Promotable
98212b57c8c879b232f87aa847ce388a
  data Player = PX | PO
    Promotable
e7c0f98a0087ec0a20b9a94002b385d2
  type Turn = Main.Player
f2a1a335817ee576bebc737fdce61e57
  board :: Main.GameState -> Main.Board
  RecSel Main.GameState
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.GameState ->
                 case ds of wild {
                   DEFAULT -> Main.board1 Main.GameState ds1 ds2 -> ds1 }) -}
5b1def7e81f9198492a34f0103e94235
  board1 :: Main.Board
  {- Strictness: b -}
0ac2e562430b366bfd2e7df8089e38cd
  boardInitF :: Data.Matrix.Matrix Main.Piece
  {- Unfolding: (case GHC.List.$wlenAcc
                        @ [Main.Piece]
                        Main.boardInitF_xss
                        0 of ww2 { DEFAULT ->
                 case GHC.List.$wlenAcc
                        @ Main.Piece
                        Main.boardInitF1
                        0 of ww1 { DEFAULT ->
                 let {
                   dt1 :: GHC.Prim.Int# = GHC.Prim.+# 1 ww2
                 } in
                 Data.Matrix.M
                   @ Main.Piece
                   dt1
                   ww1
                   0
                   0
                   ww1
                   (GHC.ST.runSTRep
                      @ (Data.Vector.Vector Main.Piece)
                      (\ @ s1 s2 :: GHC.Prim.State# s1[OneShot] ->
                       let {
                         a :: GHC.Prim.Int# = GHC.Prim.*# dt1 ww1
                       } in
                       let {
                         $j :: GHC.Prim.Int#
                               -> (# GHC.Prim.State# s1, Data.Vector.Vector Main.Piece #)
                           {- Arity: 1, Strictness: <L,U> -}
                         = \ n# :: GHC.Prim.Int#[OneShot] ->
                           case GHC.Prim.newArray#
                                  @ Main.Piece
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s1))
                                  n#
                                  (Data.Vector.Mutable.uninitialised @ Main.Piece)
                                  s2
                                    `cast`
                                  (GHC.Prim.State#
                                     (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                               <s1>_N)))_R of ds1 { (#,#) ipv ipv1 ->
                           letrec {
                             $wa :: Data.Vector.Fusion.Stream.Monadic.SPEC
                                    -> GHC.Prim.Int#
                                    -> [Main.Piece]
                                    -> GHC.Prim.Int#
                                    -> GHC.Prim.State# s1
                                    -> (# GHC.Prim.State# s1, GHC.Types.Int #)
                               {- Arity: 5, Strictness: <S,1*U><L,U><L,1*U><L,U><L,U>,
                                  Inline: [0] -}
                             = \ w1 :: Data.Vector.Fusion.Stream.Monadic.SPEC
                                 ww :: GHC.Prim.Int#
                                 ww3 :: [Main.Piece]
                                 ww4 :: GHC.Prim.Int#
                                 w2 :: GHC.Prim.State# s1[OneShot] ->
                               case w1 of sPEC1 { DEFAULT ->
                               case GHC.Prim.tagToEnum#
                                      @ GHC.Types.Bool
                                      (GHC.Prim.<=# ww4 0) of wild1 {
                                 GHC.Types.False
                                 -> case ww3 of wild2 {
                                      [] -> (# w2, GHC.Types.I# ww #)
                                      : x xs2
                                      -> case GHC.Prim.writeArray#
                                                @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s1))
                                                @ Main.Piece
                                                ipv1
                                                ww
                                                x
                                                w2
                                                  `cast`
                                                (GHC.Prim.State#
                                                   (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                             <s1>_N)))_R of s'# { DEFAULT ->
                                         $wa
                                           Data.Vector.Fusion.Stream.Monadic.SPEC
                                           (GHC.Prim.+# ww 1)
                                           xs2
                                           (GHC.Prim.-# ww4 1)
                                           s'#
                                             `cast`
                                           (GHC.Prim.State#
                                              (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                                   <s1>_N))_R } }
                                 GHC.Types.True -> (# w2, GHC.Types.I# ww #) } }
                           } in
                           case $wa
                                  Data.Vector.Fusion.Stream.Monadic.SPEC
                                  0
                                  (GHC.Base.++
                                     @ Main.Piece
                                     Main.boardInitF1
                                     (let {
                                        lvl23 :: GHC.Types.Bool
                                        = GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# 0 ww1)
                                      } in
                                      letrec {
                                        go :: [[Main.Piece]] -> [Main.Piece]
                                          {- Arity: 1, Strictness: <S,1*U> -}
                                        = \ ds :: [[Main.Piece]] ->
                                          case ds of wild {
                                            [] -> GHC.Types.[] @ Main.Piece
                                            : y ys
                                            -> case lvl23 of wild1 {
                                                 GHC.Types.False
                                                 -> GHC.Base.++
                                                      @ Main.Piece
                                                      (GHC.Types.[] @ Main.Piece)
                                                      (go ys)
                                                 GHC.Types.True
                                                 -> GHC.Base.++
                                                      @ Main.Piece
                                                      (GHC.List.$wunsafeTake @ Main.Piece ww1 y)
                                                      (go ys) } }
                                      } in
                                      go Main.boardInitF_xss))
                                  a
                                  ipv
                                    `cast`
                                  (GHC.Prim.State#
                                     (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                          <s1>_N))_R of ds2 { (#,#) ipv5 ipv6 ->
                           case ipv6 of dt5 { GHC.Types.I# dt6 ->
                           case GHC.Prim.unsafeFreezeArray#
                                  @ (Control.Monad.Primitive.PrimState (GHC.ST.ST s1))
                                  @ Main.Piece
                                  ipv1
                                  ipv5
                                    `cast`
                                  (GHC.Prim.State#
                                     (Sym (Control.Monad.Primitive.TFCo:R:PrimStateST[0]
                                               <s1>_N)))_R of ds4 { (#,#) ipv2 ipv3 ->
                           (# ipv2
                                `cast`
                              (GHC.Prim.State#
                                 (Control.Monad.Primitive.TFCo:R:PrimStateST[0] <s1>_N))_R,
                              Data.Vector.Vector @ Main.Piece 0 dt6 ipv3 #) } } } }
                       } in
                       case GHC.Prim.tagToEnum#
                              @ GHC.Types.Bool
                              (GHC.Prim.<=# a 0) of wild2 {
                         GHC.Types.False -> $j a GHC.Types.True -> $j 0 })) } }) -}
cadfb71145f697903c14bf216e51981c
  boardInitF1 :: [Main.Piece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Piece Main.Nil Main.boardInitF2) -}
474645331c2bbd3b97bc881583ddc718
  boardInitF2 :: [Main.Piece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.: @ Main.Piece Main.Nil Main.boardInitF3) -}
ca066058fd210b4da62f9b1adacdd47d
  boardInitF3 :: [Main.Piece]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ Main.Piece
                   Main.Nil
                   (GHC.Types.[] @ Main.Piece)) -}
10c930018c335fc24460074e3dc66b45
  boardInitF4 :: [[Main.Piece]]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [Main.Piece]
                   Main.boardInitF1
                   (GHC.Types.[] @ [Main.Piece])) -}
e9d03d528e21de9649bf47b7ea9bbc76
  boardInitF_xss :: [[Main.Piece]]
  {- HasNoCafRefs, Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ [Main.Piece]
                   Main.boardInitF1
                   Main.boardInitF4) -}
42efad51854c58c6597c0d5c848c7568
  currentTurn :: Main.GameState -> Main.Turn
  RecSel Main.GameState
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.GameState ->
                 case ds of wild {
                   DEFAULT -> Main.currentTurn1 Main.GameState ds1 ds2 -> ds2 }) -}
b897371090a7f4c52c99fa13b86f81a2
  currentTurn1 :: Main.Turn
  {- Strictness: b -}
9015903f3accf802213ec885ae476356
  e :: GHC.Num.Num t => (t, t1) -> (t, t1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ t @ t1 $dNum :: GHC.Num.Num t ds :: (t, t1) ->
                 case ds of wild { (,) x y ->
                 (GHC.Num.+ @ t $dNum x (GHC.Num.fromInteger @ t $dNum Main.e1),
                  y) }) -}
23e214d22dbf63a5802f9b8048da77f3
  e1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 1) -}
19295738ee2cba9c9af34bb64d288f4b
  fromString :: [GHC.Types.Char] -> Main.Move
  {- Arity: 1, Strictness: <L,U>m, Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ w1 :: [GHC.Types.Char] ->
                 case Main.$wfromString w1 of ww { (##) ww1 -> Main.Move ww1 }) -}
5fe97a671e727a942f520533cb4066a4
  fromString1 :: [GHC.Types.Char] -> [[GHC.Types.Char]]
  {- Unfolding: (Data.List.Split.Internals.splitOn
                   @ GHC.Types.Char
                   GHC.Classes.$fEqChar
                   Main.fromString2) -}
37f66e9ff049ba04aab20c87f147a270
  fromString2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ","#) -}
0e11fd47c7a200456d122ab1a1064d1d
  fromString3 :: GHC.Base.String -> GHC.Types.Int
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: (\ s1 :: GHC.Base.String ->
                 case Text.Read.readEither6
                        @ GHC.Types.Int
                        (Text.ParserCombinators.ReadP.run
                           @ GHC.Types.Int
                           Main.fromString6
                           s1) of wild {
                   [] -> Main.fromString5
                   : x ds
                   -> case ds of wild1 {
                        [] -> x : ipv ipv1 -> Main.fromString4 } }) -}
7e78a4d9f7052273fa1ec63f887a30b8
  fromString4 :: GHC.Types.Int
  {- Strictness: b -}
cbbc78807d1ba9882331a5182529f516
  fromString5 :: GHC.Types.Int
  {- Strictness: b -}
c190071ebc93f39f565dab3f7b152990
  fromString6 :: Text.ParserCombinators.ReadP.P GHC.Types.Int
  {- Unfolding: ((GHC.Read.$fReadInt3
                    GHC.Read.$fReadInt_$sconvertInt
                    Text.ParserCombinators.ReadPrec.minPrec)
                   `cast`
                 (Text.ParserCombinators.ReadP.NTCo:ReadP[0] <GHC.Types.Int>_R)
                   @ GHC.Types.Int
                   (Text.Read.readEither5 @ GHC.Types.Int)) -}
48b8d92a7d675543cf2de2e99e75ad6b
  getDiags :: Data.Matrix.Matrix t -> [[t]]
  {- Arity: 1, Strictness: <S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (1, True, False)
                (\ @ t w1 :: Data.Matrix.Matrix t ->
                 case w1 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$wgetDiags @ t ww1 ww2 ww3 ww4 ww5 ww6 }) -}
4827b07494d6cab1eae1325906cea83d
  getMove :: Main.GameState -> GHC.Types.IO Main.Move
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.getMove1
                  `cast`
                (<Main.GameState>_R
                 ->_R Sym (GHC.Types.NTCo:IO[0] <Main.Move>_R)) -}
6be6f11b627049fee44681990df407a9
  getMove1 ::
    Main.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, Main.Move #)
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ gs :: Main.GameState
                   s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Player "#
                           (case gs of wild {
                              DEFAULT -> case Main.currentTurn1 ret_ty [GHC.Types.Char] of {}
                              Main.GameState ds ds1
                              -> case ds1 of wild1 {
                                   Main.PX -> Main.getMove4 Main.PO -> Main.getMove2 } }))
                        GHC.Types.True
                        s1 of ds1 { (#,#) ipv ipv1 ->
                 case GHC.IO.Handle.Internals.wantReadableHandle_1
                        @ GHC.Base.String
                        GHC.IO.Handle.Text.hGetLine4
                        GHC.IO.Handle.FD.stdin
                        GHC.IO.Handle.Text.hGetLine2
                          `cast`
                        (<GHC.IO.Handle.Types.Handle__>_R
                         ->_R Sym (GHC.Types.NTCo:IO[0] <GHC.Base.String>_R))
                        ipv of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2, Main.fromString ipv3 #) } }) -}
eb01401792f331164eeec8a42cebf1ea
  getMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState5
                   Main.getMove3) -}
135808afc4b5cc3d0a68b9d730fdf5e1
  getMove3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "'s turn.Please enter a move:"#) -}
7c67328fcfe0380c236e6a9043cd6704
  getMove4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState7
                   Main.getMove3) -}
26f1737e66c3c13e56e78d7d534cc7a2
  iToC ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w1 :: GHC.Types.Int w2 :: GHC.Types.Int w3 :: GHC.Types.Int ->
                 case Main.$wiToC w1 w2 w3 of ww { (#,#) ww1 ww2 -> (ww1, ww2) }) -}
623346a2fcea54bb958f6ff80723341c
  inBounds ::
    (GHC.Num.Num a, GHC.Num.Num a1, GHC.Classes.Ord a,
     GHC.Classes.Ord a1) =>
    (a, a1) -> GHC.Types.Bool
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,U(A,A,A,A,A,A,C(U))><L,U(A,A,A,A,A,A,C(U))><S(LLLC(C(S))LLLL),U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><L,U(A,A,A,1*C1(C1(U)),1*C1(C1(U)),A,A,A)><S,1*U(U,U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (5, True, False)
                (\ @ a
                   @ a1
                   w1 :: GHC.Num.Num a
                   w2 :: GHC.Num.Num a1
                   w3 :: GHC.Classes.Ord a
                   w4 :: GHC.Classes.Ord a1
                   w5 :: (a, a1) ->
                 case w5 of ww { (,) ww1 ww2 ->
                 Main.$winBounds @ a @ a1 w1 w2 w3 w4 ww1 ww2 }) -}
5d32b46ee62b2ad28cf24d62cc556c85
  inBounds1 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 0) -}
f9e82ff6113ef75e514e2df45c1fba3d
  inBounds2 :: GHC.Integer.Type.Integer
  {- HasNoCafRefs, Unfolding: (__integer 3) -}
c96561f863ca2d2f2dd29d10018b5c66
  inCol ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,1*U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w1 :: GHC.Types.Int w2 :: Main.Player w3 :: Main.Board ->
                 case w3 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winCol w1 w2 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
a185a6ffa14a56d3df443a98ecda7d11
  inDiag ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, Strictness: <L,U(U)><L,U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w1 :: GHC.Types.Int w2 :: Main.Player w3 :: Main.Board ->
                 case w3 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winDiag w1 w2 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
944d3719431287e08c05961acd7fa189
  inRow ::
    GHC.Types.Int -> Main.Player -> Main.Board -> GHC.Types.Bool
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(U)><L,U><S,1*U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w1 :: GHC.Types.Int w2 :: Main.Player w3 :: Main.Board ->
                 case w3 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$winRow w1 w2 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
37b698934257e839275a94c6bab14bd1
  isEmpty ::
    (GHC.Types.Int, GHC.Types.Int) -> Main.GameState -> GHC.Types.Bool
  {- Arity: 2, Strictness: <S(SS),1*U(1*U(U),U(U))><S,1*U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w1 :: (GHC.Types.Int, GHC.Types.Int) w2 :: Main.GameState ->
                 case w1 of ww { (,) ww1 ww2 ->
                 case ww1 of ww3 { GHC.Types.I# ww4 ->
                 case ww2 of ww5 { GHC.Types.I# ww6 ->
                 Main.$wisEmpty ww4 ww6 w2 } } }) -}
118983815e720b21606cfe9f17ad7634
  isEmpty1 ::
    GHC.Prim.Int#
    -> GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Prim.Int# -> Main.Piece
  {- Arity: 4, Strictness: <L,U><L,U><L,U><L,U>b -}
becfc7b1b0ccdf893c533e96af85920a
  isFull :: Data.Matrix.Matrix Main.Piece -> GHC.Types.Bool
  {- Arity: 1, Strictness: <S,U(U,U,U,U,U,U(U,A,U))>,
     Unfolding: InlineRule (1, True, False)
                (\ b :: Data.Matrix.Matrix Main.Piece ->
                 Main.mfold
                   @ Main.Piece
                   @ GHC.Types.Bool
                   Main.isFull1
                   GHC.Types.True
                   b) -}
27199e1a32266b3e3ea0b77e989051ec
  isFull1 ::
    ((GHC.Types.Int, GHC.Types.Int), Main.Piece, GHC.Types.Bool)
    -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SSL),1*U(1*H,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: ((GHC.Types.Int, GHC.Types.Int),
                          Main.Piece,
                          GHC.Types.Bool) ->
                 case ds of wild { (,,) ds1 piece acc ->
                 case ds1 of wild1 { (,) i j ->
                 case piece of wild2 {
                   DEFAULT -> acc Main.Nil -> GHC.Types.False } } }) -}
2b32eedb5dce28e814c17f0a7c54852f
  isValid :: Main.GameState -> Main.Move -> GHC.Types.Bool
  {- Arity: 2, Strictness: <L,1*U><S(S(SL)),1*U(1*U(1*U(U),1*U(U)))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w1 :: Main.GameState w2 :: Main.Move ->
                 case w2 of ww { Main.Move ww1 ->
                 case ww1 of ww2 { (,) ww3 ww4 ->
                 case ww3 of ww5 { GHC.Types.I# ww6 ->
                 Main.$wisValid w1 ww6 ww4 } } }) -}
0b01ab912a9150549937adbdd209f272
  lfoldi ::
    (GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int))
    -> GHC.Types.Int
    -> (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> [a]
    -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(U)><L,U(U)><L,C(U)><L,1*U><S,1*U> -}
7f4a70786620d3230d6d64d35fc86690
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
84476fbf9d21b06ba6aa788511b84628
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case Main.main2
                        (Main.GameState Main.boardInitF Main.PX)
                        s1 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
4be1b6c7fcbdb26e3abc817e6a109c6f
  main2 ::
    Main.GameState
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,U><L,U> -}
e100ef099a16b959a3f5a72a45dc7039
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R))) -}
be009e1a928b6e3085c0218bd1675c90
  mfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b -> Data.Matrix.Matrix a -> b
  {- Arity: 3, Strictness: <L,C(U)><L,1*U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   w1 :: ((GHC.Types.Int, GHC.Types.Int), a, b) -> b
                   w2 :: b
                   w3 :: Data.Matrix.Matrix a ->
                 case w3 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Main.$wmfold @ a @ b w1 w2 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
24bd0c61c60343fcef11e05e5993ff8b
  n :: GHC.Num.Num t1 => (t, t1) -> (t, t1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ t @ t1 $dNum :: GHC.Num.Num t1 ds :: (t, t1) ->
                 case ds of wild { (,) x y ->
                 (x,
                  GHC.Num.+
                    @ t1
                    $dNum
                    y
                    (GHC.Num.fromInteger @ t1 $dNum Main.e1)) }) -}
ab1f6a0940c43998410cd6f9f4b57228
  ne :: (GHC.Num.Num t, GHC.Num.Num t1) => (t, t1) -> (t, t1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   w1 :: GHC.Num.Num t
                   w2 :: GHC.Num.Num t1
                   w3 :: (t, t1) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 (GHC.Num.+ @ t w1 ww1 (GHC.Num.fromInteger @ t w1 Main.e1),
                  GHC.Num.+ @ t1 w2 ww2 (GHC.Num.fromInteger @ t1 w2 Main.e1)) }) -}
b7d986fe127fe014ba6bd2377a3ffae5
  nw :: (GHC.Num.Num t, GHC.Num.Num t1) => (t, t1) -> (t, t1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   w1 :: GHC.Num.Num t
                   w2 :: GHC.Num.Num t1
                   w3 :: (t, t1) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 (GHC.Num.- @ t w1 ww1 (GHC.Num.fromInteger @ t w1 Main.e1),
                  GHC.Num.+ @ t1 w2 ww2 (GHC.Num.fromInteger @ t1 w2 Main.e1)) }) -}
717cb2b907635648a9d39655d36ba543
  otherPlayer :: Main.Player -> Main.Player
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Player ->
                 case ds of wild { Main.PX -> Main.PO Main.PO -> Main.PX }) -}
4b59d6564e264bb2c912740777f55ee8
  outcome ::
    Main.GameState -> Main.Move -> (Main.GameState, GHC.Types.Int)
  {- Arity: 2, Strictness: <S,U><S,1*U(1*U(1*U(U),1*U(U)))>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w1 :: Main.GameState w2 :: Main.Move ->
                 case w2 of ww { Main.Move ww1 ->
                 case Main.$woutcome w1 ww1 of ww2 { (#,#) ww3 ww4 ->
                 (ww3, ww4) } }) -}
046686f4d1847cb3a772153a0c96e802
  pieceToPlayer :: Main.Piece -> Main.Player
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Piece ->
                 case ds of wild {
                   Main.X -> Main.PX
                   Main.O -> Main.PO
                   Main.Nil -> Main.pieceToPlayer1 }) -}
2590449ffad179a87004ea020fc193cd
  pieceToPlayer1 :: Main.Player
  {- Strictness: b -}
f2eb96289d445fa99c5d7e73f9c33d25
  playGame :: Main.GameState -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main2
                  `cast`
                (<Main.GameState>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
5269cdf011d70889b8b1a4320c157808
  playerToPiece :: Main.Player -> Main.Piece
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Main.Player ->
                 case ds of wild { Main.PX -> Main.X Main.PO -> Main.O }) -}
63f3ffeea55ba064e09d5b8ab65ce101
  possMoves :: Main.GameState -> [Main.Move]
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ game :: Main.GameState ->
                 case game of wild {
                   DEFAULT -> case Main.board1 ret_ty [Main.Move] of {}
                   Main.GameState ds ds1
                   -> Main.mfold
                        @ Main.Piece
                        @ [Main.Move]
                        Main.possMoves1
                        (GHC.Types.[] @ Main.Move)
                        ds }) -}
caa7e6b1e764b660945b06c8e5028617
  possMoves1 ::
    ((GHC.Types.Int, GHC.Types.Int), Main.Piece, [Main.Move])
    -> [Main.Move]
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(SSL),1*U(1*U(U,U),1*U,U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: ((GHC.Types.Int, GHC.Types.Int),
                          Main.Piece,
                          [Main.Move]) ->
                 case ds of wild { (,,) ds1 piece acc ->
                 case ds1 of wild1 { (,) i j ->
                 case piece of wild2 {
                   DEFAULT -> acc
                   Main.Nil
                   -> GHC.Types.: @ Main.Move (Main.Move (i, j)) acc } } }) -}
e508934ea21f671dd9b84cddb424b18e
  s :: GHC.Num.Num t1 => (t, t1) -> (t, t1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ t @ t1 $dNum :: GHC.Num.Num t1 ds :: (t, t1) ->
                 case ds of wild { (,) x y ->
                 (x,
                  GHC.Num.-
                    @ t1
                    $dNum
                    y
                    (GHC.Num.fromInteger @ t1 $dNum Main.e1)) }) -}
89d0a40359ccaf9f6e13f9dcf0f3b2e6
  se :: (GHC.Num.Num t, GHC.Num.Num t1) => (t, t1) -> (t, t1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(1*C1(C1(U)),A,A,A,A,A,1*C1(U))><L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   w1 :: GHC.Num.Num t
                   w2 :: GHC.Num.Num t1
                   w3 :: (t, t1) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 (GHC.Num.+ @ t w1 ww1 (GHC.Num.fromInteger @ t w1 Main.e1),
                  GHC.Num.- @ t1 w2 ww2 (GHC.Num.fromInteger @ t1 w2 Main.e1)) }) -}
df9b4a6482edbf267fe7543257492f63
  size :: (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer)
  {- HasNoCafRefs, Strictness: m,
     Unfolding: ((Main.inBounds2, Main.inBounds2)) -}
356e1d6c62c2b899c0f740f8692d0979
  sw :: (GHC.Num.Num t, GHC.Num.Num t1) => (t, t1) -> (t, t1)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   w1 :: GHC.Num.Num t
                   w2 :: GHC.Num.Num t1
                   w3 :: (t, t1) ->
                 case w3 of ww { (,) ww1 ww2 ->
                 (GHC.Num.- @ t w1 ww1 (GHC.Num.fromInteger @ t w1 Main.e1),
                  GHC.Num.- @ t1 w2 ww2 (GHC.Num.fromInteger @ t1 w2 Main.e1)) }) -}
71dab202b62c9e850d917ed4f671a7c6
  tie :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.tie1 `cast` (Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
d2c83c422bc7d73a0715b7e3dc15d9b1
  tie1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        Main.tie2
                        GHC.Types.True
                        s1 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
b377a1833b3a98befe2ea3b5fe927a33
  tie2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   "The game has ended in a tie."#) -}
d6db835169d98a1b6e63072fae2d6953
  turn :: Main.Player
  {- HasNoCafRefs, Unfolding: InlineRule (0, True, True) Main.PX -}
64d4e52895e58466d56d99a48337afcd
  w :: GHC.Num.Num t => (t, t1) -> (t, t1)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <L,U(A,1*C1(C1(U)),A,A,A,A,1*C1(U))><S,1*U(U,U)>m,
     Unfolding: InlineRule (2, True, False)
                (\ @ t @ t1 $dNum :: GHC.Num.Num t ds :: (t, t1) ->
                 case ds of wild { (,) x y ->
                 (GHC.Num.- @ t $dNum x (GHC.Num.fromInteger @ t $dNum Main.e1),
                  y) }) -}
fd0af7221b3bf95ffcc29515cda5a228
  won :: Main.Player -> GHC.Types.IO ()
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.won1
                  `cast`
                (<Main.Player>_R ->_R Sym (GHC.Types.NTCo:IO[0] <()>_R)) -}
e26c2019256fe91e5910f89b271db06b
  won1 ::
    Main.Player
    -> GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 2, Strictness: <L,1*U><L,U>,
     Unfolding: (\ p :: Main.Player
                   s1 :: GHC.Prim.State# GHC.Prim.RealWorld[OneShot] ->
                 case GHC.IO.Handle.Text.hPutStr2
                        GHC.IO.Handle.FD.stdout
                        (GHC.CString.unpackAppendCString#
                           "Player "#
                           (case p of wild { Main.PX -> Main.won4 Main.PO -> Main.won2 }))
                        GHC.Types.True
                        s1 of ds1 { (#,#) ipv ipv1 ->
                 (# ipv, GHC.Tuple.() #) }) -}
cb7086b7ff6f63af6bcc13cf04f373ff
  won2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState5
                   Main.won3) -}
9813d1c3398962e835d4c2d15783178c
  won3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# " has won!"#) -}
43c5fb605ae25843dc571b4c6c3bc340
  won4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowGameState7
                   Main.won3) -}
32e05893ed19f81e188ce44d3ac0f086
  xor :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: GHC.Types.Bool ds1 :: GHC.Types.Bool ->
                 case ds of wild {
                   GHC.Types.False -> ds1
                   GHC.Types.True
                   -> case ds1 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
instance GHC.Classes.Eq [Main.GameState] = Main.$fEqGameState
instance GHC.Classes.Eq [Main.Move] = Main.$fEqMove
instance GHC.Classes.Eq [Main.Piece] = Main.$fEqPiece
instance GHC.Classes.Eq [Main.Player] = Main.$fEqPlayer
instance GHC.Show.Show [Main.GameState] = Main.$fShowGameState
instance GHC.Show.Show [Main.Move] = Main.$fShowMove
instance GHC.Show.Show [Main.Piece] = Main.$fShowPiece
instance GHC.Show.Show [Main.Player] = Main.$fShowPlayer
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

