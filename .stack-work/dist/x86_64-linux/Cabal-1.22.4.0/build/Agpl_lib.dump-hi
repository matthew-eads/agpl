
==================== FINAL INTERFACE ====================
2015-11-18 04:26:36.444154 UTC

interface Agpl_ARbgTy7wgrRJtlloTDRArE:Agpl_lib 7102
  interface hash: f63a94f9156e4b600cb595cdf0c46106
  ABI hash: 4f22e5a218dc449f925297d17c5d49b8
  export-list hash: cbc4f0da04576d1f4ce08635ff1875e5
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b66090cf17f4cc751c68c8377d24c28f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Agpl_lib.iToC
  Agpl_lib.lfoldi
  Agpl_lib.mfold
  Agpl_lib.xor
module dependencies: Agpl_syntax
package dependencies: array-0.5.1.0@array_E0sTtauuKsGDLZoT7lTbgZ
                      base-4.8.1.0 deepseq-1.4.1.1@deeps_LbCWUlehDDeLxurARKDH5o
                      ghc-prim-0.4.0.0 integer-gmp-1.0.0.0
                      loop-0.2.0@loop_804hhNK9LSY6FgJQJ2wKvV
                      matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl
                      primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb
                      template-haskell-2.10.0.0
                      transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X
                      vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
         transformers-0.4.2.0@trans_3eG64VdP2vzGjP6wJiCp5X:Control.Monad.Trans.Error
         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector.Fusion.Stream
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Functor.Identity
                         base-4.8.1.0:Data.Monoid base-4.8.1.0:Data.Type.Equality
                         base-4.8.1.0:Data.Void base-4.8.1.0:GHC.Exts
                         base-4.8.1.0:GHC.Generics
                         primitive-0.6.1.0@primi_5Jnw7oEuYtM9dmKXelGXVb:Control.Monad.Primitive
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
                         vector-0.10.12.3@vecto_JrQt7SYKOQF2foH4Ugm8MQ:Data.Vector
import  -/  Agpl_syntax 6e693080fd2e3401d0bcece3ff793395
  exports: f49372cede7d1194d9354766daf6df62
import  -/  base-4.8.1.0:Data.Foldable 2e5acb797cfda6b3b7fabd7052abe290
import  -/  base-4.8.1.0:GHC.Num 9f42750c866f5832ca565146bd660c60
import  -/  base-4.8.1.0:GHC.Real 4c3b525ecbd4d62bb287aec36d4c2f0d
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  matrix-0.3.4.4@matri_AtloKBQ0sJh0fVbfwJdXPl:Data.Matrix ccc9b2eeba0ed526bed77e0610fa9537
99240c663811380bc636c7e79ab704ff
  $wiToC ::
    GHC.Types.Int
    -> GHC.Types.Int
    -> GHC.Types.Int
    -> (# GHC.Types.Int, GHC.Types.Int #)
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><L,U(U)>, Inline: [0],
     Unfolding: (\ w :: GHC.Types.Int
                   w1 :: GHC.Types.Int
                   w2 :: GHC.Types.Int ->
                 (# case w2 of wild { GHC.Types.I# i ->
                    case w of wild1 { GHC.Types.I# i1 ->
                    case GHC.Prim./##
                           (GHC.Prim.int2Double# i)
                           (GHC.Prim.int2Double# i1) of wild2 { DEFAULT ->
                    let {
                      n :: GHC.Prim.Int# = GHC.Prim.double2Int# wild2
                    } in
                    case GHC.Prim.tagToEnum#
                           @ GHC.Types.Bool
                           (GHC.Prim.<## (GHC.Prim.int2Double# n) wild2) of wild3 {
                      GHC.Types.False -> GHC.Types.I# n
                      GHC.Types.True -> GHC.Types.I# (GHC.Prim.+# n 1) } } } },
                    case w1 of ww { GHC.Types.I# ww1 ->
                    case ww1 of wild {
                      DEFAULT
                      -> case w2 of wild1 { GHC.Types.I# x ->
                         case GHC.Classes.modInt# x wild of ww2 {
                           DEFAULT -> GHC.Types.I# ww2 0 -> ww } }
                      (-1) -> ww
                      0
                      -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} } } #)) -}
a93b06dfafcac1f33989729162e8b086
  $wmfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> Data.Vector.Vector a
    -> b
  {- Arity: 8,
     Strictness: <L,C(U)><L,1*U><L,U><L,U><L,U><L,U><L,U><L,U(U,A,U)>,
     Inline: [0],
     Unfolding: (\ @ a
                   @ b
                   w :: ((GHC.Types.Int, GHC.Types.Int), a, b) -> b
                   w1 :: b
                   ww :: GHC.Prim.Int#
                   ww1 :: GHC.Prim.Int#
                   ww2 :: GHC.Prim.Int#
                   ww3 :: GHC.Prim.Int#
                   ww4 :: GHC.Prim.Int#
                   ww5 :: Data.Vector.Vector a ->
                 let {
                   l :: [a] = Data.Matrix.$wtoList @ a ww ww1 ww2 ww3 ww4 ww5
                 } in
                 Agpl_lib.lfoldi
                   @ a
                   @ b
                   (let {
                      w2 :: GHC.Types.Int = GHC.Types.I# ww1
                    } in
                    \ w3 :: GHC.Types.Int ->
                    (case w3 of wild { GHC.Types.I# i ->
                     case GHC.Prim./##
                            (GHC.Prim.int2Double# i)
                            (GHC.Prim.int2Double# ww) of wild2 { DEFAULT ->
                     let {
                       n :: GHC.Prim.Int# = GHC.Prim.double2Int# wild2
                     } in
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<## (GHC.Prim.int2Double# n) wild2) of wild1 {
                       GHC.Types.False -> GHC.Types.I# n
                       GHC.Types.True -> GHC.Types.I# (GHC.Prim.+# n 1) } } },
                     case ww1 of wild {
                       DEFAULT
                       -> case w3 of wild1 { GHC.Types.I# x ->
                          case GHC.Classes.modInt# x wild of ww6 {
                            DEFAULT -> GHC.Types.I# ww6 0 -> w2 } }
                       (-1) -> w2
                       0 -> case GHC.Real.divZeroError ret_ty GHC.Types.Int of {} }))
                   (case GHC.List.$wlenAcc @ a l 0 of ww6 { DEFAULT ->
                    GHC.Types.I# ww6 })
                   w
                   w1
                   l) -}
86fc03b69c595984e553b4fc893deca6
  iToC ::
    GHC.Types.Int
    -> GHC.Types.Int -> GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int)
  {- Arity: 3, Strictness: <L,1*U(U)><L,1*U(U)><L,U(U)>m,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int w1 :: GHC.Types.Int w2 :: GHC.Types.Int ->
                 case Agpl_lib.$wiToC w w1 w2 of ww { (#,#) ww1 ww2 ->
                 (ww1, ww2) }) -}
da0ce3ca7bcdc1c416807ec9fdd46e6c
  lfoldi ::
    (GHC.Types.Int -> (GHC.Types.Int, GHC.Types.Int))
    -> GHC.Types.Int
    -> (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b
    -> [a]
    -> b
  {- Arity: 5, HasNoCafRefs,
     Strictness: <L,C(U)><L,U(U)><L,C(U)><L,1*U><S,1*U> -}
997b8dfccfd7d46158b7e5573e564de5
  mfold ::
    (((GHC.Types.Int, GHC.Types.Int), a, b) -> b)
    -> b -> Data.Matrix.Matrix a -> b
  {- Arity: 3, Strictness: <L,C(U)><L,1*U><S,U(U,U,U,U,U,U(U,A,U))>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   @ b
                   w :: ((GHC.Types.Int, GHC.Types.Int), a, b) -> b
                   w1 :: b
                   w2 :: Data.Matrix.Matrix a ->
                 case w2 of ww { Data.Matrix.M ww1 ww2 ww3 ww4 ww5 ww6 ->
                 Agpl_lib.$wmfold @ a @ b w w1 ww1 ww2 ww3 ww4 ww5 ww6 }) -}
84d07d3ba848cbdbca9a4aba6df8b3f0
  xor :: GHC.Types.Bool -> GHC.Types.Bool -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ ds :: GHC.Types.Bool ds1 :: GHC.Types.Bool ->
                 case ds of wild {
                   GHC.Types.False -> ds1
                   GHC.Types.True
                   -> case ds1 of wild1 {
                        GHC.Types.False -> GHC.Types.True
                        GHC.Types.True -> GHC.Types.False } }) -}
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

