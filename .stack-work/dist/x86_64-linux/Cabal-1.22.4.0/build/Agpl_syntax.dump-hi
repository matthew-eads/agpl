
==================== FINAL INTERFACE ====================
2015-11-27 19:33:23.707309 UTC

interface Agpl_01dT6SXeKAJ0RDOHBmKHBU:Agpl_syntax 7102
  interface hash: fcbf88d63530739fa6a620f29db9e750
  ABI hash: 6e54cfe657c092e4f217d654caacdd85
  export-list hash: f0ee46e9f2fb04531fa8549554a62c0b
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: b66090cf17f4cc751c68c8377d24c28f
  sig of: Nothing
  used TH splices: False
  where
exports:
  Agpl_syntax.Board{Agpl_syntax.Array Agpl_syntax.Board Agpl_syntax.Matrix}
  Agpl_syntax.CustomDataType{Agpl_syntax.CustomDataType}
  Agpl_syntax.FromString{Agpl_syntax.FromString}
  Agpl_syntax.Game{Agpl_syntax.Game Agpl_syntax.NIL}
  Agpl_syntax.GameID
  Agpl_syntax.GameState{Agpl_syntax.GameState Agpl_syntax.board Agpl_syntax.hand Agpl_syntax.piece Agpl_syntax.turn}
  Agpl_syntax.InitState{Agpl_syntax.InitState Agpl_syntax.boardInit Agpl_syntax.turnInit}
  Agpl_syntax.IsValidFun{Agpl_syntax.IsValidFun}
  Agpl_syntax.Move{Agpl_syntax.Move}
  Agpl_syntax.OutcomeFun{Agpl_syntax.CustOutcomeFun Agpl_syntax.OutcomeFun Agpl_syntax.elsecon Agpl_syntax.tiecon Agpl_syntax.wincon}
  Agpl_syntax.Player{Agpl_syntax.Player}
  Agpl_syntax.PossMovesFun{Agpl_syntax.PMNil Agpl_syntax.PossMovesFun}
module dependencies:
package dependencies: base-4.8.1.0 ghc-prim-0.4.0.0
                      integer-gmp-1.0.0.0 template-haskell-2.10.0.0
orphans: base-4.8.1.0:GHC.Base base-4.8.1.0:GHC.Float
family instance modules: base-4.8.1.0:Control.Applicative
                         base-4.8.1.0:Data.Either base-4.8.1.0:Data.Monoid
                         base-4.8.1.0:Data.Type.Equality base-4.8.1.0:GHC.Generics
                         template-haskell-2.10.0.0:Language.Haskell.TH.Syntax
import  -/  base-4.8.1.0:GHC.Base 1db77db5dae73d8c424c85b09fbadb89
import  -/  base-4.8.1.0:GHC.Show b8c65ca3124f92a166c9f05120382442
import  -/  base-4.8.1.0:Prelude 518f762991bc287d78f21a73c974da1f
import  -/  ghc-prim-0.4.0.0:GHC.Classes e1f4ff80f7b5262008a595d29986fb18
import  -/  integer-gmp-1.0.0.0:GHC.Integer.Type bf9b4d13b1dbe96a83786d2e47d2e8ca
import  -/  template-haskell-2.10.0.0:Language.Haskell.TH.Syntax afcf64bad3773d231089a8ce432131ab
c75d27e513d9668ca9ff65ae62b51e2d
  $fShowBoard :: GHC.Show.Show Agpl_syntax.Board
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.Board
                  Agpl_syntax.$fShowBoard_$cshowsPrec
                  Agpl_syntax.$fShowBoard_$cshow
                  Agpl_syntax.$fShowBoard_$cshowList -}
c75d27e513d9668ca9ff65ae62b51e2d
  $fShowBoard1 :: Agpl_syntax.Board -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.Board ->
                 Agpl_syntax.$w$cshowsPrec 0 w) -}
99582f8c4ef298fd0ef98e4a64438518
  $fShowBoard2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Board "#) -}
c49dd1cc80041933d306bea0bfc55e88
  $fShowBoard3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Array "#) -}
b7c58d4e78f7d2cf5e325c715a7dc8bc
  $fShowBoard4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Matrix "#) -}
b11b83d1ca241cf6f5c3585323299465
  $fShowBoard5 :: [GHC.Types.Char]
  {- HasNoCafRefs,
     Unfolding: (GHC.Types.:
                   @ GHC.Types.Char
                   GHC.Show.shows8
                   (GHC.Types.[] @ GHC.Types.Char)) -}
c75d27e513d9668ca9ff65ae62b51e2d
  $fShowBoard_$cshow :: Agpl_syntax.Board -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: Agpl_syntax.Board ->
                 case x of wild {
                   Agpl_syntax.Matrix b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Agpl_syntax.$fShowBoard4
                        (case b1 of ww { (,) ww1 ww2 ->
                         GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows9
                           (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                              0
                              ww1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showList__1
                                 (GHC.List.foldr1_$sfoldr1
                                    @ (GHC.Base.String -> GHC.Base.String)
                                    GHC.Show.$fShow(,)1
                                    (\ w4 :: GHC.Base.String ->
                                     case ww2 of ww4 { (,) ww5 ww6 ->
                                     GHC.Types.:
                                       @ GHC.Types.Char
                                       GHC.Show.shows9
                                       (case GHC.Show.$w$cshowsPrec1
                                               0
                                               ww5
                                               (GHC.Types.:
                                                  @ GHC.Types.Char
                                                  GHC.Show.showList__1
                                                  (GHC.List.foldr1_$sfoldr1
                                                     @ (GHC.Base.String -> GHC.Base.String)
                                                     GHC.Show.$fShow(,)1
                                                     (\ w2 :: GHC.Base.String ->
                                                      case GHC.Show.$w$cshowsPrec1
                                                             0
                                                             ww6
                                                             w2 of ww7 { (#,#) ww3 ww8 ->
                                                      GHC.Types.: @ GHC.Types.Char ww3 ww8 })
                                                     (GHC.Types.[] @ GHC.Show.ShowS)
                                                     (GHC.Types.:
                                                        @ GHC.Types.Char
                                                        GHC.Show.shows8
                                                        w4))) of ww7 { (#,#) ww3 ww8 ->
                                        GHC.Types.: @ GHC.Types.Char ww3 ww8 }) })
                                    (GHC.Types.[] @ GHC.Show.ShowS)
                                    Agpl_syntax.$fShowBoard5))) })
                   Agpl_syntax.Array b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Agpl_syntax.$fShowBoard3
                        (case b1 of ww { (,) ww1 ww2 ->
                         GHC.Types.:
                           @ GHC.Types.Char
                           GHC.Show.shows9
                           (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                              0
                              ww1
                              (GHC.Types.:
                                 @ GHC.Types.Char
                                 GHC.Show.showList__1
                                 (GHC.List.foldr1_$sfoldr1
                                    @ (GHC.Base.String -> GHC.Base.String)
                                    GHC.Show.$fShow(,)1
                                    (\ w2 :: GHC.Base.String ->
                                     case GHC.Show.$w$cshowsPrec1 0 ww2 w2 of ww4 { (#,#) ww3 ww5 ->
                                     GHC.Types.: @ GHC.Types.Char ww3 ww5 })
                                    (GHC.Types.[] @ GHC.Show.ShowS)
                                    Agpl_syntax.$fShowBoard5))) })
                   Agpl_syntax.Board b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Agpl_syntax.$fShowBoard2
                        (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                           11
                           b1
                           (GHC.Types.[] @ GHC.Types.Char)) }) -}
c75d27e513d9668ca9ff65ae62b51e2d
  $fShowBoard_$cshowList :: [Agpl_syntax.Board] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.Board
                   Agpl_syntax.$fShowBoard1) -}
c75d27e513d9668ca9ff65ae62b51e2d
  $fShowBoard_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.Board -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.Board ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Agpl_syntax.$w$cshowsPrec ww1 w1 }) -}
ce25e86f36dd09be7a3f1a633a33205a
  $fShowCustomDataType :: GHC.Show.Show Agpl_syntax.CustomDataType
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.CustomDataType
                  Agpl_syntax.$fShowCustomDataType_$cshowsPrec
                  Agpl_syntax.$fShowCustomDataType_$cshow
                  Agpl_syntax.$fShowCustomDataType_$cshowList -}
ce25e86f36dd09be7a3f1a633a33205a
  $fShowCustomDataType1 ::
    Agpl_syntax.CustomDataType -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.CustomDataType ->
                 case w of ww { Agpl_syntax.CustomDataType ww1 ->
                 Agpl_syntax.$w$cshowsPrec1 0 ww1 }) -}
93dca0d4b2541a836bad88bd5a86586e
  $fShowCustomDataType2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CustomDataType "#) -}
ce25e86f36dd09be7a3f1a633a33205a
  $fShowCustomDataType_$cshow ::
    Agpl_syntax.CustomDataType -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.CustomDataType ->
                 case x of wild { Agpl_syntax.CustomDataType b1 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      Agpl_syntax.$fShowCustomDataType2)
                   (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                      11
                      b1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
ce25e86f36dd09be7a3f1a633a33205a
  $fShowCustomDataType_$cshowList ::
    [Agpl_syntax.CustomDataType] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.CustomDataType
                   Agpl_syntax.$fShowCustomDataType1) -}
ce25e86f36dd09be7a3f1a633a33205a
  $fShowCustomDataType_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.CustomDataType -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.CustomDataType ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.CustomDataType ww3 ->
                 Agpl_syntax.$w$cshowsPrec1 ww1 ww3 } }) -}
9de1f1c5c56bc150313b6f981a05186a
  $fShowFromString :: GHC.Show.Show Agpl_syntax.FromString
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.FromString
                  Agpl_syntax.$fShowFromString_$cshowsPrec
                  Agpl_syntax.$fShowFromString_$cshow
                  Agpl_syntax.$fShowFromString_$cshowList -}
9de1f1c5c56bc150313b6f981a05186a
  $fShowFromString1 :: Agpl_syntax.FromString -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.FromString ->
                 case w of ww { Agpl_syntax.FromString ww1 ->
                 Agpl_syntax.$w$cshowsPrec2 0 ww1 }) -}
f34cc0b8385cd0881b4bd37c798553ef
  $fShowFromString2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "FromString "#) -}
9de1f1c5c56bc150313b6f981a05186a
  $fShowFromString_$cshow ::
    Agpl_syntax.FromString -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.FromString ->
                 case x of wild { Agpl_syntax.FromString b1 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      Agpl_syntax.$fShowFromString2)
                   (Language.Haskell.TH.Syntax.$w$cshowsPrec5
                      11
                      b1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
9de1f1c5c56bc150313b6f981a05186a
  $fShowFromString_$cshowList ::
    [Agpl_syntax.FromString] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.FromString
                   Agpl_syntax.$fShowFromString1) -}
9de1f1c5c56bc150313b6f981a05186a
  $fShowFromString_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.FromString -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.FromString ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.FromString ww3 ->
                 Agpl_syntax.$w$cshowsPrec2 ww1 ww3 } }) -}
156b1b525f2358ad7a2bbc4e9bf3f87a
  $fShowGame :: GHC.Show.Show Agpl_syntax.Game
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.Game
                  Agpl_syntax.$fShowGame_$cshowsPrec
                  Agpl_syntax.$fShowGame_$cshow
                  Agpl_syntax.$fShowGame_$cshowList -}
156b1b525f2358ad7a2bbc4e9bf3f87a
  $fShowGame1 :: Agpl_syntax.Game -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Agpl_syntax.$fShowGame_$cshowsPrec
                   Agpl_syntax.$fShowGame2) -}
c2610655f087b918713a678c7725bf54
  $fShowGame2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0) -}
871c7054332f33d83571ccf90ab002f6
  $fShowGameState :: GHC.Show.Show Agpl_syntax.GameState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.GameState
                  Agpl_syntax.$fShowGameState_$cshowsPrec
                  Agpl_syntax.$fShowGameState_$cshow
                  Agpl_syntax.$fShowGameState_$cshowList -}
871c7054332f33d83571ccf90ab002f6
  $fShowGameState1 :: Agpl_syntax.GameState -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.GameState ->
                 case w of ww { Agpl_syntax.GameState ww1 ww2 ww3 ww4 ->
                 Agpl_syntax.$w$cshowsPrec3 0 ww1 ww2 ww3 ww4 }) -}
9aa14d341243adc543d3773e24a41fb8
  $fShowGameState2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
163d0acc6e80d23841d0db4f09b36bb2
  $fShowGameState3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turn = "#) -}
1411c413a20e5d1fa9300fd5e0590dac
  $fShowGameState4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hand = "#) -}
0bebe4b1ebb1f77bba73cba09476d448
  $fShowGameState5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "piece = "#) -}
393216c34c234026a55089ff32321efb
  $fShowGameState6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# ", "#) -}
60a5158ceca58bfb659aba73d58c27c1
  $fShowGameState7 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "board = "#) -}
49ed5b2e692a09ed6928f47976f6a4ac
  $fShowGameState8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "GameState {"#) -}
871c7054332f33d83571ccf90ab002f6
  $fShowGameState_$cshow :: Agpl_syntax.GameState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U,1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.GameState ->
                 Agpl_syntax.$fShowGameState_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
871c7054332f33d83571ccf90ab002f6
  $fShowGameState_$cshowList ::
    [Agpl_syntax.GameState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.GameState
                   Agpl_syntax.$fShowGameState1) -}
871c7054332f33d83571ccf90ab002f6
  $fShowGameState_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.GameState -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,1*U,1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.GameState ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.GameState ww3 ww4 ww5 ww6 ->
                 Agpl_syntax.$w$cshowsPrec3 ww1 ww3 ww4 ww5 ww6 } }) -}
156b1b525f2358ad7a2bbc4e9bf3f87a
  $fShowGame_$cshow :: Agpl_syntax.Game -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.Game ->
                 Agpl_syntax.$fShowGame_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
156b1b525f2358ad7a2bbc4e9bf3f87a
  $fShowGame_$cshowList :: [Agpl_syntax.Game] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.Game
                   Agpl_syntax.$fShowGame1) -}
156b1b525f2358ad7a2bbc4e9bf3f87a
  $fShowGame_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.Game -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
eb234e934f004d266de185b45dfeb6d3
  $fShowInitState :: GHC.Show.Show Agpl_syntax.InitState
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.InitState
                  Agpl_syntax.$fShowInitState_$cshowsPrec
                  Agpl_syntax.$fShowInitState_$cshow
                  Agpl_syntax.$fShowInitState_$cshowList -}
eb234e934f004d266de185b45dfeb6d3
  $fShowInitState1 :: Agpl_syntax.InitState -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.InitState ->
                 case w of ww { Agpl_syntax.InitState ww1 ww2 ->
                 Agpl_syntax.$w$cshowsPrec4 0 ww1 ww2 }) -}
dc08fdd2fc40f10c8f3004e455d968f6
  $fShowInitState2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "turnInit = "#) -}
dcc1e9f0f95021a6ea52926732e031f5
  $fShowInitState3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "boardInit = "#) -}
37b35d1bdd078cdebe5c6dbaa6c8e47a
  $fShowInitState4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "InitState {"#) -}
eb234e934f004d266de185b45dfeb6d3
  $fShowInitState_$cshow :: Agpl_syntax.InitState -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.InitState ->
                 Agpl_syntax.$fShowInitState_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
eb234e934f004d266de185b45dfeb6d3
  $fShowInitState_$cshowList ::
    [Agpl_syntax.InitState] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.InitState
                   Agpl_syntax.$fShowInitState1) -}
eb234e934f004d266de185b45dfeb6d3
  $fShowInitState_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.InitState -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U,1*U)>,
     Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.InitState ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.InitState ww3 ww4 ->
                 Agpl_syntax.$w$cshowsPrec4 ww1 ww3 ww4 } }) -}
6c84a7fea3c724bb4ea5a77b300f4d0d
  $fShowIsValidFun :: GHC.Show.Show Agpl_syntax.IsValidFun
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.IsValidFun
                  Agpl_syntax.$fShowIsValidFun_$cshowsPrec
                  Agpl_syntax.$fShowIsValidFun_$cshow
                  Agpl_syntax.$fShowIsValidFun_$cshowList -}
6c84a7fea3c724bb4ea5a77b300f4d0d
  $fShowIsValidFun1 :: Agpl_syntax.IsValidFun -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.IsValidFun ->
                 case w of ww { Agpl_syntax.IsValidFun ww1 ->
                 Agpl_syntax.$w$cshowsPrec5 0 ww1 }) -}
3046f2b90ec0e8efa788c1800531a8b3
  $fShowIsValidFun2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "IsValidFun "#) -}
6c84a7fea3c724bb4ea5a77b300f4d0d
  $fShowIsValidFun_$cshow ::
    Agpl_syntax.IsValidFun -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.IsValidFun ->
                 case x of wild { Agpl_syntax.IsValidFun b1 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr
                      @ GHC.Types.Char
                      @ b
                      c
                      n
                      Agpl_syntax.$fShowIsValidFun2)
                   (Language.Haskell.TH.Syntax.$w$cshowsPrec5
                      11
                      b1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
6c84a7fea3c724bb4ea5a77b300f4d0d
  $fShowIsValidFun_$cshowList ::
    [Agpl_syntax.IsValidFun] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.IsValidFun
                   Agpl_syntax.$fShowIsValidFun1) -}
6c84a7fea3c724bb4ea5a77b300f4d0d
  $fShowIsValidFun_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.IsValidFun -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.IsValidFun ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.IsValidFun ww3 ->
                 Agpl_syntax.$w$cshowsPrec5 ww1 ww3 } }) -}
c027ec37f3d8d7b80ac83549849cdc3e
  $fShowMove :: GHC.Show.Show Agpl_syntax.Move
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.Move
                  Agpl_syntax.$fShowMove_$cshowsPrec
                  Agpl_syntax.$fShowMove_$cshow
                  Agpl_syntax.$fShowMove_$cshowList -}
c027ec37f3d8d7b80ac83549849cdc3e
  $fShowMove1 :: Agpl_syntax.Move -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.Move ->
                 case w of ww { Agpl_syntax.Move ww1 ->
                 Agpl_syntax.$w$cshowsPrec6 0 ww1 }) -}
7b22693934dbf993b2ae19bfeb11d2ab
  $fShowMove2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Move "#) -}
c027ec37f3d8d7b80ac83549849cdc3e
  $fShowMove_$cshow :: Agpl_syntax.Move -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.Move ->
                 case x of wild { Agpl_syntax.Move b1 ->
                 GHC.Base.augment
                   @ GHC.Types.Char
                   (\ @ b c :: GHC.Types.Char -> b -> b[OneShot] n :: b[OneShot] ->
                    GHC.Base.foldr @ GHC.Types.Char @ b c n Agpl_syntax.$fShowMove2)
                   (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                      11
                      b1
                      (GHC.Types.[] @ GHC.Types.Char)) }) -}
c027ec37f3d8d7b80ac83549849cdc3e
  $fShowMove_$cshowList :: [Agpl_syntax.Move] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.Move
                   Agpl_syntax.$fShowMove1) -}
c027ec37f3d8d7b80ac83549849cdc3e
  $fShowMove_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.Move -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U(1*U)>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.Move ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.Move ww3 ->
                 Agpl_syntax.$w$cshowsPrec6 ww1 ww3 } }) -}
0305492e3b70695edb64cf4eacecc879
  $fShowOutcomeFun :: GHC.Show.Show Agpl_syntax.OutcomeFun
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.OutcomeFun
                  Agpl_syntax.$fShowOutcomeFun_$cshowsPrec
                  Agpl_syntax.$fShowOutcomeFun_$cshow
                  Agpl_syntax.$fShowOutcomeFun_$cshowList -}
0305492e3b70695edb64cf4eacecc879
  $fShowOutcomeFun1 :: Agpl_syntax.OutcomeFun -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (\ w :: Agpl_syntax.OutcomeFun ->
                 Agpl_syntax.$w$cshowsPrec7 0 w) -}
63979204954308fba8a8a27fa6eefbd8
  $fShowOutcomeFun2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "elsecon = "#) -}
78097d7dd2b525acbe0747add196c2fa
  $fShowOutcomeFun3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "tiecon = "#) -}
3e291da461d3fa30d98491f913d57e33
  $fShowOutcomeFun4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "wincon = "#) -}
97344c0e72979c3710c5e4818814d71d
  $fShowOutcomeFun5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "OutcomeFun {"#) -}
bd75c026fe644cb97fc307abeda7ff04
  $fShowOutcomeFun6 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "CustOutcomeFun "#) -}
0305492e3b70695edb64cf4eacecc879
  $fShowOutcomeFun_$cshow ::
    Agpl_syntax.OutcomeFun -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.OutcomeFun ->
                 Agpl_syntax.$fShowOutcomeFun_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
0305492e3b70695edb64cf4eacecc879
  $fShowOutcomeFun_$cshowList ::
    [Agpl_syntax.OutcomeFun] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.OutcomeFun
                   Agpl_syntax.$fShowOutcomeFun1) -}
0305492e3b70695edb64cf4eacecc879
  $fShowOutcomeFun_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.OutcomeFun -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <S,1*U(U)><S,1*U>, Inline: INLINE[0],
     Unfolding: InlineRule (2, True, False)
                (\ w :: GHC.Types.Int w1 :: Agpl_syntax.OutcomeFun ->
                 case w of ww { GHC.Types.I# ww1 ->
                 Agpl_syntax.$w$cshowsPrec7 ww1 w1 }) -}
153b6c1fe30397fa22e3d9401e47e221
  $fShowPlayer :: GHC.Show.Show Agpl_syntax.Player
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.Player
                  Agpl_syntax.$fShowPlayer_$cshowsPrec
                  Agpl_syntax.$fShowPlayer_$cshow
                  Agpl_syntax.$fShowPlayer_$cshowList -}
153b6c1fe30397fa22e3d9401e47e221
  $fShowPlayer1 :: Agpl_syntax.Player -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (\ w :: Agpl_syntax.Player w1 :: GHC.Base.String ->
                 case w of ww { Agpl_syntax.Player ww1 ->
                 Agpl_syntax.$w$cshowsPrec8 0 ww1 w1 }) -}
de0c4bca11a5bc804929da6880d53b3f
  $fShowPlayer2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Player "#) -}
153b6c1fe30397fa22e3d9401e47e221
  $fShowPlayer_$cshow :: Agpl_syntax.Player -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U(1*U(1*U,U(U)))>,
     Unfolding: InlineRule (1, True, False)
                (\ x :: Agpl_syntax.Player ->
                 Agpl_syntax.$fShowPlayer_$cshowsPrec
                   GHC.Show.shows18
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
153b6c1fe30397fa22e3d9401e47e221
  $fShowPlayer_$cshowList :: [Agpl_syntax.Player] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.Player
                   Agpl_syntax.$fShowPlayer1) -}
153b6c1fe30397fa22e3d9401e47e221
  $fShowPlayer_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.Player -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <S,1*U(U)><S,1*U(1*U(1*U,U(U)))><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ w :: GHC.Types.Int
                   w1 :: Agpl_syntax.Player
                   w2 :: GHC.Base.String ->
                 case w of ww { GHC.Types.I# ww1 ->
                 case w1 of ww2 { Agpl_syntax.Player ww3 ->
                 Agpl_syntax.$w$cshowsPrec8 ww1 ww3 w2 } }) -}
5753c96b872cf107753d361a048f55b0
  $fShowPossMovesFun :: GHC.Show.Show Agpl_syntax.PossMovesFun
  DFunId[0]
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Agpl_syntax.PossMovesFun
                  Agpl_syntax.$fShowPossMovesFun_$cshowsPrec
                  Agpl_syntax.$fShowPossMovesFun_$cshow
                  Agpl_syntax.$fShowPossMovesFun_$cshowList -}
5753c96b872cf107753d361a048f55b0
  $fShowPossMovesFun1 :: Agpl_syntax.PossMovesFun -> GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (Agpl_syntax.$fShowPossMovesFun_$cshowsPrec
                   Agpl_syntax.$fShowGame2) -}
c69d3dcee15500b8c35884188e2fafa0
  $fShowPossMovesFun2 :: GHC.Show.ShowS
  {- Arity: 1,
     Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Agpl_syntax.$fShowPossMovesFun3) -}
c192026092c3f295b5bbc9973beb3a2a
  $fShowPossMovesFun3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PMNil"#) -}
83ac352818e7e3369055d1a58fc8c278
  $fShowPossMovesFun4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "PossMovesFun "#) -}
5753c96b872cf107753d361a048f55b0
  $fShowPossMovesFun_$cshow ::
    Agpl_syntax.PossMovesFun -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ x :: Agpl_syntax.PossMovesFun ->
                 case x of wild {
                   Agpl_syntax.PossMovesFun b1
                   -> GHC.Base.++
                        @ GHC.Types.Char
                        Agpl_syntax.$fShowPossMovesFun4
                        (Language.Haskell.TH.Syntax.$w$cshowsPrec5
                           11
                           b1
                           (GHC.Types.[] @ GHC.Types.Char))
                   Agpl_syntax.PMNil -> Agpl_syntax.$fShowPossMovesFun3 }) -}
5753c96b872cf107753d361a048f55b0
  $fShowPossMovesFun_$cshowList ::
    [Agpl_syntax.PossMovesFun] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Agpl_syntax.PossMovesFun
                   Agpl_syntax.$fShowPossMovesFun1) -}
5753c96b872cf107753d361a048f55b0
  $fShowPossMovesFun_$cshowsPrec ::
    GHC.Types.Int -> Agpl_syntax.PossMovesFun -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,1*U(U)><S,1*U>,
     Unfolding: (\ a :: GHC.Types.Int ds :: Agpl_syntax.PossMovesFun ->
                 case ds of wild {
                   Agpl_syntax.PossMovesFun b1
                   -> case a of wild1 { GHC.Types.I# x ->
                      let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec5 11 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# x 11) of wild2 {
                        GHC.Types.False
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowPossMovesFun4 (g x1)
                        GHC.Types.True
                        -> \ x1 :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Agpl_syntax.$fShowPossMovesFun4
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x1))) } }
                   Agpl_syntax.PMNil -> Agpl_syntax.$fShowPossMovesFun2 }) -}
c75d27e513d9668ca9ff65ae62b51e2d
  $w$cshowsPrec ::
    GHC.Prim.Int# -> Agpl_syntax.Board -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: Agpl_syntax.Board ->
                 case w of wild {
                   Agpl_syntax.Matrix b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Agpl_syntax.$fShowBoard4
                            (case b1 of ww1 { (,) ww2 ww3 ->
                             GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows9
                               (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                                  0
                                  ww2
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__1
                                     (GHC.List.foldr1_$sfoldr1
                                        @ (GHC.Base.String -> GHC.Base.String)
                                        GHC.Show.$fShow(,)1
                                        (\ w4 :: GHC.Base.String ->
                                         case ww3 of ww4 { (,) ww5 ww6 ->
                                         GHC.Types.:
                                           @ GHC.Types.Char
                                           GHC.Show.shows9
                                           (case GHC.Show.$w$cshowsPrec1
                                                   0
                                                   ww5
                                                   (GHC.Types.:
                                                      @ GHC.Types.Char
                                                      GHC.Show.showList__1
                                                      (GHC.List.foldr1_$sfoldr1
                                                         @ (GHC.Base.String -> GHC.Base.String)
                                                         GHC.Show.$fShow(,)1
                                                         (\ w2 :: GHC.Base.String ->
                                                          case GHC.Show.$w$cshowsPrec1
                                                                 0
                                                                 ww6
                                                                 w2 of ww7 { (#,#) ww8 ww9 ->
                                                          GHC.Types.: @ GHC.Types.Char ww8 ww9 })
                                                         (GHC.Types.[] @ GHC.Show.ShowS)
                                                         (GHC.Types.:
                                                            @ GHC.Types.Char
                                                            GHC.Show.shows8
                                                            w4))) of ww7 { (#,#) ww8 ww9 ->
                                            GHC.Types.: @ GHC.Types.Char ww8 ww9 }) })
                                        (GHC.Types.[] @ GHC.Show.ShowS)
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)))) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   Agpl_syntax.Array b1
                   -> let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Agpl_syntax.$fShowBoard3
                            (case b1 of ww1 { (,) ww2 ww3 ->
                             GHC.Types.:
                               @ GHC.Types.Char
                               GHC.Show.shows9
                               (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                                  0
                                  ww2
                                  (GHC.Types.:
                                     @ GHC.Types.Char
                                     GHC.Show.showList__1
                                     (GHC.List.foldr1_$sfoldr1
                                        @ (GHC.Base.String -> GHC.Base.String)
                                        GHC.Show.$fShow(,)1
                                        (\ w2 :: GHC.Base.String ->
                                         case GHC.Show.$w$cshowsPrec1
                                                0
                                                ww3
                                                w2 of ww4 { (#,#) ww5 ww6 ->
                                         GHC.Types.: @ GHC.Types.Char ww5 ww6 })
                                        (GHC.Types.[] @ GHC.Show.ShowS)
                                        (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)))) })
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }
                   Agpl_syntax.Board b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec8 11 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowBoard2 (g x)
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Agpl_syntax.$fShowBoard2
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) } }) -}
0eb4ef1b10d92006029a94fbe448ea31
  $w$cshowsPrec1 ::
    GHC.Prim.Int# -> Language.Haskell.TH.Syntax.Dec -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Language.Haskell.TH.Syntax.Dec ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec8 11 ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++
                        @ GHC.Types.Char
                        Agpl_syntax.$fShowCustomDataType2
                        (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Agpl_syntax.$fShowCustomDataType2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
ea4a93345751f68f18eaf6c1bc6a3bb8
  $w$cshowsPrec2 ::
    GHC.Prim.Int# -> Language.Haskell.TH.Syntax.Exp -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Language.Haskell.TH.Syntax.Exp ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec5 11 ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowFromString2 (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Agpl_syntax.$fShowFromString2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
5cbaf4896e3ba12e0e685147bb136113
  $w$cshowsPrec3 ::
    GHC.Prim.Int#
    -> Agpl_syntax.Board
    -> Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Dec
    -> Language.Haskell.TH.Syntax.Dec
    -> GHC.Show.ShowS
  {- Arity: 5, Strictness: <L,U><L,1*U><L,1*U><L,1*U><L,1*U>,
     Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Agpl_syntax.Board
                   ww2 :: Language.Haskell.TH.Syntax.Dec
                   ww3 :: Language.Haskell.TH.Syntax.Dec
                   ww4 :: Language.Haskell.TH.Syntax.Dec ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Agpl_syntax.$w$cshowsPrec 0 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec8 0 ww2
                 } in
                 let {
                   f2 :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec8 0 ww3
                 } in
                 let {
                   f3 :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec8 0 ww4
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Agpl_syntax.$fShowGameState8
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Agpl_syntax.$fShowGameState7
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                Agpl_syntax.$fShowGameState6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Agpl_syntax.$fShowGameState5
                                   (f1
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Agpl_syntax.$fShowGameState6
                                         (GHC.Base.++
                                            @ GHC.Types.Char
                                            Agpl_syntax.$fShowGameState4
                                            (f2
                                               (GHC.Base.++
                                                  @ GHC.Types.Char
                                                  Agpl_syntax.$fShowGameState6
                                                  (GHC.Base.++
                                                     @ GHC.Types.Char
                                                     Agpl_syntax.$fShowGameState3
                                                     (f3
                                                        (GHC.Base.++
                                                           @ GHC.Types.Char
                                                           Agpl_syntax.$fShowGameState2
                                                           x))))))))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
1f9e4c160b8802376e18584c24d35fa1
  $w$cshowsPrec4 ::
    GHC.Prim.Int#
    -> Language.Haskell.TH.Syntax.Exp
    -> Language.Haskell.TH.Syntax.Exp
    -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U><L,1*U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Language.Haskell.TH.Syntax.Exp
                   ww2 :: Language.Haskell.TH.Syntax.Exp ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec5 0 ww1
                 } in
                 let {
                   f1 :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec5 0 ww2
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ x :: GHC.Base.String ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Agpl_syntax.$fShowInitState4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Agpl_syntax.$fShowInitState3
                          (f (GHC.Base.++
                                @ GHC.Types.Char
                                Agpl_syntax.$fShowGameState6
                                (GHC.Base.++
                                   @ GHC.Types.Char
                                   Agpl_syntax.$fShowInitState2
                                   (f1
                                      (GHC.Base.++
                                         @ GHC.Types.Char
                                         Agpl_syntax.$fShowGameState2
                                         x))))))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) }) -}
cdeae3ecab022ca40806d34af1690d08
  $w$cshowsPrec5 ::
    GHC.Prim.Int# -> Language.Haskell.TH.Syntax.Exp -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Language.Haskell.TH.Syntax.Exp ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec5 11 ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowIsValidFun2 (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Agpl_syntax.$fShowIsValidFun2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
d0d0b1f2745fc4747c510e4a92c5dd99
  $w$cshowsPrec6 ::
    GHC.Prim.Int# -> Language.Haskell.TH.Syntax.Dec -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><L,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: Language.Haskell.TH.Syntax.Dec ->
                 let {
                   g :: GHC.Base.String -> GHC.Base.String
                   = Language.Haskell.TH.Syntax.$w$cshowsPrec8 11 ww1
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False
                   -> \ x :: GHC.Base.String ->
                      GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowMove2 (g x)
                   GHC.Types.True
                   -> \ x :: GHC.Base.String ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (GHC.Base.++
                           @ GHC.Types.Char
                           Agpl_syntax.$fShowMove2
                           (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }) -}
0305492e3b70695edb64cf4eacecc879
  $w$cshowsPrec7 ::
    GHC.Prim.Int# -> Agpl_syntax.OutcomeFun -> GHC.Show.ShowS
  {- Arity: 2, Strictness: <L,U><S,1*U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int# w :: Agpl_syntax.OutcomeFun ->
                 case w of wild {
                   Agpl_syntax.CustOutcomeFun b1
                   -> let {
                        g :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec5 11 b1
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False
                        -> \ x :: GHC.Base.String ->
                           GHC.Base.++ @ GHC.Types.Char Agpl_syntax.$fShowOutcomeFun6 (g x)
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (GHC.Base.++
                                @ GHC.Types.Char
                                Agpl_syntax.$fShowOutcomeFun6
                                (g (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x))) }
                   Agpl_syntax.OutcomeFun b1 b2 b3
                   -> let {
                        f :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec5 0 b1
                      } in
                      let {
                        f1 :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec5 0 b2
                      } in
                      let {
                        f2 :: GHC.Base.String -> GHC.Base.String
                        = Language.Haskell.TH.Syntax.$w$cshowsPrec5 0 b3
                      } in
                      let {
                        p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                        = \ x :: GHC.Base.String ->
                          GHC.Base.++
                            @ GHC.Types.Char
                            Agpl_syntax.$fShowOutcomeFun5
                            (GHC.Base.++
                               @ GHC.Types.Char
                               Agpl_syntax.$fShowOutcomeFun4
                               (f (GHC.Base.++
                                     @ GHC.Types.Char
                                     Agpl_syntax.$fShowGameState6
                                     (GHC.Base.++
                                        @ GHC.Types.Char
                                        Agpl_syntax.$fShowOutcomeFun3
                                        (f1
                                           (GHC.Base.++
                                              @ GHC.Types.Char
                                              Agpl_syntax.$fShowGameState6
                                              (GHC.Base.++
                                                 @ GHC.Types.Char
                                                 Agpl_syntax.$fShowOutcomeFun2
                                                 (f2
                                                    (GHC.Base.++
                                                       @ GHC.Types.Char
                                                       Agpl_syntax.$fShowGameState2
                                                       x)))))))))
                      } in
                      case GHC.Prim.tagToEnum#
                             @ GHC.Types.Bool
                             (GHC.Prim.>=# ww 11) of wild1 {
                        GHC.Types.False -> p
                        GHC.Types.True
                        -> \ x :: GHC.Base.String ->
                           GHC.Types.:
                             @ GHC.Types.Char
                             GHC.Show.shows9
                             (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)) } }) -}
ddaf7b1cd70b550353114c761f32d09a
  $w$cshowsPrec8 ::
    GHC.Prim.Int#
    -> (Language.Haskell.TH.Syntax.Dec, GHC.Types.Int)
    -> GHC.Base.String
    -> GHC.Base.String
  {- Arity: 3, Strictness: <L,U><L,1*U(1*U,U(U))><L,U>, Inline: [0],
     Unfolding: (\ ww :: GHC.Prim.Int#
                   ww1 :: (Language.Haskell.TH.Syntax.Dec, GHC.Types.Int)
                   w :: GHC.Base.String ->
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,U> -}
                   = \ x :: GHC.Base.String[OneShot] ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Agpl_syntax.$fShowPlayer2
                       (case ww1 of ww2 { (,) ww3 ww4 ->
                        GHC.Types.:
                          @ GHC.Types.Char
                          GHC.Show.shows9
                          (Language.Haskell.TH.Syntax.$w$cshowsPrec8
                             0
                             ww3
                             (GHC.Types.:
                                @ GHC.Types.Char
                                GHC.Show.showList__1
                                (GHC.List.foldr1_$sfoldr1
                                   @ (GHC.Base.String -> GHC.Base.String)
                                   GHC.Show.$fShow(,)1
                                   (\ w2 :: GHC.Base.String ->
                                    case ww4 of ww5 { GHC.Types.I# ww6 ->
                                    case GHC.Show.$wshowSignedInt 0 ww6 w2 of ww7 { (#,#) ww8 ww9 ->
                                    GHC.Types.: @ GHC.Types.Char ww8 ww9 } })
                                   (GHC.Types.[] @ GHC.Show.ShowS)
                                   (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 x)))) })
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11) of wild {
                   GHC.Types.False -> p w
                   GHC.Types.True
                   -> GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows9
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows8 w)) }) -}
c75d27e513d9668ca9ff65ae62b51e2d
  data Board
    = Matrix (Language.Haskell.TH.Syntax.Dec,
              (GHC.Integer.Type.Integer, GHC.Integer.Type.Integer))
    | Array (Language.Haskell.TH.Syntax.Dec, GHC.Integer.Type.Integer)
    | Board Language.Haskell.TH.Syntax.Dec
ce25e86f36dd09be7a3f1a633a33205a
  data CustomDataType = CustomDataType Language.Haskell.TH.Syntax.Dec
9de1f1c5c56bc150313b6f981a05186a
  data FromString = FromString Language.Haskell.TH.Syntax.Exp
156b1b525f2358ad7a2bbc4e9bf3f87a
  data Game
    = Game (Agpl_syntax.GameID,
            Agpl_syntax.GameState,
            Agpl_syntax.Move,
            Agpl_syntax.IsValidFun,
            Agpl_syntax.PossMovesFun,
            Agpl_syntax.OutcomeFun,
            Agpl_syntax.InitState,
            Agpl_syntax.Player,
            Agpl_syntax.FromString,
            [Language.Haskell.TH.Syntax.Dec],
            [Language.Haskell.TH.Syntax.Dec])
    | NIL
3c57968a5e76d8451c337c1b67566c5b
  type GameID = GHC.Base.String
871c7054332f33d83571ccf90ab002f6
  data GameState
    = GameState {board :: Agpl_syntax.Board,
                 piece :: Language.Haskell.TH.Syntax.Dec,
                 hand :: Language.Haskell.TH.Syntax.Dec,
                 turn :: Language.Haskell.TH.Syntax.Dec}
eb234e934f004d266de185b45dfeb6d3
  data InitState
    = InitState {boardInit :: Language.Haskell.TH.Syntax.Exp,
                 turnInit :: Language.Haskell.TH.Syntax.Exp}
6c84a7fea3c724bb4ea5a77b300f4d0d
  data IsValidFun = IsValidFun Language.Haskell.TH.Syntax.Exp
c027ec37f3d8d7b80ac83549849cdc3e
  data Move = Move Language.Haskell.TH.Syntax.Dec
0305492e3b70695edb64cf4eacecc879
  data OutcomeFun
    = CustOutcomeFun Language.Haskell.TH.Syntax.Exp
    | OutcomeFun {wincon :: Language.Haskell.TH.Syntax.Exp,
                  tiecon :: Language.Haskell.TH.Syntax.Exp,
                  elsecon :: Language.Haskell.TH.Syntax.Exp}
153b6c1fe30397fa22e3d9401e47e221
  data Player
    = Player (Language.Haskell.TH.Syntax.Dec, GHC.Types.Int)
5753c96b872cf107753d361a048f55b0
  data PossMovesFun
    = PossMovesFun Language.Haskell.TH.Syntax.Exp | PMNil
2c316276ae18138e2c2a47e9c966e4f0
  board :: Agpl_syntax.GameState -> Agpl_syntax.Board
  RecSel Agpl_syntax.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SLLL),1*U(1*U,A,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.GameState ->
                 case ds of wild { Agpl_syntax.GameState ds1 ds2 ds3 ds4 ->
                 ds1 }) -}
a1599c207cb1a9360a3751511be41345
  boardInit ::
    Agpl_syntax.InitState -> Language.Haskell.TH.Syntax.Exp
  RecSel Agpl_syntax.InitState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),1*U(1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.InitState ->
                 case ds of wild { Agpl_syntax.InitState ds1 ds2 -> ds1 }) -}
46e2bb0b288855d07122cc45ec9a4a38
  elsecon :: Agpl_syntax.OutcomeFun -> Language.Haskell.TH.Syntax.Exp
  RecSel Agpl_syntax.OutcomeFun
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.OutcomeFun ->
                 case ds of wild {
                   Agpl_syntax.CustOutcomeFun ipv -> Agpl_syntax.elsecon1
                   Agpl_syntax.OutcomeFun ds1 ds2 ds3 -> ds3 }) -}
ce9fe83219a82462a9c72f170f5a719e
  elsecon1 :: Language.Haskell.TH.Syntax.Exp
  {- Strictness: b -}
445609a9a462f8ede27301f8c56c89aa
  hand :: Agpl_syntax.GameState -> Language.Haskell.TH.Syntax.Dec
  RecSel Agpl_syntax.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLSL),1*U(A,A,1*U,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.GameState ->
                 case ds of wild { Agpl_syntax.GameState ds1 ds2 ds3 ds4 ->
                 ds3 }) -}
5cffbb5bcc8b2fd379d0d16984165ecf
  piece :: Agpl_syntax.GameState -> Language.Haskell.TH.Syntax.Dec
  RecSel Agpl_syntax.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LSLL),1*U(A,1*U,A,A)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.GameState ->
                 case ds of wild { Agpl_syntax.GameState ds1 ds2 ds3 ds4 ->
                 ds2 }) -}
44ebc67cc0e798682233058f3dc90479
  tiecon :: Agpl_syntax.OutcomeFun -> Language.Haskell.TH.Syntax.Exp
  RecSel Agpl_syntax.OutcomeFun
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.OutcomeFun ->
                 case ds of wild {
                   Agpl_syntax.CustOutcomeFun ipv -> Agpl_syntax.tiecon1
                   Agpl_syntax.OutcomeFun ds1 ds2 ds3 -> ds2 }) -}
bcbc355d5a5d293cd9f91c3774ad3434
  tiecon1 :: Language.Haskell.TH.Syntax.Exp
  {- Strictness: b -}
3bf320bf15c8260db9c1a64ddc880aff
  turn :: Agpl_syntax.GameState -> Language.Haskell.TH.Syntax.Dec
  RecSel Agpl_syntax.GameState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LLLS),1*U(A,A,A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.GameState ->
                 case ds of wild { Agpl_syntax.GameState ds1 ds2 ds3 ds4 ->
                 ds4 }) -}
40f33898b60bb1d95ca0635a1258fdd7
  turnInit :: Agpl_syntax.InitState -> Language.Haskell.TH.Syntax.Exp
  RecSel Agpl_syntax.InitState
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),1*U(A,1*U)>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.InitState ->
                 case ds of wild { Agpl_syntax.InitState ds1 ds2 -> ds2 }) -}
807686047d65c4f03f925e7bdf9b6ad4
  wincon :: Agpl_syntax.OutcomeFun -> Language.Haskell.TH.Syntax.Exp
  RecSel Agpl_syntax.OutcomeFun
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ ds :: Agpl_syntax.OutcomeFun ->
                 case ds of wild {
                   Agpl_syntax.CustOutcomeFun ipv -> Agpl_syntax.wincon1
                   Agpl_syntax.OutcomeFun ds1 ds2 ds3 -> ds1 }) -}
f247cc77fd35cafaa0a02edcfad0a2cd
  wincon1 :: Language.Haskell.TH.Syntax.Exp
  {- Strictness: b -}
instance GHC.Show.Show [Agpl_syntax.Board]
  = Agpl_syntax.$fShowBoard
instance GHC.Show.Show [Agpl_syntax.CustomDataType]
  = Agpl_syntax.$fShowCustomDataType
instance GHC.Show.Show [Agpl_syntax.FromString]
  = Agpl_syntax.$fShowFromString
instance GHC.Show.Show [Agpl_syntax.Game] = Agpl_syntax.$fShowGame
instance GHC.Show.Show [Agpl_syntax.GameState]
  = Agpl_syntax.$fShowGameState
instance GHC.Show.Show [Agpl_syntax.InitState]
  = Agpl_syntax.$fShowInitState
instance GHC.Show.Show [Agpl_syntax.IsValidFun]
  = Agpl_syntax.$fShowIsValidFun
instance GHC.Show.Show [Agpl_syntax.Move] = Agpl_syntax.$fShowMove
instance GHC.Show.Show [Agpl_syntax.OutcomeFun]
  = Agpl_syntax.$fShowOutcomeFun
instance GHC.Show.Show [Agpl_syntax.Player]
  = Agpl_syntax.$fShowPlayer
instance GHC.Show.Show [Agpl_syntax.PossMovesFun]
  = Agpl_syntax.$fShowPossMovesFun
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: none
require own pkg trusted: False

