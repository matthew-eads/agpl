import Agpl_lib
import test_lib
TicTacToe: Game

Gamestate: {
           Board: {Matrix[3][3]}
           Piece: {X | O}
}

Player: {PX | PO}

Move: {(Int, Int)}
isValid: { (\(Move (i, j)) -> ((inBounds (i,j)) && (isEmpty (i,j) game)))}

-- isValid: { inBounds move && isEmpty move }


possMoves: {mfold (\((i, j), piece, acc) -> if piece == Nil then (Move(i, j):acc)
                                                        else acc) [] (board game)}

outcome: {\(Move move) -> 
  let t = otherPlayer (currentTurn game)
      b = if isFull (board game) 
            then (board game) 
            else setElem (playerToPiece (currentTurn game)) move (board game)
      g = (GameState{board=b, currentTurn = t})
  in 
    if (inRow 3 (currentTurn game) b) || (inCol 3 (currentTurn game) b) || (inDiag 3 (currentTurn game) b)
    then (Win (currentTurn game), 1)
    else if isFull b then (Tie, 1)
    else (g, 1) 
} 
{-
outcome: {
         winCondition: { (inRow 3 (currentTurn game)) || (inCol 3 (currentTurn game)) ||
                         (inDiag 3 (currentTurn game))}
         tieCondition: {isFull (board game)}
         else: {place (playerToPiece (currentTurn game)) move}}

-}


initialState:{Board: {[[Nil, Nil, Nil],
                       [Nil, Nil, Nil],
                       [Nil, Nil, Nil]]}
              Turn: {PX}}
--Board: <<matrix 3 3 (\(i,j) -> Nil)>>
--Board: {all Nil}
--Board: {[[Nil, Nil, Nil],
--         [Nil, Nil, Nil],
--         [Nil, Nil, Nil]]}          

fromString: {\(s) -> let move = L.map read (splitOn "," s) in (Move ((L.head move), (L.head (L.tail move))))}

$
pieceToPlayer :: Piece -> Player
pieceToPlayer X = PX
pieceToPlayer O = PO
playerToPiece :: Player -> Piece
playerToPiece PX = X
playerToPiece PO = O
otherPlayer :: Player -> Player
otherPlayer PX = PO
otherPlayer PO = PX
$

