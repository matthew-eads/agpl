TicTacToe: Game

Gamestate: {
           Board: {Matrix}
           Piece: {X | O | Nil}
}

Player: {PX | PO}

--Type Coord: {Coord (Int, Int)}
--Move: {Move (Coord)}

Move: {(Int, Int)}
isValid: { (\(Move (i, j)) -> ((i < 3) && (j < 3) &&
                         (i >= 0) && (j >= 0) && ((board game) ! (i,j)) == Nil))}


possMoves: {mfold (\((i, j), piece, acc) -> if piece == Nil then ((i, j):acc)
                                                        else acc) [] (board game)}

{- $fun ne (x, y) = (x+1,y+1)
 fun e  (x, y) = (x+1, y)
 fun se (x, y) = (x+1, y-1)
 fun s  (x, y) = (x, y-1)
 fun sw (x, y) = (x-1, y-1)
 fun w  (x, y) = (x-1, y)
 fun nw (x, y) = (x-1, y+1)
 fun n  (x, y) = (x, y+1)$
-}
outcome: {\(x) -> if (((board game) ! ((fst (n x)), (snd (n x))) ==
                      (board game) ! ((fst (s x)), (snd (s x)))) &&
                     ((board game) ! ((fst (n x)), (snd (n x))) ==
                      (board game) ! ((fst x), (snd x))))   
                  then 1 --Fin(Game.Board[fst x][snd x], 2)
                   --etc
                  else 0
         }

initialState:{Board: {matrix 3 3 (\(i,j) -> Nil)}
              Turn: {X}}
